!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ABORT_CHAR	readline/chardefs.h	64;"	d
ABORT_CHAR	readline/chardefs.h	66;"	d
ALLOC_BUF	g++/libioP.h	502;"	d
ALLOC_BUF	g++/libioP.h	515;"	d
AND	ansidecl.h	106;"	d
AND	ansidecl.h	131;"	d
ANSI_PROTOTYPES	ansidecl.h	112;"	d
ActivateMask	tk.h	417;"	d
ActivateNotify	tk.h	412;"	d
BFD64	bfd.h	64;"	d
BFDLINK_H	bfdlink.h	22;"	d
BFD_ABS_SECTION_NAME	bfd.h	1120;"	d
BFD_ARCH_SIZE	bfd.h	56;"	d
BFD_COM_SECTION_NAME	bfd.h	1122;"	d
BFD_ENDIAN_BIG	bfd.h	/^enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };$/;"	e	enum:bfd_endian
BFD_ENDIAN_LITTLE	bfd.h	/^enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };$/;"	e	enum:bfd_endian
BFD_ENDIAN_UNKNOWN	bfd.h	/^enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };$/;"	e	enum:bfd_endian
BFD_FORT_COMM_DEFAULT_VALUE	bfd.h	2171;"	d
BFD_HOST_64BIT_LONG	bfd.h	57;"	d
BFD_HOST_64_BIT	bfd.h	128;"	d
BFD_HOST_64_BIT	bfd.h	132;"	d
BFD_HOST_U_64_BIT	bfd.h	129;"	d
BFD_HOST_U_64_BIT	bfd.h	133;"	d
BFD_IND_SECTION_NAME	bfd.h	1123;"	d
BFD_IN_MEMORY	bfd.h	249;"	d
BFD_IS_RELAXABLE	bfd.h	239;"	d
BFD_JUMP_TABLE_ARCHIVE	bfd.h	2732;"	d
BFD_JUMP_TABLE_COPY	bfd.h	2695;"	d
BFD_JUMP_TABLE_CORE	bfd.h	2723;"	d
BFD_JUMP_TABLE_DYNAMIC	bfd.h	2868;"	d
BFD_JUMP_TABLE_GENERIC	bfd.h	2674;"	d
BFD_JUMP_TABLE_LINK	bfd.h	2832;"	d
BFD_JUMP_TABLE_RELOCS	bfd.h	2810;"	d
BFD_JUMP_TABLE_SYMBOLS	bfd.h	2761;"	d
BFD_JUMP_TABLE_WRITE	bfd.h	2823;"	d
BFD_NO_FLAGS	bfd.h	202;"	d
BFD_NO_MORE_SYMBOLS	bfd.h	259;"	d
BFD_RELOC_12_PCREL	bfd.h	/^  BFD_RELOC_12_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_14	bfd.h	/^  BFD_RELOC_14,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_16	bfd.h	/^  BFD_RELOC_16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_16_BASEREL	bfd.h	/^  BFD_RELOC_16_BASEREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_16_GOTOFF	bfd.h	/^  BFD_RELOC_16_GOTOFF,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_16_GOT_PCREL	bfd.h	/^  BFD_RELOC_16_GOT_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_16_PCREL	bfd.h	/^  BFD_RELOC_16_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_16_PCREL_S2	bfd.h	/^  BFD_RELOC_16_PCREL_S2,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_16_PLTOFF	bfd.h	/^  BFD_RELOC_16_PLTOFF,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_16_PLT_PCREL	bfd.h	/^  BFD_RELOC_16_PLT_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_23_PCREL_S2	bfd.h	/^  BFD_RELOC_23_PCREL_S2,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_24	bfd.h	/^  BFD_RELOC_24,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_24_PCREL	bfd.h	/^  BFD_RELOC_24_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_24_PLT_PCREL	bfd.h	/^  BFD_RELOC_24_PLT_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_26	bfd.h	/^  BFD_RELOC_26,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_32	bfd.h	/^  BFD_RELOC_32,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_32_BASEREL	bfd.h	/^  BFD_RELOC_32_BASEREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_32_GOTOFF	bfd.h	/^  BFD_RELOC_32_GOTOFF,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_32_GOT_PCREL	bfd.h	/^  BFD_RELOC_32_GOT_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_32_PCREL	bfd.h	/^  BFD_RELOC_32_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_32_PCREL_S2	bfd.h	/^  BFD_RELOC_32_PCREL_S2,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_32_PLTOFF	bfd.h	/^  BFD_RELOC_32_PLTOFF,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_32_PLT_PCREL	bfd.h	/^  BFD_RELOC_32_PLT_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_386_COPY	bfd.h	/^  BFD_RELOC_386_COPY,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_386_GLOB_DAT	bfd.h	/^  BFD_RELOC_386_GLOB_DAT,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_386_GOT32	bfd.h	/^  BFD_RELOC_386_GOT32,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_386_GOTOFF	bfd.h	/^  BFD_RELOC_386_GOTOFF,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_386_GOTPC	bfd.h	/^  BFD_RELOC_386_GOTPC,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_386_JUMP_SLOT	bfd.h	/^  BFD_RELOC_386_JUMP_SLOT,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_386_PLT32	bfd.h	/^  BFD_RELOC_386_PLT32,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_386_RELATIVE	bfd.h	/^  BFD_RELOC_386_RELATIVE,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_64	bfd.h	/^  BFD_RELOC_64,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_64_PCREL	bfd.h	/^  BFD_RELOC_64_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_68K_GLOB_DAT	bfd.h	/^  BFD_RELOC_68K_GLOB_DAT,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_68K_JMP_SLOT	bfd.h	/^  BFD_RELOC_68K_JMP_SLOT,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_68K_RELATIVE	bfd.h	/^  BFD_RELOC_68K_RELATIVE,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_8	bfd.h	/^  BFD_RELOC_8,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_8_BASEREL	bfd.h	/^  BFD_RELOC_8_BASEREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_8_FFnn	bfd.h	/^  BFD_RELOC_8_FFnn,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_8_GOTOFF	bfd.h	/^  BFD_RELOC_8_GOTOFF,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_8_GOT_PCREL	bfd.h	/^  BFD_RELOC_8_GOT_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_8_PCREL	bfd.h	/^  BFD_RELOC_8_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_8_PLTOFF	bfd.h	/^  BFD_RELOC_8_PLTOFF,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_8_PLT_PCREL	bfd.h	/^  BFD_RELOC_8_PLT_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ALPHA_CODEADDR	bfd.h	/^  BFD_RELOC_ALPHA_CODEADDR,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ALPHA_ELF_LITERAL	bfd.h	/^  BFD_RELOC_ALPHA_ELF_LITERAL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ALPHA_GPDISP	bfd.h	/^  BFD_RELOC_ALPHA_GPDISP,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ALPHA_GPDISP_HI16	bfd.h	/^  BFD_RELOC_ALPHA_GPDISP_HI16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ALPHA_GPDISP_LO16	bfd.h	/^  BFD_RELOC_ALPHA_GPDISP_LO16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ALPHA_HINT	bfd.h	/^  BFD_RELOC_ALPHA_HINT,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ALPHA_LINKAGE	bfd.h	/^  BFD_RELOC_ALPHA_LINKAGE,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ALPHA_LITERAL	bfd.h	/^  BFD_RELOC_ALPHA_LITERAL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ALPHA_LITUSE	bfd.h	/^  BFD_RELOC_ALPHA_LITUSE,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARC_B22_PCREL	bfd.h	/^  BFD_RELOC_ARC_B22_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARC_B26	bfd.h	/^  BFD_RELOC_ARC_B26,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_ADR_IMM	bfd.h	/^  BFD_RELOC_ARM_ADR_IMM,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_CP_OFF_IMM	bfd.h	/^  BFD_RELOC_ARM_CP_OFF_IMM,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_HWLITERAL	bfd.h	/^  BFD_RELOC_ARM_HWLITERAL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_IMMEDIATE	bfd.h	/^  BFD_RELOC_ARM_IMMEDIATE,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_IN_POOL	bfd.h	/^  BFD_RELOC_ARM_IN_POOL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_LDR_IMM	bfd.h	/^  BFD_RELOC_ARM_LDR_IMM,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_LITERAL	bfd.h	/^  BFD_RELOC_ARM_LITERAL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_MULTI	bfd.h	/^  BFD_RELOC_ARM_MULTI,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_OFFSET_IMM	bfd.h	/^  BFD_RELOC_ARM_OFFSET_IMM,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_OFFSET_IMM8	bfd.h	/^  BFD_RELOC_ARM_OFFSET_IMM8,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_PCREL_BRANCH	bfd.h	/^  BFD_RELOC_ARM_PCREL_BRANCH,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_SHIFT_IMM	bfd.h	/^  BFD_RELOC_ARM_SHIFT_IMM,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_SWI	bfd.h	/^  BFD_RELOC_ARM_SWI,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_THUMB_ADD	bfd.h	/^  BFD_RELOC_ARM_THUMB_ADD,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_THUMB_IMM	bfd.h	/^  BFD_RELOC_ARM_THUMB_IMM,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_THUMB_OFFSET	bfd.h	/^  BFD_RELOC_ARM_THUMB_OFFSET,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_ARM_THUMB_SHIFT	bfd.h	/^  BFD_RELOC_ARM_THUMB_SHIFT,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_CTOR	bfd.h	/^  BFD_RELOC_CTOR,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_D10V_10_PCREL_L	bfd.h	/^  BFD_RELOC_D10V_10_PCREL_L,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_D10V_10_PCREL_R	bfd.h	/^  BFD_RELOC_D10V_10_PCREL_R,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_D10V_18	bfd.h	/^  BFD_RELOC_D10V_18,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_D10V_18_PCREL	bfd.h	/^  BFD_RELOC_D10V_18_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_D30V_15	bfd.h	/^  BFD_RELOC_D30V_15,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_D30V_15_PCREL	bfd.h	/^  BFD_RELOC_D30V_15_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_D30V_15_PCREL_R	bfd.h	/^  BFD_RELOC_D30V_15_PCREL_R,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_D30V_21	bfd.h	/^  BFD_RELOC_D30V_21,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_D30V_21_PCREL	bfd.h	/^  BFD_RELOC_D30V_21_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_D30V_21_PCREL_R	bfd.h	/^  BFD_RELOC_D30V_21_PCREL_R,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_D30V_32	bfd.h	/^  BFD_RELOC_D30V_32,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_D30V_32_PCREL	bfd.h	/^  BFD_RELOC_D30V_32_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_D30V_6	bfd.h	/^  BFD_RELOC_D30V_6,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_D30V_9_PCREL	bfd.h	/^  BFD_RELOC_D30V_9_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_D30V_9_PCREL_R	bfd.h	/^  BFD_RELOC_D30V_9_PCREL_R,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_GPREL16	bfd.h	/^  BFD_RELOC_GPREL16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_GPREL32	bfd.h	/^  BFD_RELOC_GPREL32,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_HI16	bfd.h	/^  BFD_RELOC_HI16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_HI16_BASEREL	bfd.h	/^  BFD_RELOC_HI16_BASEREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_HI16_GOTOFF	bfd.h	/^  BFD_RELOC_HI16_GOTOFF,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_HI16_PLTOFF	bfd.h	/^  BFD_RELOC_HI16_PLTOFF,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_HI16_S	bfd.h	/^  BFD_RELOC_HI16_S,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_HI16_S_BASEREL	bfd.h	/^  BFD_RELOC_HI16_S_BASEREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_HI16_S_GOTOFF	bfd.h	/^  BFD_RELOC_HI16_S_GOTOFF,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_HI16_S_PLTOFF	bfd.h	/^  BFD_RELOC_HI16_S_PLTOFF,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_HI22	bfd.h	/^  BFD_RELOC_HI22,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_I960_CALLJ	bfd.h	/^  BFD_RELOC_I960_CALLJ,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_LO10	bfd.h	/^  BFD_RELOC_LO10,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_LO16	bfd.h	/^  BFD_RELOC_LO16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_LO16_BASEREL	bfd.h	/^  BFD_RELOC_LO16_BASEREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_LO16_GOTOFF	bfd.h	/^  BFD_RELOC_LO16_GOTOFF,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_LO16_PLTOFF	bfd.h	/^  BFD_RELOC_LO16_PLTOFF,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_M32R_10_PCREL	bfd.h	/^  BFD_RELOC_M32R_10_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_M32R_18_PCREL	bfd.h	/^  BFD_RELOC_M32R_18_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_M32R_24	bfd.h	/^  BFD_RELOC_M32R_24,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_M32R_26_PCREL	bfd.h	/^  BFD_RELOC_M32R_26_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_M32R_HI16_SLO	bfd.h	/^  BFD_RELOC_M32R_HI16_SLO,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_M32R_HI16_ULO	bfd.h	/^  BFD_RELOC_M32R_HI16_ULO,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_M32R_LO16	bfd.h	/^  BFD_RELOC_M32R_LO16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_M32R_SDA16	bfd.h	/^  BFD_RELOC_M32R_SDA16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_MIPS16_GPREL	bfd.h	/^  BFD_RELOC_MIPS16_GPREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_MIPS16_JMP	bfd.h	/^  BFD_RELOC_MIPS16_JMP,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_MIPS_CALL16	bfd.h	/^  BFD_RELOC_MIPS_CALL16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_MIPS_CALL_HI16	bfd.h	/^  BFD_RELOC_MIPS_CALL_HI16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_MIPS_CALL_LO16	bfd.h	/^  BFD_RELOC_MIPS_CALL_LO16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_MIPS_GOT16	bfd.h	/^  BFD_RELOC_MIPS_GOT16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_MIPS_GOT_HI16	bfd.h	/^  BFD_RELOC_MIPS_GOT_HI16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_MIPS_GOT_LO16	bfd.h	/^  BFD_RELOC_MIPS_GOT_LO16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_MIPS_GPREL	bfd.h	1794;"	d
BFD_RELOC_MIPS_GPREL32	bfd.h	1802;"	d
BFD_RELOC_MIPS_JMP	bfd.h	/^  BFD_RELOC_MIPS_JMP,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_MIPS_LITERAL	bfd.h	/^  BFD_RELOC_MIPS_LITERAL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_MN10300_16_PCREL	bfd.h	/^  BFD_RELOC_MN10300_16_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_MN10300_32_PCREL	bfd.h	/^  BFD_RELOC_MN10300_32_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_NONE	bfd.h	/^  BFD_RELOC_NONE,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_NS32K_DISP_16	bfd.h	/^  BFD_RELOC_NS32K_DISP_16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_NS32K_DISP_16_PCREL	bfd.h	/^  BFD_RELOC_NS32K_DISP_16_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_NS32K_DISP_32	bfd.h	/^  BFD_RELOC_NS32K_DISP_32,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_NS32K_DISP_32_PCREL	bfd.h	/^  BFD_RELOC_NS32K_DISP_32_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_NS32K_DISP_8	bfd.h	/^  BFD_RELOC_NS32K_DISP_8,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_NS32K_DISP_8_PCREL	bfd.h	/^  BFD_RELOC_NS32K_DISP_8_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_NS32K_IMM_16	bfd.h	/^  BFD_RELOC_NS32K_IMM_16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_NS32K_IMM_16_PCREL	bfd.h	/^  BFD_RELOC_NS32K_IMM_16_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_NS32K_IMM_32	bfd.h	/^  BFD_RELOC_NS32K_IMM_32,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_NS32K_IMM_32_PCREL	bfd.h	/^  BFD_RELOC_NS32K_IMM_32_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_NS32K_IMM_8	bfd.h	/^  BFD_RELOC_NS32K_IMM_8,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_NS32K_IMM_8_PCREL	bfd.h	/^  BFD_RELOC_NS32K_IMM_8_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PCREL_HI16_S	bfd.h	/^  BFD_RELOC_PCREL_HI16_S,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PCREL_LO16	bfd.h	/^  BFD_RELOC_PCREL_LO16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_B16	bfd.h	/^  BFD_RELOC_PPC_B16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_B16_BRNTAKEN	bfd.h	/^  BFD_RELOC_PPC_B16_BRNTAKEN,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_B16_BRTAKEN	bfd.h	/^  BFD_RELOC_PPC_B16_BRTAKEN,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_B26	bfd.h	/^  BFD_RELOC_PPC_B26,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_BA16	bfd.h	/^  BFD_RELOC_PPC_BA16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_BA16_BRNTAKEN	bfd.h	/^  BFD_RELOC_PPC_BA16_BRNTAKEN,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_BA16_BRTAKEN	bfd.h	/^  BFD_RELOC_PPC_BA16_BRTAKEN,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_BA26	bfd.h	/^  BFD_RELOC_PPC_BA26,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_COPY	bfd.h	/^  BFD_RELOC_PPC_COPY,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_BIT_FLD	bfd.h	/^  BFD_RELOC_PPC_EMB_BIT_FLD,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_MRKREF	bfd.h	/^  BFD_RELOC_PPC_EMB_MRKREF,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_NADDR16	bfd.h	/^  BFD_RELOC_PPC_EMB_NADDR16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_NADDR16_HA	bfd.h	/^  BFD_RELOC_PPC_EMB_NADDR16_HA,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_NADDR16_HI	bfd.h	/^  BFD_RELOC_PPC_EMB_NADDR16_HI,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_NADDR16_LO	bfd.h	/^  BFD_RELOC_PPC_EMB_NADDR16_LO,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_NADDR32	bfd.h	/^  BFD_RELOC_PPC_EMB_NADDR32,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_RELSDA	bfd.h	/^  BFD_RELOC_PPC_EMB_RELSDA,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_RELSEC16	bfd.h	/^  BFD_RELOC_PPC_EMB_RELSEC16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_RELST_HA	bfd.h	/^  BFD_RELOC_PPC_EMB_RELST_HA,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_RELST_HI	bfd.h	/^  BFD_RELOC_PPC_EMB_RELST_HI,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_RELST_LO	bfd.h	/^  BFD_RELOC_PPC_EMB_RELST_LO,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_SDA21	bfd.h	/^  BFD_RELOC_PPC_EMB_SDA21,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_SDA2I16	bfd.h	/^  BFD_RELOC_PPC_EMB_SDA2I16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_SDA2REL	bfd.h	/^  BFD_RELOC_PPC_EMB_SDA2REL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_EMB_SDAI16	bfd.h	/^  BFD_RELOC_PPC_EMB_SDAI16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_GLOB_DAT	bfd.h	/^  BFD_RELOC_PPC_GLOB_DAT,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_JMP_SLOT	bfd.h	/^  BFD_RELOC_PPC_JMP_SLOT,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_LOCAL24PC	bfd.h	/^  BFD_RELOC_PPC_LOCAL24PC,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_RELATIVE	bfd.h	/^  BFD_RELOC_PPC_RELATIVE,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_PPC_TOC16	bfd.h	/^  BFD_RELOC_PPC_TOC16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_RVA	bfd.h	/^  BFD_RELOC_RVA,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_ALIGN	bfd.h	/^  BFD_RELOC_SH_ALIGN,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_CODE	bfd.h	/^  BFD_RELOC_SH_CODE,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_COUNT	bfd.h	/^  BFD_RELOC_SH_COUNT,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_DATA	bfd.h	/^  BFD_RELOC_SH_DATA,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_IMM4	bfd.h	/^  BFD_RELOC_SH_IMM4,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_IMM4BY2	bfd.h	/^  BFD_RELOC_SH_IMM4BY2,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_IMM4BY4	bfd.h	/^  BFD_RELOC_SH_IMM4BY4,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_IMM8	bfd.h	/^  BFD_RELOC_SH_IMM8,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_IMM8BY2	bfd.h	/^  BFD_RELOC_SH_IMM8BY2,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_IMM8BY4	bfd.h	/^  BFD_RELOC_SH_IMM8BY4,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_LABEL	bfd.h	/^  BFD_RELOC_SH_LABEL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_PCDISP12BY2	bfd.h	/^  BFD_RELOC_SH_PCDISP12BY2,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_PCDISP8BY2	bfd.h	/^  BFD_RELOC_SH_PCDISP8BY2,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_PCRELIMM8BY2	bfd.h	/^  BFD_RELOC_SH_PCRELIMM8BY2,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_PCRELIMM8BY4	bfd.h	/^  BFD_RELOC_SH_PCRELIMM8BY4,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_SWITCH16	bfd.h	/^  BFD_RELOC_SH_SWITCH16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_SWITCH32	bfd.h	/^  BFD_RELOC_SH_SWITCH32,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SH_USES	bfd.h	/^  BFD_RELOC_SH_USES,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC13	bfd.h	/^  BFD_RELOC_SPARC13,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC22	bfd.h	/^  BFD_RELOC_SPARC22,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_10	bfd.h	/^  BFD_RELOC_SPARC_10,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_11	bfd.h	/^  BFD_RELOC_SPARC_11,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_5	bfd.h	/^  BFD_RELOC_SPARC_5,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_6	bfd.h	/^  BFD_RELOC_SPARC_6,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_64	bfd.h	1677;"	d
BFD_RELOC_SPARC_7	bfd.h	/^  BFD_RELOC_SPARC_7,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_BASE13	bfd.h	/^  BFD_RELOC_SPARC_BASE13,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_BASE22	bfd.h	/^  BFD_RELOC_SPARC_BASE22,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_COPY	bfd.h	/^  BFD_RELOC_SPARC_COPY,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_DISP64	bfd.h	1692;"	d
BFD_RELOC_SPARC_GLOB_DAT	bfd.h	/^  BFD_RELOC_SPARC_GLOB_DAT,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_GOT10	bfd.h	/^  BFD_RELOC_SPARC_GOT10,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_GOT13	bfd.h	/^  BFD_RELOC_SPARC_GOT13,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_GOT22	bfd.h	/^  BFD_RELOC_SPARC_GOT22,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_H44	bfd.h	/^  BFD_RELOC_SPARC_H44,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_HH22	bfd.h	/^  BFD_RELOC_SPARC_HH22,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_HIX22	bfd.h	/^  BFD_RELOC_SPARC_HIX22,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_HM10	bfd.h	/^  BFD_RELOC_SPARC_HM10,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_JMP_SLOT	bfd.h	/^  BFD_RELOC_SPARC_JMP_SLOT,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_L44	bfd.h	/^  BFD_RELOC_SPARC_L44,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_LM22	bfd.h	/^  BFD_RELOC_SPARC_LM22,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_LOX10	bfd.h	/^  BFD_RELOC_SPARC_LOX10,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_M44	bfd.h	/^  BFD_RELOC_SPARC_M44,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_OLO10	bfd.h	/^  BFD_RELOC_SPARC_OLO10,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_PC10	bfd.h	/^  BFD_RELOC_SPARC_PC10,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_PC22	bfd.h	/^  BFD_RELOC_SPARC_PC22,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_PC_HH22	bfd.h	/^  BFD_RELOC_SPARC_PC_HH22,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_PC_HM10	bfd.h	/^  BFD_RELOC_SPARC_PC_HM10,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_PC_LM22	bfd.h	/^  BFD_RELOC_SPARC_PC_LM22,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_PLT64	bfd.h	/^  BFD_RELOC_SPARC_PLT64,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_REGISTER	bfd.h	/^  BFD_RELOC_SPARC_REGISTER,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_RELATIVE	bfd.h	/^  BFD_RELOC_SPARC_RELATIVE,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_REV32	bfd.h	/^  BFD_RELOC_SPARC_REV32,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_UA32	bfd.h	/^  BFD_RELOC_SPARC_UA32,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_WDISP16	bfd.h	/^  BFD_RELOC_SPARC_WDISP16,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_WDISP19	bfd.h	/^  BFD_RELOC_SPARC_WDISP19,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_WDISP22	bfd.h	/^  BFD_RELOC_SPARC_WDISP22,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_SPARC_WPLT30	bfd.h	/^  BFD_RELOC_SPARC_WPLT30,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_THUMB_PCREL_BRANCH12	bfd.h	/^  BFD_RELOC_THUMB_PCREL_BRANCH12,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_THUMB_PCREL_BRANCH23	bfd.h	/^  BFD_RELOC_THUMB_PCREL_BRANCH23,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_THUMB_PCREL_BRANCH9	bfd.h	/^  BFD_RELOC_THUMB_PCREL_BRANCH9,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_TIC30_LDP	bfd.h	/^  BFD_RELOC_TIC30_LDP,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_UNUSED	bfd.h	/^  BFD_RELOC_UNUSED };$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_V850_22_PCREL	bfd.h	/^  BFD_RELOC_V850_22_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_V850_9_PCREL	bfd.h	/^  BFD_RELOC_V850_9_PCREL,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_V850_SDA_15_16_OFFSET	bfd.h	/^  BFD_RELOC_V850_SDA_15_16_OFFSET,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_V850_SDA_16_16_OFFSET	bfd.h	/^  BFD_RELOC_V850_SDA_16_16_OFFSET,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_V850_TDA_16_16_OFFSET	bfd.h	/^  BFD_RELOC_V850_TDA_16_16_OFFSET,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_V850_TDA_6_8_OFFSET	bfd.h	/^  BFD_RELOC_V850_TDA_6_8_OFFSET,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_V850_TDA_7_7_OFFSET	bfd.h	/^  BFD_RELOC_V850_TDA_7_7_OFFSET,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_V850_TDA_7_8_OFFSET	bfd.h	/^  BFD_RELOC_V850_TDA_7_8_OFFSET,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_V850_ZDA_15_16_OFFSET	bfd.h	/^  BFD_RELOC_V850_ZDA_15_16_OFFSET,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_V850_ZDA_16_16_OFFSET	bfd.h	/^  BFD_RELOC_V850_ZDA_16_16_OFFSET,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_VTABLE_ENTRY	bfd.h	/^  BFD_RELOC_VTABLE_ENTRY,$/;"	e	enum:bfd_reloc_code_real
BFD_RELOC_VTABLE_INHERIT	bfd.h	/^  BFD_RELOC_VTABLE_INHERIT,$/;"	e	enum:bfd_reloc_code_real
BFD_SEND	bfd.h	2595;"	d
BFD_SEND	bfd.h	2599;"	d
BFD_SEND	bfd.h	2600;"	d
BFD_SEND_FMT	bfd.h	2605;"	d
BFD_SEND_FMT	bfd.h	2609;"	d
BFD_SEND_FMT	bfd.h	2610;"	d
BFD_TRADITIONAL_FORMAT	bfd.h	245;"	d
BFD_TRUE_FALSE	bfd.h	102;"	d
BFD_UND_SECTION_NAME	bfd.h	1121;"	d
BFD_VERSION	bfd.h	55;"	d
BSF_CONSTRUCTOR	bfd.h	2182;"	d
BSF_DEBUGGING	bfd.h	2148;"	d
BSF_DYNAMIC	bfd.h	2199;"	d
BSF_EXPORT	bfd.h	2140;"	d
BSF_FILE	bfd.h	2196;"	d
BSF_FUNCTION	bfd.h	2152;"	d
BSF_GLOBAL	bfd.h	2136;"	d
BSF_INDIRECT	bfd.h	2192;"	d
BSF_KEEP	bfd.h	2155;"	d
BSF_KEEP_G	bfd.h	2156;"	d
BSF_LOCAL	bfd.h	2132;"	d
BSF_NOT_AT_END	bfd.h	2179;"	d
BSF_NO_FLAGS	bfd.h	2128;"	d
BSF_OBJECT	bfd.h	2203;"	d
BSF_OLD_COMMON	bfd.h	2168;"	d
BSF_SECTION_SYM	bfd.h	2164;"	d
BSF_WARNING	bfd.h	2188;"	d
BSF_WEAK	bfd.h	2160;"	d
BUFSIZ	g++/iostdio.h	42;"	d
Bbase	g++/streambuf.h	/^    char *Bbase() { return in_backup() ? _IO_read_base : _IO_save_base; }$/;"	f	struct:streambuf
Bptr	g++/streambuf.h	/^    char *Bptr() { return _IO_backup_base; }$/;"	f	struct:streambuf
CAT	bfd.h	445;"	d
CAT	bfd.h	450;"	d
CAT	bfd.h	455;"	d
CAT3	bfd.h	446;"	d
CAT3	bfd.h	451;"	d
CAT3	bfd.h	456;"	d
CAT4	bfd.h	447;"	d
CAT4	bfd.h	453;"	d
CAT4	bfd.h	457;"	d
CAlloc	g++/stl_rope.h	/^    	typedef simple_alloc<__rope_RopeConcatenation<charT,Alloc>, Alloc> CAlloc;$/;"	t	class:rope
CAlloc	g++/stl_rope.h	/^    typedef simple_alloc<__rope_RopeConcatenation<charT,Alloc>, Alloc> CAlloc;$/;"	t	struct:__rope_RopeBase
CHAR	tcl.h	/^typedef char CHAR;$/;"	t
CHAR_BIT	include/limits.h	21;"	d
CHAR_BIT	include/limits.h	22;"	d
CHAR_MAX	include/limits.h	43;"	d
CHAR_MAX	include/limits.h	44;"	d
CHAR_MAX	include/limits.h	48;"	d
CHAR_MAX	include/limits.h	49;"	d
CHAR_MIN	include/limits.h	41;"	d
CHAR_MIN	include/limits.h	42;"	d
CHAR_MIN	include/limits.h	46;"	d
CHAR_MIN	include/limits.h	47;"	d
CHECK_FILE	g++/libioP.h	634;"	d
CHECK_FILE	g++/libioP.h	640;"	d
COERCE_FILE	g++/libioP.h	619;"	d
COERCE_FILE	g++/libioP.h	622;"	d
COFF_SWAP_TABLE	bfd.h	462;"	d
CONST	ansidecl.h	118;"	d
CONST	ansidecl.h	145;"	d
CONST	expect_comm.h	65;"	d
CONST	expect_comm.h	70;"	d
CONST	expect_comm.h	73;"	d
CONST	tcl.h	141;"	d
CONST	tcl.h	146;"	d
CONST	tcl.h	149;"	d
CPFunction	readline/keymaps.h	/^typedef char *CPFunction ();$/;"	t
CPPFunction	readline/keymaps.h	/^typedef char **CPPFunction ();$/;"	t
CTRL	readline/chardefs.h	17;"	d
CTRL	readline/chardefs.h	28;"	d
CTRL_P	readline/chardefs.h	44;"	d
CharReader	g++/parsestream.h	/^typedef char *(*CharReader)(void *arg);$/;"	t
ClientData	tcl.h	/^    typedef int *ClientData;$/;"	t
ClientData	tcl.h	/^    typedef void *ClientData;$/;"	t
DBL_DIG	include/float.h	44;"	d
DBL_DIG	include/float.h	45;"	d
DBL_EPSILON	include/float.h	47;"	d
DBL_EPSILON	include/float.h	48;"	d
DBL_MANT_DIG	include/float.h	41;"	d
DBL_MANT_DIG	include/float.h	42;"	d
DBL_MAX	include/float.h	62;"	d
DBL_MAX	include/float.h	63;"	d
DBL_MAX_10_EXP	include/float.h	65;"	d
DBL_MAX_10_EXP	include/float.h	66;"	d
DBL_MAX_EXP	include/float.h	59;"	d
DBL_MAX_EXP	include/float.h	60;"	d
DBL_MIN	include/float.h	53;"	d
DBL_MIN	include/float.h	54;"	d
DBL_MIN_10_EXP	include/float.h	56;"	d
DBL_MIN_10_EXP	include/float.h	57;"	d
DBL_MIN_EXP	include/float.h	50;"	d
DBL_MIN_EXP	include/float.h	51;"	d
DEFALLOC_H	g++/defalloc.h	13;"	d
DEFUN	ansidecl.h	122;"	d
DEFUN	ansidecl.h	149;"	d
DEFUN_VOID	ansidecl.h	123;"	d
DEFUN_VOID	ansidecl.h	150;"	d
DOTS	ansidecl.h	119;"	d
DOTS	ansidecl.h	146;"	d
DYNAMIC	bfd.h	225;"	d
D_PAGED	bfd.h	234;"	d
DataAlloc	g++/stl_rope.h	/^    	typedef simple_alloc<charT, Alloc> DataAlloc;$/;"	t	class:rope
DataAlloc	g++/stl_rope.h	/^    typedef simple_alloc<charT, Alloc> DataAlloc;$/;"	t	struct:__rope_RopeBase
Dbg_DefaultCmdName	Dbg.h	/^EXTERN char *Dbg_DefaultCmdName;$/;"	v
Dbg_IgnoreFuncsProc	Dbg.h	/^typedef int (Dbg_IgnoreFuncsProc) _ANSI_ARGS_(($/;"	t
Dbg_InterProc	Dbg.h	/^typedef int (Dbg_InterProc) _ANSI_ARGS_((Tcl_Interp *interp, ClientData data));$/;"	t
Dbg_InterStruct	Dbg.h	/^} Dbg_InterStruct;$/;"	t	typeref:struct:__anon70
Dbg_OutputProc	Dbg.h	/^typedef void (Dbg_OutputProc) _ANSI_ARGS_(($/;"	t
Dbg_OutputStruct	Dbg.h	/^} Dbg_OutputStruct;$/;"	t	typeref:struct:__anon71
Dbg_VarName	Dbg.h	/^EXTERN char *Dbg_VarName;$/;"	v
DeactivateNotify	tk.h	413;"	d
EOF	g++/iostdio.h	39;"	d
EOF	g++/libio.h	83;"	d
EOF	g++/libioP.h	456;"	d
EOF	g++/streambuf.h	47;"	d
ESC	readline/chardefs.h	79;"	d
ESC	readline/chardefs.h	82;"	d
EXEC_P	bfd.h	208;"	d
EXFUN	ansidecl.h	121;"	d
EXFUN	ansidecl.h	148;"	d
EXP_ABEOF	expect_comm.h	117;"	d
EXP_ABORT	expect.h	55;"	d
EXP_CANMATCH	expect_comm.h	128;"	d
EXP_CANTMATCH	expect_comm.h	127;"	d
EXP_CONTINUE	expect_comm.h	147;"	d
EXP_CONTINUE_TIMER	expect_comm.h	149;"	d
EXP_DATA_NEW	expect_comm.h	129;"	d
EXP_DATA_OLD	expect_comm.h	130;"	d
EXP_EOF	expect_comm.h	131;"	d
EXP_FULLBUFFER	expect_comm.h	124;"	d
EXP_MATCH	expect_comm.h	125;"	d
EXP_NOMATCH	expect_comm.h	126;"	d
EXP_RECONFIGURE	expect_comm.h	132;"	d
EXP_RESTART	expect.h	56;"	d
EXP_SPAWN_ID_BAD	expect_comm.h	157;"	d
EXP_TCLBRK	expect_comm.h	140;"	d
EXP_TCLCNT	expect_comm.h	138;"	d
EXP_TCLCNTEXP	expect_comm.h	141;"	d
EXP_TCLCNTTIMER	expect_comm.h	139;"	d
EXP_TCLERROR	expect_comm.h	123;"	d
EXP_TCLRET	expect_comm.h	137;"	d
EXP_TCLRETTCL	expect_comm.h	142;"	d
EXP_TCL_RETURN	expect_comm.h	151;"	d
EXP_TIMEOUT	expect_comm.h	122;"	d
EXP_TIME_INFINITY	expect_comm.h	156;"	d
EXP__TCL_WAS_DEFINED	expect_comm.h	100;"	d
EXP__TCL_WAS_DEFINED	expect_comm.h	89;"	d
EXTERN	expect_comm.h	77;"	d
EXTERN	expect_comm.h	79;"	d
EXTERN	tcl.h	153;"	d
EXTERN	tcl.h	155;"	d
Exp_Init	expect_tcl.h	28;"	d
FAlloc	g++/stl_rope.h	/^    	typedef simple_alloc<__rope_RopeFunction<charT,Alloc>, Alloc> FAlloc;$/;"	t	class:rope
FAlloc	g++/stl_rope.h	/^    typedef simple_alloc<__rope_RopeFunction<charT,Alloc>, Alloc> FAlloc;$/;"	t	struct:__rope_RopeBase
FILE	g++/iostdio.h	/^typedef _IO_FILE FILE;$/;"	t
FILEBUF_LITERAL	g++/libioP.h	575;"	d
FILEBUF_LITERAL	g++/libioP.h	581;"	d
FLT_DIG	include/float.h	13;"	d
FLT_DIG	include/float.h	14;"	d
FLT_EPSILON	include/float.h	19;"	d
FLT_EPSILON	include/float.h	20;"	d
FLT_MANT_DIG	include/float.h	10;"	d
FLT_MANT_DIG	include/float.h	11;"	d
FLT_MAX	include/float.h	34;"	d
FLT_MAX	include/float.h	35;"	d
FLT_MAX_10_EXP	include/float.h	37;"	d
FLT_MAX_10_EXP	include/float.h	38;"	d
FLT_MAX_EXP	include/float.h	31;"	d
FLT_MAX_EXP	include/float.h	32;"	d
FLT_MIN	include/float.h	25;"	d
FLT_MIN	include/float.h	26;"	d
FLT_MIN_10_EXP	include/float.h	28;"	d
FLT_MIN_10_EXP	include/float.h	29;"	d
FLT_MIN_EXP	include/float.h	22;"	d
FLT_MIN_EXP	include/float.h	23;"	d
FLT_RADIX	include/float.h	7;"	d
FLT_RADIX	include/float.h	8;"	d
FLT_ROUNDS	include/float.h	16;"	d
FLT_ROUNDS	include/float.h	17;"	d
FREELIST_INDEX	g++/stl_alloc.h	/^	static size_t FREELIST_INDEX(size_t bytes) $/;"	f	class:__default_alloc_template
FREE_BUF	g++/libioP.h	500;"	d
FREE_BUF	g++/libioP.h	513;"	d
FUNMAP	readline/readline.h	/^} FUNMAP;$/;"	t	typeref:struct:__anon28
FUNMAP	readline/readline.h	/^} FUNMAP;$/;"	t	typeref:struct:__anon29
FlexLexer	FlexLexer.h	/^class FlexLexer {$/;"	c
Function	readline/keymaps.h	/^typedef int Function ();$/;"	t
GET_RECORD	tix.h	425;"	d
Gbase	g++/streambuf.h	/^    char *Gbase() { return in_backup() ? _IO_save_base : _IO_read_base; }$/;"	f	struct:streambuf
HAS_DEBUG	bfd.h	215;"	d
HAS_LINENO	bfd.h	212;"	d
HAS_LOCALS	bfd.h	222;"	d
HAS_RELOC	bfd.h	205;"	d
HAS_STDARG	tcl.h	65;"	d
HAS_STDARG	tcl.h	86;"	d
HAS_SYMS	bfd.h	218;"	d
HOWTO	bfd.h	1517;"	d
HOWTO_PREPARE	bfd.h	1521;"	d
INLINE	bfd.h	69;"	d
INLINE	bfd.h	71;"	d
INT_MAX	include/limits.h	69;"	d
INT_MAX	include/limits.h	70;"	d
INT_MIN	include/limits.h	67;"	d
INT_MIN	include/limits.h	68;"	d
ISFUNC	readline/keymaps.h	62;"	d
ISKMAP	readline/keymaps.h	63;"	d
ISMACR	readline/keymaps.h	64;"	d
ITCL_H	itcl.h	64;"	d
Init	g++/streambuf.h	/^      Init () { }$/;"	f	class:ios::Init
Init	g++/streambuf.h	/^    class Init {$/;"	c	class:ios
Iostream_init	g++/iostream.h	/^struct Iostream_init { } ;  \/\/ Compatibility hack for AT&T library.$/;"	s
JUMP0	g++/libioP.h	74;"	d
JUMP0	g++/libioP.h	83;"	d
JUMP1	g++/libioP.h	75;"	d
JUMP1	g++/libioP.h	84;"	d
JUMP2	g++/libioP.h	76;"	d
JUMP2	g++/libioP.h	85;"	d
JUMP3	g++/libioP.h	77;"	d
JUMP3	g++/libioP.h	86;"	d
JUMP_FIELD	g++/libioP.h	73;"	d
JUMP_FIELD	g++/libioP.h	82;"	d
JUMP_INIT	g++/libioP.h	78;"	d
JUMP_INIT	g++/libioP.h	87;"	d
JUMP_INIT_DUMMY	g++/libioP.h	79;"	d
JUMP_INIT_DUMMY	g++/libioP.h	88;"	d
KEYMAP_ENTRY	readline/keymaps.h	/^} KEYMAP_ENTRY;$/;"	t	typeref:struct:_keymap_entry
KEYMAP_ENTRY_ARRAY	readline/keymaps.h	/^typedef KEYMAP_ENTRY KEYMAP_ENTRY_ARRAY[KEYMAP_SIZE];$/;"	t
KEYMAP_SIZE	readline/keymaps.h	51;"	d
Keymap	readline/keymaps.h	/^typedef KEYMAP_ENTRY *Keymap;$/;"	t
LAlloc	g++/stl_rope.h	/^    	typedef simple_alloc<__rope_RopeLeaf<charT,Alloc>, Alloc> LAlloc;$/;"	t	class:rope
LAlloc	g++/stl_rope.h	/^    typedef simple_alloc<__rope_RopeLeaf<charT,Alloc>, Alloc> LAlloc;$/;"	t	struct:__rope_RopeBase
LDBL_DIG	include/float.h	72;"	d
LDBL_DIG	include/float.h	73;"	d
LDBL_EPSILON	include/float.h	75;"	d
LDBL_EPSILON	include/float.h	76;"	d
LDBL_MANT_DIG	include/float.h	69;"	d
LDBL_MANT_DIG	include/float.h	70;"	d
LDBL_MAX	include/float.h	90;"	d
LDBL_MAX	include/float.h	91;"	d
LDBL_MAX_10_EXP	include/float.h	93;"	d
LDBL_MAX_10_EXP	include/float.h	94;"	d
LDBL_MAX_EXP	include/float.h	87;"	d
LDBL_MAX_EXP	include/float.h	88;"	d
LDBL_MIN	include/float.h	81;"	d
LDBL_MIN	include/float.h	82;"	d
LDBL_MIN_10_EXP	include/float.h	84;"	d
LDBL_MIN_10_EXP	include/float.h	85;"	d
LDBL_MIN_EXP	include/float.h	78;"	d
LDBL_MIN_EXP	include/float.h	79;"	d
LENGTHERROR	g++/std/bastring.h	53;"	d
LENGTHERROR	g++/std/bastring.h	60;"	d
LONG	tcl.h	/^typedef long LONG;$/;"	t
LONG_DOUBLE	ansidecl.h	104;"	d
LONG_DOUBLE	ansidecl.h	129;"	d
LONG_LONG_MAX	include/limits.h	101;"	d
LONG_LONG_MAX	include/limits.h	102;"	d
LONG_LONG_MIN	include/limits.h	100;"	d
LONG_LONG_MIN	include/limits.h	99;"	d
LONG_MAX	include/limits.h	87;"	d
LONG_MAX	include/limits.h	88;"	d
LONG_MIN	include/limits.h	85;"	d
LONG_MIN	include/limits.h	86;"	d
MAP_ANONYMOUS	g++/libioP.h	479;"	d
MAXEXP	g++/floatio.h	49;"	d
MAXFRACT	g++/floatio.h	51;"	d
MAYBE_SET_EINVAL	g++/libioP.h	628;"	d
MAYBE_SET_EINVAL	g++/libioP.h	630;"	d
MB_LEN_MAX	include/limits.h	26;"	d
META	readline/chardefs.h	29;"	d
META_CHAR	readline/chardefs.h	27;"	d
META_P	readline/chardefs.h	45;"	d
NEWHOWTO	bfd.h	1519;"	d
NEWLINE	readline/chardefs.h	48;"	d
NOARGS	ansidecl.h	107;"	d
NOARGS	ansidecl.h	132;"	d
NO_STRCASECMP	tix.h	444;"	d
NO_STRERROR	tcl.h	92;"	d
NSUBEXP	tclRegexp.h	22;"	d
NULL	g++/libio.h	88;"	d
NULL	g++/libio.h	91;"	d
NULL	g++/libio.h	93;"	d
NULL	g++/libioP.h	461;"	d
NULL	g++/libioP.h	464;"	d
NULL	g++/libioP.h	466;"	d
NULL	g++/streambuf.h	51;"	d
NULL	g++/streambuf.h	53;"	d
NULL	include/stddef.h	324;"	d
NULL	include/stddef.h	326;"	d
NULL	include/stddef.h	328;"	d
NULL	tcl.h	188;"	d
Nbase	g++/streambuf.h	/^    char *Nbase() { return _IO_save_base; }$/;"	f	struct:streambuf
OS_FSTAT	g++/libioP.h	525;"	d
OUTOFRANGE	g++/std/bastring.h	51;"	d
OUTOFRANGE	g++/std/bastring.h	59;"	d
PAGE	readline/chardefs.h	69;"	d
PAGE	readline/chardefs.h	71;"	d
PARAMS	ansidecl.h	111;"	d
PARAMS	ansidecl.h	139;"	d
PARSESTREAM_H	g++/parsestream.h	28;"	d
PROTO	ansidecl.h	120;"	d
PROTO	ansidecl.h	147;"	d
PTR	ansidecl.h	102;"	d
PTR	ansidecl.h	127;"	d
PTRCONST	ansidecl.h	103;"	d
PTRCONST	ansidecl.h	128;"	d
PlotFile	g++/PlotFile.h	/^  PlotFile() : ofstream() { }$/;"	f	class:PlotFile
PlotFile	g++/PlotFile.h	/^  PlotFile(const char *name, int mode=ios::out, int prot=0664)$/;"	f	class:PlotFile
PlotFile	g++/PlotFile.h	/^  PlotFile(int fd) : ofstream(fd) { }$/;"	f	class:PlotFile
PlotFile	g++/PlotFile.h	/^class PlotFile : public ofstream$/;"	c
REDO_KEYSYM_LOOKUP	tk.h	62;"	d
RETURN	readline/chardefs.h	52;"	d
ROUND_TO_PAGE	g++/libioP.h	497;"	d
ROUND_UP	g++/stl_alloc.h	/^	static size_t ROUND_UP(size_t bytes) $/;"	f	class:__default_alloc_template
RUBOUT	readline/chardefs.h	56;"	d
Rep	g++/std/bastring.h	/^	struct Rep $/;"	s	class:basic_string
RopeBase	g++/stl_rope.h	/^	typedef __rope_RopeBase<charT,Alloc> RopeBase;$/;"	t	class:rope
RopeBase	g++/stl_rope.h	/^    typedef __rope_RopeBase<charT,Alloc> RopeBase;$/;"	t	class:__rope_charT_ref_proxy
RopeBase	g++/stl_rope.h	/^    typedef __rope_RopeBase<charT,Alloc> RopeBase;$/;"	t	class:__rope_iterator_base
RopeConcatenation	g++/stl_rope.h	/^	typedef __rope_RopeConcatenation<charT,Alloc> RopeConcatenation;$/;"	t	class:rope
RopeFunction	g++/stl_rope.h	/^	typedef __rope_RopeFunction<charT,Alloc> RopeFunction;$/;"	t	class:rope
RopeFunction_from_fn	g++/ropeimpl.h	/^rope<charT,Alloc>::RopeFunction_from_fn$/;"	f	class:rope
RopeLeaf	g++/stl_rope.h	/^	typedef __rope_RopeLeaf<charT,Alloc> RopeLeaf;$/;"	t	class:rope
RopeLeaf_from_char_ptr	g++/ropeimpl.h	/^rope<charT,Alloc>::RopeLeaf_from_char_ptr(__GC_CONST charT *s, size_t size)$/;"	f	class:rope
RopeLeaf_from_unowned_char_ptr	g++/stl_rope.h	/^	static RopeLeaf * RopeLeaf_from_unowned_char_ptr(const charT *s,$/;"	f	class:rope
RopeSubstring	g++/stl_rope.h	/^	typedef __rope_RopeSubstring<charT,Alloc> RopeSubstring;$/;"	t	class:rope
S	g++/stl_function.h	/^  explicit const_mem_fun1_ref_t(S (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_ref_t
S	g++/stl_function.h	/^  explicit const_mem_fun1_t(S (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_t
S	g++/stl_function.h	/^  explicit const_mem_fun_ref_t(S (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_ref_t
S	g++/stl_function.h	/^  explicit const_mem_fun_t(S (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_t
S	g++/stl_function.h	/^  explicit mem_fun1_ref_t(S (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_ref_t
S	g++/stl_function.h	/^  explicit mem_fun1_t(S (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_t
S	g++/stl_function.h	/^  explicit mem_fun_ref_t(S (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_ref_t
S	g++/stl_function.h	/^  explicit mem_fun_t(S (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_t
S	g++/stl_function.h	/^inline const_mem_fun1_ref_t<S,T,A> mem_fun1_ref(S (T::*f)(A) const) {$/;"	f
S	g++/stl_function.h	/^inline const_mem_fun1_t<S,T,A> mem_fun1(S (T::*f)(A) const) {$/;"	f
S	g++/stl_function.h	/^inline const_mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)() const) {$/;"	f
S	g++/stl_function.h	/^inline const_mem_fun_t<S,T> mem_fun(S (T::*f)() const) {$/;"	f
S	g++/stl_function.h	/^inline mem_fun1_ref_t<S,T,A> mem_fun1_ref(S (T::*f)(A)) { $/;"	f
S	g++/stl_function.h	/^inline mem_fun1_t<S,T,A> mem_fun1(S (T::*f)(A)) { $/;"	f
S	g++/stl_function.h	/^inline mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)()) { $/;"	f
S	g++/stl_function.h	/^inline mem_fun_t<S,T> mem_fun(S (T::*f)()) { $/;"	f
SAlloc	g++/stl_rope.h	/^    	typedef simple_alloc<__rope_RopeSubstring<charT,Alloc>, Alloc> SAlloc;$/;"	t	class:rope
SAlloc	g++/stl_rope.h	/^    typedef simple_alloc<__rope_RopeSubstring<charT,Alloc>, Alloc> SAlloc;$/;"	t	struct:__rope_RopeBase
SCHAR_MAX	include/limits.h	32;"	d
SCHAR_MAX	include/limits.h	33;"	d
SCHAR_MIN	include/limits.h	30;"	d
SCHAR_MIN	include/limits.h	31;"	d
SEC_ALLOC	bfd.h	850;"	d
SEC_CODE	bfd.h	869;"	d
SEC_COFF_SHARED_LIBRARY	bfd.h	913;"	d
SEC_CONSTRUCTOR	bfd.h	887;"	d
SEC_CONSTRUCTOR_BSS	bfd.h	893;"	d
SEC_CONSTRUCTOR_DATA	bfd.h	892;"	d
SEC_CONSTRUCTOR_TEXT	bfd.h	891;"	d
SEC_DATA	bfd.h	872;"	d
SEC_DEBUGGING	bfd.h	926;"	d
SEC_EXCLUDE	bfd.h	937;"	d
SEC_HAS_CONTENTS	bfd.h	898;"	d
SEC_IN_MEMORY	bfd.h	932;"	d
SEC_IS_COMMON	bfd.h	920;"	d
SEC_KEEP	bfd.h	979;"	d
SEC_LINKER_CREATED	bfd.h	976;"	d
SEC_LINK_DUPLICATES	bfd.h	952;"	d
SEC_LINK_DUPLICATES_DISCARD	bfd.h	956;"	d
SEC_LINK_DUPLICATES_ONE_ONLY	bfd.h	961;"	d
SEC_LINK_DUPLICATES_SAME_CONTENTS	bfd.h	970;"	d
SEC_LINK_DUPLICATES_SAME_SIZE	bfd.h	965;"	d
SEC_LINK_ONCE	bfd.h	948;"	d
SEC_LOAD	bfd.h	854;"	d
SEC_NEVER_LOAD	bfd.h	902;"	d
SEC_NO_FLAGS	bfd.h	845;"	d
SEC_READONLY	bfd.h	866;"	d
SEC_RELOC	bfd.h	858;"	d
SEC_ROM	bfd.h	875;"	d
SEC_SORT_ENTRIES	bfd.h	942;"	d
SEEK_CUR	g++/iostdio.h	52;"	d
SEEK_END	g++/iostdio.h	53;"	d
SEEK_SET	g++/iostdio.h	51;"	d
SET_RECORD	tix.h	422;"	d
SFile	g++/SFile.h	/^    SFile() : fstream() { }$/;"	f	class:SFile
SFile	g++/SFile.h	/^class SFile: public fstream$/;"	c
SHORT	tcl.h	/^typedef short SHORT;$/;"	t
SHRT_MAX	include/limits.h	56;"	d
SHRT_MAX	include/limits.h	57;"	d
SHRT_MIN	include/limits.h	53;"	d
SHRT_MIN	include/limits.h	55;"	d
SIGNED	ansidecl.h	109;"	d
SIGNED	ansidecl.h	137;"	d
SPACE	readline/chardefs.h	74;"	d
SPACE	readline/chardefs.h	76;"	d
STRICT	tcl.h	59;"	d
STRINGIFY	tcl.h	74;"	d
STRINGIFY1	tcl.h	75;"	d
TAB	readline/chardefs.h	60;"	d
TCL_7_5_OR_LATER	tix.h	48;"	d
TCL_7_5_OR_LATER	tix.h	51;"	d
TCL_ALL_EVENTS	tcl.h	830;"	d
TCL_APPEND_VALUE	tcl.h	633;"	d
TCL_BREAK	tcl.h	269;"	d
TCL_CONTINUE	tcl.h	270;"	d
TCL_DONT_USE_BRACES	tcl.h	600;"	d
TCL_DONT_WAIT	tcl.h	825;"	d
TCL_DOUBLE	tcl.h	/^typedef enum {TCL_INT, TCL_DOUBLE, TCL_EITHER} Tcl_ValueType;$/;"	e	enum:__anon53
TCL_DOUBLE_SPACE	tcl.h	592;"	d
TCL_DSTRING_STATIC_SIZE	tcl.h	568;"	d
TCL_DYNAMIC	tcl.h	625;"	d
TCL_EITHER	tcl.h	/^typedef enum {TCL_INT, TCL_DOUBLE, TCL_EITHER} Tcl_ValueType;$/;"	e	enum:__anon53
TCL_ENFORCE_MODE	tcl.h	893;"	d
TCL_ERROR	tcl.h	267;"	d
TCL_EVAL_GLOBAL	tcl.h	616;"	d
TCL_EXACT	tcl.h	607;"	d
TCL_EXCEPTION	tcl.h	882;"	d
TCL_FILE_EVENTS	tcl.h	827;"	d
TCL_GLOBAL_ONLY	tcl.h	631;"	d
TCL_IDLE_EVENTS	tcl.h	829;"	d
TCL_INT	tcl.h	/^typedef enum {TCL_INT, TCL_DOUBLE, TCL_EITHER} Tcl_ValueType;$/;"	e	enum:__anon53
TCL_INTERP_DESTROYED	tcl.h	639;"	d
TCL_LEAVE_ERR_MSG	tcl.h	640;"	d
TCL_LINK_BOOLEAN	tcl.h	649;"	d
TCL_LINK_DOUBLE	tcl.h	648;"	d
TCL_LINK_INT	tcl.h	647;"	d
TCL_LINK_READ_ONLY	tcl.h	651;"	d
TCL_LINK_STRING	tcl.h	650;"	d
TCL_LIST_ELEMENT	tcl.h	634;"	d
TCL_MAJOR_VERSION	tcl.h	38;"	d
TCL_MAX_PREC	tcl.h	591;"	d
TCL_MINOR_VERSION	tcl.h	39;"	d
TCL_MODE_BLOCKING	tcl.h	972;"	d
TCL_MODE_NONBLOCKING	tcl.h	973;"	d
TCL_NAMESPACE_ONLY	tcl.h	632;"	d
TCL_NO_EVAL	tcl.h	615;"	d
TCL_OK	tcl.h	266;"	d
TCL_ONE_WORD_KEYS	tcl.h	798;"	d
TCL_PARSE_PART1	tcl.h	641;"	d
TCL_PATCH_LEVEL	tcl.h	44;"	d
TCL_PATH_ABSOLUTE	tcl.h	/^    TCL_PATH_ABSOLUTE,$/;"	e	enum:Tcl_PathType
TCL_PATH_RELATIVE	tcl.h	/^    TCL_PATH_RELATIVE,$/;"	e	enum:Tcl_PathType
TCL_PATH_VOLUME_RELATIVE	tcl.h	/^    TCL_PATH_VOLUME_RELATIVE$/;"	e	enum:Tcl_PathType
TCL_QUEUE_HEAD	tcl.h	/^    TCL_QUEUE_TAIL, TCL_QUEUE_HEAD, TCL_QUEUE_MARK$/;"	e	enum:__anon57
TCL_QUEUE_MARK	tcl.h	/^    TCL_QUEUE_TAIL, TCL_QUEUE_HEAD, TCL_QUEUE_MARK$/;"	e	enum:__anon57
TCL_QUEUE_TAIL	tcl.h	/^    TCL_QUEUE_TAIL, TCL_QUEUE_HEAD, TCL_QUEUE_MARK$/;"	e	enum:__anon57
TCL_READABLE	tcl.h	880;"	d
TCL_RELEASE_LEVEL	tcl.h	40;"	d
TCL_RELEASE_SERIAL	tcl.h	41;"	d
TCL_RESULT_SIZE	tcl.h	272;"	d
TCL_RETURN	tcl.h	268;"	d
TCL_SERVICE_ALL	tcl.h	861;"	d
TCL_SERVICE_NONE	tcl.h	860;"	d
TCL_SMALL_HASH_TABLE	tcl.h	749;"	d
TCL_STATIC	tcl.h	624;"	d
TCL_STDERR	tcl.h	892;"	d
TCL_STDIN	tcl.h	890;"	d
TCL_STDOUT	tcl.h	891;"	d
TCL_STRING_KEYS	tcl.h	797;"	d
TCL_TIMER_EVENTS	tcl.h	828;"	d
TCL_TRACE_DESTROYED	tcl.h	638;"	d
TCL_TRACE_READS	tcl.h	635;"	d
TCL_TRACE_UNSETS	tcl.h	637;"	d
TCL_TRACE_WRITES	tcl.h	636;"	d
TCL_TRANSLATE_AUTO	tcl.h	/^    TCL_TRANSLATE_AUTO,			\/* Eol == \\r, \\n and \\r\\n. *\/$/;"	e	enum:Tcl_EolTranslation
TCL_TRANSLATE_CR	tcl.h	/^    TCL_TRANSLATE_CR,			\/* Eol == \\r. *\/$/;"	e	enum:Tcl_EolTranslation
TCL_TRANSLATE_CRLF	tcl.h	/^    TCL_TRANSLATE_CRLF			\/* Eol == \\r\\n. *\/$/;"	e	enum:Tcl_EolTranslation
TCL_TRANSLATE_LF	tcl.h	/^    TCL_TRANSLATE_LF,			\/* Eol == \\n. *\/$/;"	e	enum:Tcl_EolTranslation
TCL_VARARGS	expect_comm.h	43;"	d
TCL_VARARGS	expect_comm.h	49;"	d
TCL_VARARGS	expect_comm.h	52;"	d
TCL_VARARGS	tcl.h	120;"	d
TCL_VARARGS	tcl.h	125;"	d
TCL_VARARGS	tcl.h	128;"	d
TCL_VARARGS_DEF	expect_comm.h	44;"	d
TCL_VARARGS_DEF	expect_comm.h	50;"	d
TCL_VARARGS_DEF	expect_comm.h	53;"	d
TCL_VARARGS_DEF	tcl.h	121;"	d
TCL_VARARGS_DEF	tcl.h	126;"	d
TCL_VARARGS_DEF	tcl.h	129;"	d
TCL_VARARGS_START	expect_comm.h	45;"	d
TCL_VARARGS_START	expect_comm.h	55;"	d
TCL_VARARGS_START	tcl.h	122;"	d
TCL_VARARGS_START	tcl.h	131;"	d
TCL_VERSION	tcl.h	43;"	d
TCL_VOLATILE	tcl.h	623;"	d
TCL_WINDOW_EVENTS	tcl.h	826;"	d
TCL_WRITABLE	tcl.h	881;"	d
TIX_DECLARE_CMD	tix.h	168;"	d
TIX_DECLARE_SUBCMD	tix.h	178;"	d
TIX_DEFAULT_LEN	tix.h	151;"	d
TIX_DEFAULT_SUBCMD	tix.h	160;"	d
TIX_DEFINE_CMD	tix.h	188;"	d
TIX_HASHKEY	tix.h	429;"	d
TIX_PATCHLEVEL	tix.h	22;"	d
TIX_PATCH_LEVEL	tix.h	23;"	d
TIX_RELEASE	tix.h	25;"	d
TIX_RELIEF_FLAT	tix.h	315;"	d
TIX_RELIEF_GROOVE	tix.h	317;"	d
TIX_RELIEF_RAISED	tix.h	314;"	d
TIX_RELIEF_RIDGE	tix.h	318;"	d
TIX_RELIEF_SOLID	tix.h	319;"	d
TIX_RELIEF_SUNKEN	tix.h	316;"	d
TIX_STDIN_ALWAYS	tix.h	87;"	d
TIX_STDIN_NONE	tix.h	89;"	d
TIX_STDIN_OPTIONAL	tix.h	88;"	d
TIX_UNDEFINED	tix.h	233;"	d
TIX_UNIQUE	tix.h	232;"	d
TIX_VAR_ARGS	tix.h	143;"	d
TIX_VERSION	tix.h	20;"	d
TK_3D_DARK_GC	tk.h	305;"	d
TK_3D_FLAT_GC	tk.h	303;"	d
TK_3D_LIGHT_GC	tk.h	304;"	d
TK_4_1_OR_LATER	tix.h	57;"	d
TK_4_1_OR_LATER	tix.h	60;"	d
TK_8_0_OR_LATER	tix.h	65;"	d
TK_ALL_EVENTS	tk.h	980;"	d
TK_ALREADY_DEAD	tk.h	608;"	d
TK_ANCHOR_CENTER	tk.h	/^    TK_ANCHOR_CENTER$/;"	e	enum:__anon32
TK_ANCHOR_E	tk.h	/^    TK_ANCHOR_N, TK_ANCHOR_NE, TK_ANCHOR_E, TK_ANCHOR_SE,$/;"	e	enum:__anon32
TK_ANCHOR_N	tk.h	/^    TK_ANCHOR_N, TK_ANCHOR_NE, TK_ANCHOR_E, TK_ANCHOR_SE,$/;"	e	enum:__anon32
TK_ANCHOR_NE	tk.h	/^    TK_ANCHOR_N, TK_ANCHOR_NE, TK_ANCHOR_E, TK_ANCHOR_SE,$/;"	e	enum:__anon32
TK_ANCHOR_NW	tk.h	/^    TK_ANCHOR_S, TK_ANCHOR_SW, TK_ANCHOR_W, TK_ANCHOR_NW,$/;"	e	enum:__anon32
TK_ANCHOR_S	tk.h	/^    TK_ANCHOR_S, TK_ANCHOR_SW, TK_ANCHOR_W, TK_ANCHOR_NW,$/;"	e	enum:__anon32
TK_ANCHOR_SE	tk.h	/^    TK_ANCHOR_N, TK_ANCHOR_NE, TK_ANCHOR_E, TK_ANCHOR_SE,$/;"	e	enum:__anon32
TK_ANCHOR_SW	tk.h	/^    TK_ANCHOR_S, TK_ANCHOR_SW, TK_ANCHOR_W, TK_ANCHOR_NW,$/;"	e	enum:__anon32
TK_ANCHOR_W	tk.h	/^    TK_ANCHOR_S, TK_ANCHOR_SW, TK_ANCHOR_W, TK_ANCHOR_NW,$/;"	e	enum:__anon32
TK_ARGV_CONSTANT	tk.h	130;"	d
TK_ARGV_CONST_OPTION	tk.h	139;"	d
TK_ARGV_DONT_SKIP_FIRST_ARG	tk.h	153;"	d
TK_ARGV_END	tk.h	144;"	d
TK_ARGV_FLOAT	tk.h	135;"	d
TK_ARGV_FUNC	tk.h	136;"	d
TK_ARGV_GENFUNC	tk.h	137;"	d
TK_ARGV_HELP	tk.h	138;"	d
TK_ARGV_INT	tk.h	131;"	d
TK_ARGV_NO_ABBREV	tk.h	152;"	d
TK_ARGV_NO_DEFAULTS	tk.h	150;"	d
TK_ARGV_NO_LEFTOVERS	tk.h	151;"	d
TK_ARGV_OPTION_NAME_VALUE	tk.h	141;"	d
TK_ARGV_OPTION_VALUE	tk.h	140;"	d
TK_ARGV_REST	tk.h	134;"	d
TK_ARGV_STRING	tk.h	132;"	d
TK_ARGV_UID	tk.h	133;"	d
TK_ARGV_VERSION	tk.h	143;"	d
TK_AT_LEAST_ONE	tk.h	360;"	d
TK_BOTH_HALVES	tk.h	616;"	d
TK_CHECKED_IC	tk.h	611;"	d
TK_CONFIG_ACTIVE_CURSOR	tk.h	225;"	d
TK_CONFIG_ANCHOR	tk.h	227;"	d
TK_CONFIG_ARGV_ONLY	tk.h	253;"	d
TK_CONFIG_BITMAP	tk.h	221;"	d
TK_CONFIG_BOOLEAN	tk.h	214;"	d
TK_CONFIG_BORDER	tk.h	222;"	d
TK_CONFIG_CAP_STYLE	tk.h	229;"	d
TK_CONFIG_COLOR	tk.h	219;"	d
TK_CONFIG_COLOR_ONLY	tk.h	262;"	d
TK_CONFIG_CURSOR	tk.h	224;"	d
TK_CONFIG_CUSTOM	tk.h	234;"	d
TK_CONFIG_DONT_SET_DEFAULT	tk.h	265;"	d
TK_CONFIG_DOUBLE	tk.h	216;"	d
TK_CONFIG_END	tk.h	235;"	d
TK_CONFIG_FONT	tk.h	220;"	d
TK_CONFIG_INT	tk.h	215;"	d
TK_CONFIG_JOIN_STYLE	tk.h	230;"	d
TK_CONFIG_JUSTIFY	tk.h	226;"	d
TK_CONFIG_MM	tk.h	232;"	d
TK_CONFIG_MONO_ONLY	tk.h	263;"	d
TK_CONFIG_NULL_OK	tk.h	264;"	d
TK_CONFIG_OPTION_SPECIFIED	tk.h	266;"	d
TK_CONFIG_PIXELS	tk.h	231;"	d
TK_CONFIG_RELIEF	tk.h	223;"	d
TK_CONFIG_STRING	tk.h	217;"	d
TK_CONFIG_SYNONYM	tk.h	228;"	d
TK_CONFIG_UID	tk.h	218;"	d
TK_CONFIG_USER_BIT	tk.h	267;"	d
TK_CONFIG_WINDOW	tk.h	233;"	d
TK_CONTAINER	tk.h	615;"	d
TK_DEFER_EVENT	tk.h	/^    TK_DEFER_EVENT, TK_PROCESS_EVENT, TK_DISCARD_EVENT$/;"	e	enum:__anon31
TK_DEFER_MODAL	tk.h	617;"	d
TK_DISCARD_EVENT	tk.h	/^    TK_DEFER_EVENT, TK_PROCESS_EVENT, TK_DISCARD_EVENT$/;"	e	enum:__anon31
TK_DONT_DESTROY_WINDOW	tk.h	612;"	d
TK_DONT_WAIT	tk.h	974;"	d
TK_EMBEDDED	tk.h	614;"	d
TK_EXCEPTION	tk.h	972;"	d
TK_FILE_EVENTS	tk.h	977;"	d
TK_GRAB_FLAG	tk.h	610;"	d
TK_IDLE_EVENTS	tk.h	979;"	d
TK_IGNORE_NEWLINES	tk.h	368;"	d
TK_IGNORE_TABS	tk.h	367;"	d
TK_INTERACTIVE_PRIO	tk.h	285;"	d
TK_JUSTIFY_CENTER	tk.h	/^    TK_JUSTIFY_LEFT, TK_JUSTIFY_RIGHT, TK_JUSTIFY_CENTER$/;"	e	enum:__anon33
TK_JUSTIFY_LEFT	tk.h	/^    TK_JUSTIFY_LEFT, TK_JUSTIFY_RIGHT, TK_JUSTIFY_CENTER$/;"	e	enum:__anon33
TK_JUSTIFY_RIGHT	tk.h	/^    TK_JUSTIFY_LEFT, TK_JUSTIFY_RIGHT, TK_JUSTIFY_CENTER$/;"	e	enum:__anon33
TK_LASTEVENT	tk.h	414;"	d
TK_LASTEVENT	tk.h	418;"	d
TK_MAJOR_VERSION	tk.h	40;"	d
TK_MAPPED	tk.h	606;"	d
TK_MAX_PRIO	tk.h	286;"	d
TK_MINOR_VERSION	tk.h	41;"	d
TK_NEED_CONFIG_NOTIFY	tk.h	609;"	d
TK_NOTIFY_SHARE	tk.h	314;"	d
TK_PARTIAL_OK	tk.h	361;"	d
TK_PATCH_LEVEL	tk.h	46;"	d
TK_PROCESS_EVENT	tk.h	/^    TK_DEFER_EVENT, TK_PROCESS_EVENT, TK_DISCARD_EVENT$/;"	e	enum:__anon31
TK_READABLE	tk.h	970;"	d
TK_RELEASE_LEVEL	tk.h	42;"	d
TK_RELEASE_SERIAL	tk.h	43;"	d
TK_RELIEF_FLAT	tk.h	293;"	d
TK_RELIEF_GROOVE	tk.h	295;"	d
TK_RELIEF_RAISED	tk.h	292;"	d
TK_RELIEF_RIDGE	tk.h	296;"	d
TK_RELIEF_SOLID	tk.h	297;"	d
TK_RELIEF_SUNKEN	tk.h	294;"	d
TK_REPARENTED	tk.h	619;"	d
TK_SCROLL_ERROR	tk.h	402;"	d
TK_SCROLL_MOVETO	tk.h	399;"	d
TK_SCROLL_PAGES	tk.h	400;"	d
TK_SCROLL_UNITS	tk.h	401;"	d
TK_STARTUP_FILE_PRIO	tk.h	283;"	d
TK_TAG_SPACE	tk.h	637;"	d
TK_TIMER_EVENTS	tk.h	978;"	d
TK_TOP_LEVEL	tk.h	607;"	d
TK_USER_DEFAULT_PRIO	tk.h	284;"	d
TK_USE_INPUT_METHODS	tk.h	86;"	d
TK_VERSION	tk.h	45;"	d
TK_WHOLE_WORDS	tk.h	359;"	d
TK_WIDGET_DEFAULT_PRIO	tk.h	282;"	d
TK_WINDOW_EVENTS	tk.h	976;"	d
TK_WM_COLORMAP_WINDOW	tk.h	613;"	d
TK_WRAPPER	tk.h	618;"	d
TK_WRITABLE	tk.h	971;"	d
TK_X_EVENTS	tk.h	975;"	d
TRUE_FALSE_ALREADY_DEFINED	bfd.h	93;"	d
TRUE_FALSE_ALREADY_DEFINED	bfd.h	98;"	d
Tcl_Alloc	tcl.h	666;"	d
Tcl_AppInitProc	tcl.h	/^typedef int (Tcl_AppInitProc) _ANSI_ARGS_((Tcl_Interp *interp));$/;"	t
Tcl_AsyncHandler	tcl.h	/^typedef struct Tcl_AsyncHandler_ *Tcl_AsyncHandler;$/;"	t	typeref:struct:Tcl_AsyncHandler_
Tcl_AsyncProc	tcl.h	/^typedef int (Tcl_AsyncProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tcl_CallFrame	tcl.h	/^typedef struct Tcl_CallFrame {$/;"	s
Tcl_CallFrame	tcl.h	/^} Tcl_CallFrame;$/;"	t	typeref:struct:Tcl_CallFrame
Tcl_Channel	tcl.h	/^typedef struct Tcl_Channel_ *Tcl_Channel;$/;"	t	typeref:struct:Tcl_Channel_
Tcl_ChannelProc	tcl.h	/^typedef void (Tcl_ChannelProc) _ANSI_ARGS_((ClientData clientData, int mask));$/;"	t
Tcl_ChannelType	tcl.h	/^typedef struct Tcl_ChannelType {$/;"	s
Tcl_ChannelType	tcl.h	/^} Tcl_ChannelType;$/;"	t	typeref:struct:Tcl_ChannelType
Tcl_Ckalloc	tcl.h	1023;"	d
Tcl_Ckfree	tcl.h	1024;"	d
Tcl_Ckrealloc	tcl.h	1025;"	d
Tcl_CloseProc	tcl.h	/^typedef void (Tcl_CloseProc) _ANSI_ARGS_((ClientData data));$/;"	t
Tcl_CmdDeleteProc	tcl.h	/^typedef void (Tcl_CmdDeleteProc) _ANSI_ARGS_((ClientData clientData));$/;"	t
Tcl_CmdInfo	tcl.h	/^typedef struct Tcl_CmdInfo {$/;"	s
Tcl_CmdInfo	tcl.h	/^} Tcl_CmdInfo;$/;"	t	typeref:struct:Tcl_CmdInfo
Tcl_CmdProc	tcl.h	/^typedef int (Tcl_CmdProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tcl_CmdTraceProc	tcl.h	/^typedef void (Tcl_CmdTraceProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tcl_Command	tcl.h	/^typedef struct Tcl_Command_ *Tcl_Command;$/;"	t	typeref:struct:Tcl_Command_
Tcl_CreateHashEntry	tcl.h	817;"	d
Tcl_DString	tcl.h	/^typedef struct Tcl_DString {$/;"	s
Tcl_DString	tcl.h	/^} Tcl_DString;$/;"	t	typeref:struct:Tcl_DString
Tcl_DStringLength	tcl.h	581;"	d
Tcl_DStringTrunc	tcl.h	583;"	d
Tcl_DStringValue	tcl.h	582;"	d
Tcl_DecrRefCount	tcl.h	420;"	d
Tcl_DecrRefCount	tcl.h	427;"	d
Tcl_DriverBlockModeProc	tcl.h	/^typedef int	(Tcl_DriverBlockModeProc) _ANSI_ARGS_(($/;"	t
Tcl_DriverCloseProc	tcl.h	/^typedef int	(Tcl_DriverCloseProc) _ANSI_ARGS_((ClientData instanceData,$/;"	t
Tcl_DriverGetHandleProc	tcl.h	/^typedef int	(Tcl_DriverGetHandleProc) _ANSI_ARGS_(($/;"	t
Tcl_DriverGetOptionProc	tcl.h	/^typedef int	(Tcl_DriverGetOptionProc) _ANSI_ARGS_(($/;"	t
Tcl_DriverInputProc	tcl.h	/^typedef int	(Tcl_DriverInputProc) _ANSI_ARGS_((ClientData instanceData,$/;"	t
Tcl_DriverOutputProc	tcl.h	/^typedef int	(Tcl_DriverOutputProc) _ANSI_ARGS_((ClientData instanceData,$/;"	t
Tcl_DriverSeekProc	tcl.h	/^typedef int	(Tcl_DriverSeekProc) _ANSI_ARGS_((ClientData instanceData,$/;"	t
Tcl_DriverSetOptionProc	tcl.h	/^typedef int	(Tcl_DriverSetOptionProc) _ANSI_ARGS_(($/;"	t
Tcl_DriverWatchProc	tcl.h	/^typedef void	(Tcl_DriverWatchProc) _ANSI_ARGS_(($/;"	t
Tcl_DumpActiveMemory	tcl.h	700;"	d
Tcl_DupInternalRepProc	tcl.h	/^typedef void (Tcl_DupInternalRepProc) _ANSI_ARGS_((struct Tcl_Obj *srcPtr, $/;"	t
Tcl_EolTranslation	tcl.h	/^typedef enum Tcl_EolTranslation {$/;"	g
Tcl_EolTranslation	tcl.h	/^} Tcl_EolTranslation;$/;"	t	typeref:enum:Tcl_EolTranslation
Tcl_Event	tcl.h	/^struct Tcl_Event {$/;"	s
Tcl_Event	tcl.h	/^typedef struct Tcl_Event Tcl_Event;$/;"	t	typeref:struct:Tcl_Event
Tcl_EventCheckProc	tcl.h	/^typedef void (Tcl_EventCheckProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tcl_EventDeleteProc	tcl.h	/^typedef int (Tcl_EventDeleteProc) _ANSI_ARGS_((Tcl_Event *evPtr,$/;"	t
Tcl_EventProc	tcl.h	/^typedef int (Tcl_EventProc) _ANSI_ARGS_((Tcl_Event *evPtr, int flags));$/;"	t
Tcl_EventSetupProc	tcl.h	/^typedef void (Tcl_EventSetupProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tcl_ExitProc	tcl.h	/^typedef void (Tcl_ExitProc) _ANSI_ARGS_((ClientData clientData));$/;"	t
Tcl_FileFreeProc	tcl.h	/^typedef void (Tcl_FileFreeProc) _ANSI_ARGS_((ClientData clientData));$/;"	t
Tcl_FileProc	tcl.h	/^typedef void (Tcl_FileProc) _ANSI_ARGS_((ClientData clientData, int mask));$/;"	t
Tcl_FindHashEntry	tcl.h	815;"	d
Tcl_Free	tcl.h	667;"	d
Tcl_FreeInternalRepProc	tcl.h	/^typedef void (Tcl_FreeInternalRepProc) _ANSI_ARGS_((struct Tcl_Obj *objPtr));$/;"	t
Tcl_FreeProc	tcl.h	/^typedef void (Tcl_FreeProc) _ANSI_ARGS_((char *blockPtr));$/;"	t
Tcl_GetHashKey	tcl.h	806;"	d
Tcl_GetHashValue	tcl.h	804;"	d
Tcl_HashEntry	tcl.h	/^typedef struct Tcl_HashEntry {$/;"	s
Tcl_HashEntry	tcl.h	/^} Tcl_HashEntry;$/;"	t	typeref:struct:Tcl_HashEntry
Tcl_HashSearch	tcl.h	/^typedef struct Tcl_HashSearch {$/;"	s
Tcl_HashSearch	tcl.h	/^} Tcl_HashSearch;$/;"	t	typeref:struct:Tcl_HashSearch
Tcl_HashTable	tcl.h	/^typedef struct Tcl_HashTable {$/;"	s
Tcl_HashTable	tcl.h	/^} Tcl_HashTable;$/;"	t	typeref:struct:Tcl_HashTable
Tcl_IdleProc	tcl.h	/^typedef void (Tcl_IdleProc) _ANSI_ARGS_((ClientData clientData));$/;"	t
Tcl_IncrRefCount	tcl.h	418;"	d
Tcl_IncrRefCount	tcl.h	425;"	d
Tcl_Interp	tcl.h	/^typedef struct Tcl_Interp {$/;"	s
Tcl_Interp	tcl.h	/^} Tcl_Interp;$/;"	t	typeref:struct:Tcl_Interp
Tcl_InterpDeleteProc	tcl.h	/^typedef void (Tcl_InterpDeleteProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tcl_IsShared	tcl.h	422;"	d
Tcl_IsShared	tcl.h	429;"	d
Tcl_MathProc	tcl.h	/^typedef int (Tcl_MathProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tcl_Namespace	tcl.h	/^typedef struct Tcl_Namespace {$/;"	s
Tcl_Namespace	tcl.h	/^} Tcl_Namespace;$/;"	t	typeref:struct:Tcl_Namespace
Tcl_NamespaceDeleteProc	tcl.h	/^typedef void (Tcl_NamespaceDeleteProc) _ANSI_ARGS_((ClientData clientData));$/;"	t
Tcl_NewBooleanObj	tcl.h	450;"	d
Tcl_NewDoubleObj	tcl.h	452;"	d
Tcl_NewIntObj	tcl.h	454;"	d
Tcl_NewListObj	tcl.h	456;"	d
Tcl_NewLongObj	tcl.h	458;"	d
Tcl_NewObj	tcl.h	460;"	d
Tcl_NewStringObj	tcl.h	462;"	d
Tcl_Obj	tcl.h	/^typedef struct Tcl_Obj {$/;"	s
Tcl_Obj	tcl.h	/^} Tcl_Obj;$/;"	t	typeref:struct:Tcl_Obj
Tcl_ObjCmdProc	tcl.h	/^typedef int (Tcl_ObjCmdProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tcl_ObjType	tcl.h	/^typedef struct Tcl_ObjType {$/;"	s
Tcl_ObjType	tcl.h	/^} Tcl_ObjType;$/;"	t	typeref:struct:Tcl_ObjType
Tcl_PackageInitProc	tcl.h	/^typedef int (Tcl_PackageInitProc) _ANSI_ARGS_((Tcl_Interp *interp));$/;"	t
Tcl_PathType	tcl.h	/^typedef enum Tcl_PathType {$/;"	g
Tcl_PathType	tcl.h	/^} Tcl_PathType;$/;"	t	typeref:enum:Tcl_PathType
Tcl_Pid	tcl.h	/^typedef struct Tcl_Pid_ *Tcl_Pid;$/;"	t	typeref:struct:Tcl_Pid_
Tcl_QueuePosition	tcl.h	/^} Tcl_QueuePosition;$/;"	t	typeref:enum:__anon57
Tcl_Realloc	tcl.h	668;"	d
Tcl_RegExp	tcl.h	/^typedef struct Tcl_RegExp_ *Tcl_RegExp;$/;"	t	typeref:struct:Tcl_RegExp_
Tcl_Return	tcl.h	1378;"	d
Tcl_SetFromAnyProc	tcl.h	/^typedef int (Tcl_SetFromAnyProc) _ANSI_ARGS_((Tcl_Interp *interp,$/;"	t
Tcl_SetHashValue	tcl.h	805;"	d
Tcl_TcpAcceptProc	tcl.h	/^typedef void (Tcl_TcpAcceptProc) _ANSI_ARGS_((ClientData callbackData,$/;"	t
Tcl_TildeSubst	tcl.h	1448;"	d
Tcl_Time	tcl.h	/^typedef struct Tcl_Time {$/;"	s
Tcl_Time	tcl.h	/^} Tcl_Time;$/;"	t	typeref:struct:Tcl_Time
Tcl_TimerProc	tcl.h	/^typedef void (Tcl_TimerProc) _ANSI_ARGS_((ClientData clientData));$/;"	t
Tcl_TimerToken	tcl.h	/^typedef struct Tcl_TimerToken_ *Tcl_TimerToken;$/;"	t	typeref:struct:Tcl_TimerToken_
Tcl_Trace	tcl.h	/^typedef struct Tcl_Trace_ *Tcl_Trace;$/;"	t	typeref:struct:Tcl_Trace_
Tcl_UpdateStringProc	tcl.h	/^typedef void (Tcl_UpdateStringProc) _ANSI_ARGS_((struct Tcl_Obj *objPtr));$/;"	t
Tcl_ValidateAllMemory	tcl.h	701;"	d
Tcl_Value	tcl.h	/^typedef struct Tcl_Value {$/;"	s
Tcl_Value	tcl.h	/^} Tcl_Value;$/;"	t	typeref:struct:Tcl_Value
Tcl_ValueType	tcl.h	/^typedef enum {TCL_INT, TCL_DOUBLE, TCL_EITHER} Tcl_ValueType;$/;"	t	typeref:enum:__anon53
Tcl_Var	tcl.h	/^typedef struct Tcl_Var_ *Tcl_Var;$/;"	t	typeref:struct:Tcl_Var_
Tcl_VarTraceProc	tcl.h	/^typedef char *(Tcl_VarTraceProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tix_ArraySize	tix.h	137;"	d
Tix_CheckArgvProc	tix.h	/^typedef int (*Tix_CheckArgvProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tix_CmdInfo	tix.h	/^} Tix_CmdInfo;$/;"	t	typeref:struct:_Tix_CmdInfo
Tix_CmdProc	tix.h	/^typedef int (*Tix_CmdProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tix_FreeProc	tix.h	70;"	d
Tix_FreeProc	tix.h	74;"	d
Tix_IsLinkListEmpty	tix.h	231;"	d
Tix_LinkList	tix.h	/^typedef struct Tix_LinkList {$/;"	s
Tix_LinkList	tix.h	/^} Tix_LinkList;$/;"	t	typeref:struct:Tix_LinkList
Tix_LinkListDone	tix.h	268;"	d
Tix_ListInfo	tix.h	/^typedef struct Tix_ListInfo {$/;"	s
Tix_ListInfo	tix.h	/^} Tix_ListInfo;$/;"	t	typeref:struct:Tix_ListInfo
Tix_ListIterator	tix.h	/^typedef struct Tix_ListIterator {$/;"	s
Tix_ListIterator	tix.h	/^} Tix_ListIterator;$/;"	t	typeref:struct:Tix_ListIterator
Tix_Relief	tix.h	/^typedef int Tix_Relief;$/;"	t
Tix_SimpleListDone	tix.h	303;"	d
Tix_SubCmdInfo	tix.h	/^} Tix_SubCmdInfo;$/;"	t	typeref:struct:_Tix_SubCmdInfo
Tix_SubCmdProc	tix.h	/^typedef int (*Tix_SubCmdProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tix_TclCmd	tix.h	/^} Tix_TclCmd;$/;"	t	typeref:struct:__anon58
TkPutImage	tix.h	79;"	d
TkStringToKeysym	tix.h	82;"	d
Tk_3DBorder	tk.h	/^typedef struct Tk_3DBorder_ *Tk_3DBorder;$/;"	t	typeref:struct:Tk_3DBorder_
Tk_AfterCmd	tk.h	999;"	d
Tk_Anchor	tk.h	/^} Tk_Anchor;$/;"	t	typeref:enum:__anon32
Tk_ArgvInfo	tk.h	/^} Tk_ArgvInfo;$/;"	t	typeref:struct:__anon30
Tk_Attributes	tk.h	481;"	d
Tk_BackgroundError	tk.h	987;"	d
Tk_BindingTable	tk.h	/^typedef struct Tk_BindingTable_ *Tk_BindingTable;$/;"	t	typeref:struct:Tk_BindingTable_
Tk_CancelIdleCall	tk.h	988;"	d
Tk_Canvas	tk.h	/^typedef struct Tk_Canvas_ *Tk_Canvas;$/;"	t	typeref:struct:Tk_Canvas_
Tk_CanvasTextInfo	tk.h	/^typedef struct Tk_CanvasTextInfo {$/;"	s
Tk_CanvasTextInfo	tk.h	/^} Tk_CanvasTextInfo;$/;"	t	typeref:struct:Tk_CanvasTextInfo
Tk_Changes	tk.h	480;"	d
Tk_Class	tk.h	474;"	d
Tk_Colormap	tk.h	495;"	d
Tk_ConfigSpec	tk.h	/^typedef struct Tk_ConfigSpec {$/;"	s
Tk_ConfigSpec	tk.h	/^} Tk_ConfigSpec;$/;"	t	typeref:struct:Tk_ConfigSpec
Tk_CreateFileHandler	tk.h	989;"	d
Tk_CreateTimerHandler	tk.h	990;"	d
Tk_Cursor	tk.h	/^typedef struct Tk_Cursor_ *Tk_Cursor;$/;"	t	typeref:struct:Tk_Cursor_
Tk_CustomOption	tk.h	/^typedef struct Tk_CustomOption {$/;"	s
Tk_CustomOption	tk.h	/^} Tk_CustomOption;$/;"	t	typeref:struct:Tk_CustomOption
Tk_DeleteFileHandler	tk.h	991;"	d
Tk_DeleteTimerHandler	tk.h	992;"	d
Tk_Depth	tk.h	469;"	d
Tk_Display	tk.h	465;"	d
Tk_DoOneEvent	tk.h	993;"	d
Tk_DoWhenIdle	tk.h	994;"	d
Tk_ErrorHandler	tk.h	/^typedef struct Tk_ErrorHandler_ *Tk_ErrorHandler;$/;"	t	typeref:struct:Tk_ErrorHandler_
Tk_ErrorProc	tk.h	/^typedef int (Tk_ErrorProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tk_EventProc	tk.h	/^typedef void (Tk_EventProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tk_EventuallyFree	tk.h	1000;"	d
Tk_FakeWin	tk.h	/^typedef struct Tk_FakeWin {$/;"	s
Tk_FakeWin	tk.h	/^} Tk_FakeWin;$/;"	t	typeref:struct:Tk_FakeWin
Tk_FileProc	tk.h	983;"	d
Tk_Font	tk.h	/^typedef struct Tk_Font_ *Tk_Font;$/;"	t	typeref:struct:Tk_Font_
Tk_FontMetrics	tk.h	/^typedef struct Tk_FontMetrics {$/;"	s
Tk_FontMetrics	tk.h	/^} Tk_FontMetrics;$/;"	t	typeref:struct:Tk_FontMetrics
Tk_FreeProc	tk.h	1001;"	d
Tk_GenericProc	tk.h	/^typedef int (Tk_GenericProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tk_GeomLostSlaveProc	tk.h	/^typedef void (Tk_GeomLostSlaveProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tk_GeomMgr	tk.h	/^typedef struct Tk_GeomMgr {$/;"	s
Tk_GeomMgr	tk.h	/^} Tk_GeomMgr;$/;"	t	typeref:struct:Tk_GeomMgr
Tk_GeomRequestProc	tk.h	/^typedef void (Tk_GeomRequestProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tk_GetSelProc	tk.h	/^typedef int (Tk_GetSelProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tk_Height	tk.h	478;"	d
Tk_IdleProc	tk.h	982;"	d
Tk_Image	tk.h	/^typedef struct Tk_Image__ *Tk_Image;$/;"	t	typeref:struct:Tk_Image__
Tk_ImageChangedProc	tk.h	/^typedef void (Tk_ImageChangedProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tk_ImageCreateProc	tk.h	/^typedef int (Tk_ImageCreateProc) _ANSI_ARGS_((Tcl_Interp *interp,$/;"	t
Tk_ImageDeleteProc	tk.h	/^typedef void (Tk_ImageDeleteProc) _ANSI_ARGS_((ClientData masterData));$/;"	t
Tk_ImageDisplayProc	tk.h	/^typedef void (Tk_ImageDisplayProc) _ANSI_ARGS_((ClientData instanceData,$/;"	t
Tk_ImageFileMatchProc	tk.h	/^typedef int (Tk_ImageFileMatchProc) _ANSI_ARGS_((Tcl_Channel chan,$/;"	t
Tk_ImageFileReadProc	tk.h	/^typedef int (Tk_ImageFileReadProc) _ANSI_ARGS_((Tcl_Interp *interp,$/;"	t
Tk_ImageFileWriteProc	tk.h	/^typedef int (Tk_ImageFileWriteProc) _ANSI_ARGS_((Tcl_Interp *interp,$/;"	t
Tk_ImageFreeProc	tk.h	/^typedef void (Tk_ImageFreeProc) _ANSI_ARGS_((ClientData instanceData,$/;"	t
Tk_ImageMaster	tk.h	/^typedef struct Tk_ImageMaster_ *Tk_ImageMaster;$/;"	t	typeref:struct:Tk_ImageMaster_
Tk_ImageStringMatchProc	tk.h	/^typedef int (Tk_ImageStringMatchProc) _ANSI_ARGS_((Tcl_Obj *dataObj,$/;"	t
Tk_ImageStringReadProc	tk.h	/^typedef int (Tk_ImageStringReadProc) _ANSI_ARGS_((Tcl_Interp *interp,$/;"	t
Tk_ImageStringWriteProc	tk.h	/^typedef int (Tk_ImageStringWriteProc) _ANSI_ARGS_((Tcl_Interp *interp,$/;"	t
Tk_ImageType	tk.h	/^struct Tk_ImageType {$/;"	s
Tk_ImageType	tk.h	/^typedef struct Tk_ImageType Tk_ImageType;$/;"	t	typeref:struct:Tk_ImageType
Tk_InternalBorderWidth	tk.h	492;"	d
Tk_IsContainer	tk.h	484;"	d
Tk_IsEmbedded	tk.h	482;"	d
Tk_IsMapped	tk.h	486;"	d
Tk_IsTopLevel	tk.h	488;"	d
Tk_Item	tk.h	/^typedef struct Tk_Item  {$/;"	s
Tk_Item	tk.h	/^} Tk_Item;$/;"	t	typeref:struct:Tk_Item
Tk_ItemAreaProc	tk.h	/^typedef int	Tk_ItemAreaProc _ANSI_ARGS_((Tk_Canvas canvas,$/;"	t
Tk_ItemConfigureProc	tk.h	/^typedef int	Tk_ItemConfigureProc _ANSI_ARGS_((Tcl_Interp *interp,$/;"	t
Tk_ItemCoordProc	tk.h	/^typedef int	Tk_ItemCoordProc _ANSI_ARGS_((Tcl_Interp *interp,$/;"	t
Tk_ItemCreateProc	tk.h	/^typedef int	Tk_ItemCreateProc _ANSI_ARGS_((Tcl_Interp *interp,$/;"	t
Tk_ItemCursorProc	tk.h	/^typedef void	Tk_ItemCursorProc _ANSI_ARGS_((Tk_Canvas canvas,$/;"	t
Tk_ItemDCharsProc	tk.h	/^typedef void	Tk_ItemDCharsProc _ANSI_ARGS_((Tk_Canvas canvas,$/;"	t
Tk_ItemDeleteProc	tk.h	/^typedef void	Tk_ItemDeleteProc _ANSI_ARGS_((Tk_Canvas canvas,$/;"	t
Tk_ItemDisplayProc	tk.h	/^typedef void	Tk_ItemDisplayProc _ANSI_ARGS_((Tk_Canvas canvas,$/;"	t
Tk_ItemIndexProc	tk.h	/^typedef int	Tk_ItemIndexProc _ANSI_ARGS_((Tcl_Interp *interp,$/;"	t
Tk_ItemInsertProc	tk.h	/^typedef void	Tk_ItemInsertProc _ANSI_ARGS_((Tk_Canvas canvas,$/;"	t
Tk_ItemPointProc	tk.h	/^typedef double	Tk_ItemPointProc _ANSI_ARGS_((Tk_Canvas canvas,$/;"	t
Tk_ItemPostscriptProc	tk.h	/^typedef int	Tk_ItemPostscriptProc _ANSI_ARGS_((Tcl_Interp *interp,$/;"	t
Tk_ItemScaleProc	tk.h	/^typedef void	Tk_ItemScaleProc _ANSI_ARGS_((Tk_Canvas canvas,$/;"	t
Tk_ItemSelectionProc	tk.h	/^typedef int	Tk_ItemSelectionProc _ANSI_ARGS_((Tk_Canvas canvas,$/;"	t
Tk_ItemTranslateProc	tk.h	/^typedef void	Tk_ItemTranslateProc _ANSI_ARGS_((Tk_Canvas canvas,$/;"	t
Tk_ItemType	tk.h	/^typedef struct Tk_ItemType {$/;"	s
Tk_ItemType	tk.h	/^} Tk_ItemType;$/;"	t	typeref:struct:Tk_ItemType
Tk_Justify	tk.h	/^} Tk_Justify;$/;"	t	typeref:enum:__anon33
Tk_LostSelProc	tk.h	/^typedef void (Tk_LostSelProc) _ANSI_ARGS_((ClientData clientData));$/;"	t
Tk_Name	tk.h	473;"	d
Tk_Offset	tk.h	244;"	d
Tk_Offset	tk.h	246;"	d
Tk_OptionParseProc	tk.h	/^typedef int (Tk_OptionParseProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tk_OptionPrintProc	tk.h	/^typedef char *(Tk_OptionPrintProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tk_Parent	tk.h	494;"	d
Tk_PathName	tk.h	472;"	d
Tk_PhotoHandle	tk.h	/^typedef void *Tk_PhotoHandle;$/;"	t
Tk_PhotoImageBlock	tk.h	/^typedef struct Tk_PhotoImageBlock {$/;"	s
Tk_PhotoImageBlock	tk.h	/^} Tk_PhotoImageBlock;$/;"	t	typeref:struct:Tk_PhotoImageBlock
Tk_PhotoImageFormat	tk.h	/^struct Tk_PhotoImageFormat {$/;"	s
Tk_PhotoImageFormat	tk.h	/^typedef struct Tk_PhotoImageFormat Tk_PhotoImageFormat;$/;"	t	typeref:struct:Tk_PhotoImageFormat
Tk_Preserve	tk.h	1002;"	d
Tk_Release	tk.h	1003;"	d
Tk_ReqHeight	tk.h	491;"	d
Tk_ReqWidth	tk.h	490;"	d
Tk_RestrictAction	tk.h	/^} Tk_RestrictAction;$/;"	t	typeref:enum:__anon31
Tk_Screen	tk.h	467;"	d
Tk_ScreenNumber	tk.h	466;"	d
Tk_SelectionProc	tk.h	/^typedef int (Tk_SelectionProc) _ANSI_ARGS_((ClientData clientData,$/;"	t
Tk_Sleep	tk.h	995;"	d
Tk_TextLayout	tk.h	/^typedef struct Tk_TextLayout_ *Tk_TextLayout;$/;"	t	typeref:struct:Tk_TextLayout_
Tk_TimerProc	tk.h	984;"	d
Tk_TimerToken	tk.h	985;"	d
Tk_Uid	tk.h	/^typedef char *Tk_Uid;$/;"	t
Tk_Visual	tk.h	470;"	d
Tk_Width	tk.h	477;"	d
Tk_Window	tk.h	/^typedef struct Tk_Window_ *Tk_Window;$/;"	t	typeref:struct:Tk_Window_
Tk_WindowId	tk.h	471;"	d
Tk_X	tk.h	475;"	d
Tk_Y	tk.h	476;"	d
UCHAR_MAX	include/limits.h	36;"	d
UCHAR_MAX	include/limits.h	37;"	d
UINT_MAX	include/limits.h	73;"	d
UINT_MAX	include/limits.h	74;"	d
ULONG_LONG_MAX	include/limits.h	105;"	d
ULONG_LONG_MAX	include/limits.h	106;"	d
ULONG_MAX	include/limits.h	91;"	d
ULONG_MAX	include/limits.h	92;"	d
UNCTRL	readline/chardefs.h	32;"	d
UNDO_BEGIN	readline/readline.h	/^enum undo_code { UNDO_DELETE, UNDO_INSERT, UNDO_BEGIN, UNDO_END };$/;"	e	enum:undo_code
UNDO_DELETE	readline/readline.h	/^enum undo_code { UNDO_DELETE, UNDO_INSERT, UNDO_BEGIN, UNDO_END };$/;"	e	enum:undo_code
UNDO_END	readline/readline.h	/^enum undo_code { UNDO_DELETE, UNDO_INSERT, UNDO_BEGIN, UNDO_END };$/;"	e	enum:undo_code
UNDO_INSERT	readline/readline.h	/^enum undo_code { UNDO_DELETE, UNDO_INSERT, UNDO_BEGIN, UNDO_END };$/;"	e	enum:undo_code
UNDO_LIST	readline/readline.h	/^} UNDO_LIST;$/;"	t	typeref:struct:undo_list
UNMETA	readline/chardefs.h	31;"	d
USE_PROTOTYPE	tcl.h	62;"	d
USE_PROTOTYPE	tcl.h	68;"	d
USE_TCLALLOC	tcl.h	687;"	d
USE_TCLALLOC	tcl.h	71;"	d
USE_TCLALLOC	tcl.h	89;"	d
USHRT_MAX	include/limits.h	60;"	d
USHRT_MAX	include/limits.h	61;"	d
VA_START	ansidecl.h	115;"	d
VA_START	ansidecl.h	142;"	d
VFunction	readline/keymaps.h	/^typedef void VFunction ();$/;"	t
VOID	tcl.h	166;"	d
VOID	tcl.h	168;"	d
VOID	tcl.h	176;"	d
VOLATILE	ansidecl.h	108;"	d
VOLATILE	ansidecl.h	136;"	d
VPARAMS	ansidecl.h	114;"	d
VPARAMS	ansidecl.h	141;"	d
VTABLE_LABEL	g++/libioP.h	590;"	d
VTABLE_LABEL	g++/libioP.h	593;"	d
VirtualEvent	tk.h	411;"	d
VirtualEventMask	tk.h	416;"	d
WP_TEXT	bfd.h	230;"	d
WS	g++/stream.h	/^inline istream& WS(istream& str) { return ws(str); }$/;"	f
XActivateDeactivateEvent	tk.h	/^} XActivateDeactivateEvent;$/;"	t	typeref:struct:__anon35
XActivateEvent	tk.h	/^typedef XActivateDeactivateEvent XActivateEvent;$/;"	t
XCAT2	bfd.h	452;"	d
XDeactivateEvent	tk.h	/^typedef XActivateDeactivateEvent XDeactivateEvent;$/;"	t
XVirtualEvent	tk.h	/^} XVirtualEvent;$/;"	t	typeref:struct:__anon34
YYLeng	FlexLexer.h	/^	int YYLeng()		{ return yyleng; }$/;"	f	class:FlexLexer
YYText	FlexLexer.h	/^	const char* YYText()	{ return yytext; }$/;"	f	class:FlexLexer
_ANSIDECL_H	ansidecl.h	89;"	d
_ANSI_ARGS_	expect_comm.h	64;"	d
_ANSI_ARGS_	expect_comm.h	69;"	d
_ANSI_ARGS_	expect_comm.h	72;"	d
_ANSI_ARGS_	tcl.h	140;"	d
_ANSI_ARGS_	tcl.h	145;"	d
_ANSI_ARGS_	tcl.h	148;"	d
_ANSI_ARGS_	tk.h	/^typedef ClientData (Tk_ImageGetProc) _ANSI_ARGS_((Tk_Window tkwin,$/;"	t
_ANSI_ARGS_	tk.h	/^typedef Tk_RestrictAction (Tk_RestrictProc) _ANSI_ARGS_(($/;"	t
_ANSI_STDARG_H_	include/stdarg.h	10;"	d
_ANSI_STDARG_H_	include/varargs.h	68;"	d
_ANSI_STDDEF_H	include/stddef.h	16;"	d
_BSD_PTRDIFF_T_	include/stddef.h	112;"	d
_BSD_PTRDIFF_T_	include/stddef.h	294;"	d
_BSD_PTRDIFF_T_	include/stddef.h	307;"	d
_BSD_PTRDIFF_T_	include/stddef.h	51;"	d
_BSD_SIZE_T_	include/stddef.h	159;"	d
_BSD_SIZE_T_	include/stddef.h	298;"	d
_BSD_SIZE_T_	include/stddef.h	311;"	d
_BSD_SIZE_T_	include/stddef.h	55;"	d
_BSD_VA_LIST	include/stdarg.h	148;"	d
_BSD_VA_LIST	include/varargs.h	219;"	d
_BSD_WCHAR_T_	include/stddef.h	220;"	d
_BSD_WCHAR_T_	include/stddef.h	239;"	d
_BSD_WCHAR_T_	include/stddef.h	302;"	d
_BSD_WCHAR_T_	include/stddef.h	315;"	d
_BSD_WCHAR_T_	include/stddef.h	59;"	d
_BUILTINBUF_H	g++/builtinbuf.h	26;"	d
_CHARDEFS_	readline/chardefs.h	3;"	d
_CLIENTDATA	tcl.h	197;"	d
_COMPAT_STREAM_H	g++/stream.h	26;"	d
_EDITBUF_H	g++/editbuf.h	28;"	d
_EXPECT_COMM_H	expect_comm.h	11;"	d
_EXPECT_H	expect.h	12;"	d
_EXPECT_TCL_H	expect_tcl.h	13;"	d
_FLOAT_H_	include/float.h	3;"	d
_FSTREAM_H	g++/fstream.h	26;"	d
_GCC_LIMITS_H_	include/limits.h	7;"	d
_GCC_NEXT_LIMITS_H	include/syslimits.h	6;"	d
_GCC_NEXT_LIMITS_H	include/syslimits.h	8;"	d
_GCC_PTRDIFF_T	include/stddef.h	114;"	d
_GCC_SIZE_T	include/stddef.h	163;"	d
_GCC_WCHAR_T	include/stddef.h	226;"	d
_G_HAVE_MMAP	g++/libioP.h	483;"	d
_G_HAVE_MMAP	g++/libioP.h	484;"	d
_INDSTREAM_H	g++/indstream.h	28;"	d
_IOFBF	g++/iostdio.h	47;"	d
_IOLBF	g++/iostdio.h	48;"	d
_IOMANIP_H	g++/iomanip.h	29;"	d
_IONBF	g++/iostdio.h	49;"	d
_IOSTDIO_H	g++/iostdio.h	33;"	d
_IOSTREAM_H	g++/iostream.h	29;"	d
_IOS_APPEND	g++/libio.h	101;"	d
_IOS_ATEND	g++/libio.h	100;"	d
_IOS_BAD	g++/streambuf.h	102;"	d
_IOS_BIN	g++/libio.h	105;"	d
_IOS_EOF	g++/streambuf.h	100;"	d
_IOS_FAIL	g++/streambuf.h	101;"	d
_IOS_GOOD	g++/streambuf.h	99;"	d
_IOS_INPUT	g++/libio.h	98;"	d
_IOS_NOCREATE	g++/libio.h	103;"	d
_IOS_NOREPLACE	g++/libio.h	104;"	d
_IOS_OUTPUT	g++/libio.h	99;"	d
_IOS_TRUNC	g++/libio.h	102;"	d
_IO_APPEND	g++/streambuf.h	107;"	d
_IO_ATEND	g++/streambuf.h	106;"	d
_IO_BAD_SEEN	g++/libio.h	130;"	d
_IO_BIN	g++/streambuf.h	111;"	d
_IO_BOOLALPHA	g++/libio.h	149;"	d
_IO_BUFSIZ	g++/libio.h	40;"	d
_IO_CHAR_TYPE	g++/libioP.h	243;"	d
_IO_CURRENTLY_PUTTING	g++/libio.h	127;"	d
_IO_DEC	g++/libio.h	137;"	d
_IO_DELETE_DONT_CLOSE	g++/libio.h	122;"	d
_IO_DOALLOCATE	g++/libioP.h	177;"	d
_IO_DONT_CLOSE	g++/libio.h	148;"	d
_IO_EOF_SEEN	g++/libio.h	120;"	d
_IO_ERR_SEEN	g++/libio.h	121;"	d
_IO_FILE	g++/libio.h	/^struct _IO_FILE {$/;"	s
_IO_FILE	g++/libio.h	/^typedef struct _IO_FILE _IO_FILE;$/;"	t	typeref:struct:_IO_FILE
_IO_FILE_plus	g++/libioP.h	/^struct _IO_FILE_plus$/;"	s
_IO_FINISH	g++/libioP.h	95;"	d
_IO_FIXED	g++/libio.h	145;"	d
_IO_HAVE_ST_BLKSIZE	g++/libio.h	39;"	d
_IO_HAVE_SYS_WAIT	g++/libio.h	38;"	d
_IO_HEX	g++/libio.h	139;"	d
_IO_IMBUE	g++/libioP.h	239;"	d
_IO_INPUT	g++/streambuf.h	104;"	d
_IO_INTERNAL	g++/libio.h	136;"	d
_IO_INT_TYPE	g++/libioP.h	244;"	d
_IO_IN_BACKUP	g++/libio.h	124;"	d
_IO_IS_APPENDING	g++/libio.h	128;"	d
_IO_IS_FILEBUF	g++/libio.h	129;"	d
_IO_JUMPS	g++/libioP.h	71;"	d
_IO_LEFT	g++/libio.h	134;"	d
_IO_LINE_BUF	g++/libio.h	125;"	d
_IO_LINKED	g++/libio.h	123;"	d
_IO_LOCK_T	g++/libio.h	162;"	d
_IO_LOCK_T	g++/libio.h	169;"	d
_IO_LOCK_T	g++/libio.h	173;"	d
_IO_MAGIC	g++/libio.h	113;"	d
_IO_MAGIC_MASK	g++/libio.h	115;"	d
_IO_NEW_STREAMS	g++/streambuf.h	33;"	d
_IO_NOCREATE	g++/streambuf.h	109;"	d
_IO_NOREPLACE	g++/streambuf.h	110;"	d
_IO_NO_READS	g++/libio.h	118;"	d
_IO_NO_WRITES	g++/libio.h	119;"	d
_IO_OCT	g++/libio.h	138;"	d
_IO_OUTPUT	g++/streambuf.h	105;"	d
_IO_OVERFLOW	g++/libioP.h	101;"	d
_IO_PBACKFAIL	g++/libioP.h	120;"	d
_IO_PENDING_OUTPUT_COUNT	g++/libio.h	318;"	d
_IO_RIGHT	g++/libio.h	135;"	d
_IO_SCIENTIFIC	g++/libio.h	144;"	d
_IO_SEEKOFF	g++/libioP.h	148;"	d
_IO_SEEKPOS	g++/libioP.h	160;"	d
_IO_SETBUF	g++/libioP.h	165;"	d
_IO_SHOWBASE	g++/libio.h	140;"	d
_IO_SHOWMANYC	g++/libioP.h	234;"	d
_IO_SHOWPOINT	g++/libio.h	141;"	d
_IO_SHOWPOS	g++/libio.h	143;"	d
_IO_SKIPWS	g++/libio.h	133;"	d
_IO_STDIO	g++/libio.h	147;"	d
_IO_STDIO_H	g++/libio.h	28;"	d
_IO_STR_DYNAMIC	g++/strfile.h	59;"	d
_IO_STR_FROZEN	g++/strfile.h	63;"	d
_IO_SYNC	g++/libioP.h	171;"	d
_IO_SYSCLOSE	g++/libioP.h	220;"	d
_IO_SYSREAD	g++/libioP.h	195;"	d
_IO_SYSSEEK	g++/libioP.h	213;"	d
_IO_SYSSTAT	g++/libioP.h	227;"	d
_IO_SYSWRITE	g++/libioP.h	202;"	d
_IO_TIED_PUT_GET	g++/libio.h	126;"	d
_IO_TRUNC	g++/streambuf.h	108;"	d
_IO_UFLOW	g++/libioP.h	115;"	d
_IO_UNBUFFERED	g++/libio.h	117;"	d
_IO_UNDERFLOW	g++/libioP.h	108;"	d
_IO_UNIFIED_JUMPTABLES	g++/libio.h	77;"	d
_IO_UNITBUF	g++/libio.h	146;"	d
_IO_UPPERCASE	g++/libio.h	142;"	d
_IO_USER_BUF	g++/libio.h	116;"	d
_IO_USE_DTOA	g++/libio.h	79;"	d
_IO_XSGETN	g++/libioP.h	134;"	d
_IO_XSPUTN	g++/libioP.h	127;"	d
_IO_alloc_type	g++/strfile.h	/^typedef void *(*_IO_alloc_type) __P ((_IO_size_t));$/;"	t
_IO_backup_base	g++/libio.h	/^  char *_IO_backup_base;  \/* Pointer to first valid character of backup area *\/$/;"	m	struct:_IO_FILE
_IO_blen	g++/libioP.h	378;"	d
_IO_buf_base	g++/libio.h	/^  char* _IO_buf_base;	\/* Start of reserve area. *\/$/;"	m	struct:_IO_FILE
_IO_buf_end	g++/libio.h	/^  char* _IO_buf_end;	\/* End of reserve area. *\/$/;"	m	struct:_IO_FILE
_IO_cleanup_region_end	g++/libio.h	333;"	d
_IO_cleanup_region_start	g++/libio.h	332;"	d
_IO_clearerr	g++/iolibio.h	43;"	d
_IO_close_t	g++/libioP.h	/^typedef int (*_IO_close_t) __P ((_IO_FILE *)); \/* finalize *\/$/;"	t
_IO_cookie_file	g++/libio.h	/^struct _IO_cookie_file$/;"	s
_IO_cookie_io_functions_t	g++/libio.h	/^} _IO_cookie_io_functions_t;$/;"	t	typeref:struct:__anon3
_IO_cookie_io_functions_t	g++/libio.h	/^} _IO_cookie_io_functions_t;$/;"	t	typeref:struct:__anon74
_IO_default_close	g++/libioP.h	354;"	d
_IO_do_flush	g++/libioP.h	365;"	d
_IO_doallocate_t	g++/libioP.h	/^typedef int (*_IO_doallocate_t) __P ((_IO_FILE *));$/;"	t
_IO_feof_unlocked	g++/libio.h	307;"	d
_IO_ferror_unlocked	g++/libio.h	308;"	d
_IO_file_flags	g++/libio.h	204;"	d
_IO_file_is_open	g++/libioP.h	396;"	d
_IO_fileno	g++/iolibio.h	55;"	d
_IO_finish_t	g++/libioP.h	/^typedef void (*_IO_finish_t) __P ((_IO_FILE *, int)); \/* finalize *\/$/;"	t
_IO_flockfile	g++/libio.h	329;"	d
_IO_fpos64_t	g++/libio.h	43;"	d
_IO_fpos_t	g++/libio.h	32;"	d
_IO_free_type	g++/strfile.h	/^typedef void (*_IO_free_type) __P ((void*));$/;"	t
_IO_freopen	g++/iolibio.h	49;"	d
_IO_freopen	g++/iolibio.h	52;"	d
_IO_fseek	g++/iolibio.h	44;"	d
_IO_ftrylockfile	g++/libio.h	331;"	d
_IO_funlockfile	g++/libio.h	330;"	d
_IO_getc_unlocked	g++/libio.h	294;"	d
_IO_have_backup	g++/libioP.h	375;"	d
_IO_have_markers	g++/libioP.h	377;"	d
_IO_imbue_t	g++/libioP.h	/^typedef void (*_IO_imbue_t) __P ((_IO_FILE *, void *));$/;"	t
_IO_in_backup	g++/libioP.h	376;"	d
_IO_in_put_mode	g++/libioP.h	368;"	d
_IO_istream_withassign	g++/iostream.h	/^class _IO_istream_withassign : public istream {$/;"	c
_IO_jump_t	g++/libioP.h	/^struct _IO_jump_t$/;"	s
_IO_lock_t	g++/libio.h	/^    struct _IO_lock_t { void *ptr; short int field1; short int field2; };$/;"	s
_IO_lock_t	g++/libio.h	/^    typedef void _IO_lock_t;$/;"	t
_IO_lock_t	g++/libio.h	/^   typedef void _IO_lock_t;$/;"	t
_IO_marker	g++/libio.h	/^struct _IO_marker {$/;"	s
_IO_mask_flags	g++/libioP.h	369;"	d
_IO_off64_t	g++/libio.h	44;"	d
_IO_off_t	g++/libio.h	35;"	d
_IO_ostream_withassign	g++/iostream.h	/^class _IO_ostream_withassign : public ostream {$/;"	c
_IO_overflow_t	g++/libioP.h	/^typedef int (*_IO_overflow_t) __P ((_IO_FILE *, int));$/;"	t
_IO_pbackfail_t	g++/libioP.h	/^typedef int (*_IO_pbackfail_t) __P ((_IO_FILE *, int));$/;"	t
_IO_pclose	g++/iolibio.h	57;"	d
_IO_peekc	g++/libio.h	326;"	d
_IO_peekc	g++/libio.h	328;"	d
_IO_peekc_unlocked	g++/libio.h	297;"	d
_IO_pid_t	g++/libio.h	36;"	d
_IO_pos_0	g++/libioP.h	563;"	d
_IO_pos_0	g++/libioP.h	565;"	d
_IO_pos_BAD	g++/iolibio.h	41;"	d
_IO_pos_BAD	g++/libioP.h	543;"	d
_IO_pos_BAD	g++/libioP.h	545;"	d
_IO_pos_adjust	g++/libioP.h	558;"	d
_IO_pos_as_off	g++/libioP.h	551;"	d
_IO_pos_as_off	g++/libioP.h	553;"	d
_IO_pos_t	g++/libio.h	31;"	d
_IO_putc_unlocked	g++/libio.h	302;"	d
_IO_read_base	g++/libio.h	/^  char* _IO_read_base;	\/* Start of putback+get area. *\/$/;"	m	struct:_IO_FILE
_IO_read_end	g++/libio.h	/^  char* _IO_read_end;	\/* End of get area. *\/$/;"	m	struct:_IO_FILE
_IO_read_ptr	g++/libio.h	/^  char* _IO_read_ptr;	\/* Current read pointer *\/$/;"	m	struct:_IO_FILE
_IO_read_t	g++/libioP.h	/^typedef _IO_ssize_t (*_IO_read_t) __P ((_IO_FILE *, void *, _IO_ssize_t));$/;"	t
_IO_rewind	g++/iolibio.h	46;"	d
_IO_save_base	g++/libio.h	/^  char *_IO_save_base; \/* Pointer to start of non-current get area. *\/$/;"	m	struct:_IO_FILE
_IO_save_end	g++/libio.h	/^  char *_IO_save_end; \/* Pointer to end of non-current get area. *\/$/;"	m	struct:_IO_FILE
_IO_seek_cur	g++/libioP.h	47;"	d
_IO_seek_end	g++/libioP.h	48;"	d
_IO_seek_set	g++/libioP.h	46;"	d
_IO_seek_t	g++/libioP.h	/^typedef _IO_fpos64_t (*_IO_seek_t) __P ((_IO_FILE *, _IO_off64_t, int));$/;"	t
_IO_seek_t	g++/libioP.h	/^typedef _IO_fpos_t (*_IO_seek_t) __P ((_IO_FILE *, _IO_off_t, int));$/;"	t
_IO_seekoff_t	g++/libioP.h	/^typedef _IO_fpos64_t (*_IO_seekoff_t) __P ((_IO_FILE *FP, _IO_off64_t OFF,$/;"	t
_IO_seekoff_t	g++/libioP.h	/^typedef _IO_fpos_t (*_IO_seekoff_t) __P ((_IO_FILE *FP, _IO_off_t OFF,$/;"	t
_IO_seekpos_t	g++/libioP.h	/^typedef _IO_fpos64_t (*_IO_seekpos_t) __P ((_IO_FILE *, _IO_fpos64_t, int));$/;"	t
_IO_seekpos_t	g++/libioP.h	/^typedef _IO_fpos_t (*_IO_seekpos_t) __P ((_IO_FILE *, _IO_fpos_t, int));$/;"	t
_IO_setbuf	g++/iolibio.h	58;"	d
_IO_setbuf_t	g++/libioP.h	/^typedef _IO_FILE* (*_IO_setbuf_t) __P ((_IO_FILE *, char *, _IO_ssize_t));$/;"	t
_IO_setg	g++/libioP.h	371;"	d
_IO_setlinebuf	g++/iolibio.h	59;"	d
_IO_setp	g++/libioP.h	373;"	d
_IO_showmanyc_t	g++/libioP.h	/^typedef int (*_IO_showmanyc_t) __P ((_IO_FILE *));$/;"	t
_IO_size_t	g++/libio.h	33;"	d
_IO_sputn	g++/libioP.h	313;"	d
_IO_ssize_t	g++/libio.h	34;"	d
_IO_stat_t	g++/libioP.h	/^typedef int (*_IO_stat_t) __P ((_IO_FILE *, void *));$/;"	t
_IO_stderr	g++/libio.h	264;"	d
_IO_stderr_	g++/libio.h	257;"	d
_IO_stdin	g++/libio.h	262;"	d
_IO_stdin_	g++/libio.h	255;"	d
_IO_stdout	g++/libio.h	263;"	d
_IO_stdout_	g++/libio.h	256;"	d
_IO_str_fields	g++/strfile.h	/^struct _IO_str_fields$/;"	s
_IO_streambuf	g++/strfile.h	/^struct _IO_streambuf$/;"	s
_IO_strfile	g++/strfile.h	/^} _IO_strfile;$/;"	t	typeref:struct:_IO_strfile_
_IO_strfile_	g++/strfile.h	/^typedef struct _IO_strfile_$/;"	s
_IO_sync_t	g++/libioP.h	/^typedef int (*_IO_sync_t) __P ((_IO_FILE *));$/;"	t
_IO_uid_t	g++/libio.h	37;"	d
_IO_underflow_t	g++/libioP.h	/^typedef int (*_IO_underflow_t) __P ((_IO_FILE *));$/;"	t
_IO_va_list	g++/libio.h	41;"	d
_IO_va_list	g++/libio.h	52;"	d
_IO_va_list	g++/libio.h	53;"	d
_IO_va_list	g++/streambuf.h	43;"	d
_IO_va_start	g++/libioP.h	611;"	d
_IO_vprintf	g++/iolibio.h	47;"	d
_IO_wchar_t	g++/streambuf.h	59;"	d
_IO_wchar_t	g++/streambuf.h	61;"	d
_IO_write_base	g++/libio.h	/^  char* _IO_write_base;	\/* Start of put area. *\/$/;"	m	struct:_IO_FILE
_IO_write_end	g++/libio.h	/^  char* _IO_write_end;	\/* End of put area. *\/$/;"	m	struct:_IO_FILE
_IO_write_ptr	g++/libio.h	/^  char* _IO_write_ptr;	\/* Current put pointer. *\/$/;"	m	struct:_IO_FILE
_IO_write_t	g++/libioP.h	/^typedef _IO_ssize_t (*_IO_write_t) __P ((_IO_FILE *,const void *,_IO_ssize_t));$/;"	t
_IO_xsgetn_t	g++/libioP.h	/^typedef _IO_size_t (*_IO_xsgetn_t) __P ((_IO_FILE *FP, void *DATA,$/;"	t
_IO_xsputn_t	g++/libioP.h	/^typedef _IO_size_t (*_IO_xsputn_t) __P ((_IO_FILE *FP, const void *DATA,$/;"	t
_KEYMAPS_H_	readline/keymaps.h	24;"	d
_LIMITS_H___	include/limits.h	17;"	d
_MACH_MACHLIMITS_H_	include/limits.h	18;"	d
_NIST_DBG	Dbg.h	13;"	d
_OLD_STDIO_MAGIC	g++/libio.h	114;"	d
_PARAMS	g++/libio.h	71;"	d
_PFSTREAM_H	g++/pfstream.h	28;"	d
_PROCBUF_H	g++/procbuf.h	28;"	d
_PROTO	include/proto.h	4;"	d
_PTRDIFF_T	include/stddef.h	107;"	d
_PTRDIFF_T	include/stddef.h	39;"	d
_PTRDIFF_T_	include/stddef.h	111;"	d
_PTRDIFF_T_	include/stddef.h	293;"	d
_PTRDIFF_T_	include/stddef.h	306;"	d
_PTRDIFF_T_	include/stddef.h	50;"	d
_PTRDIFF_T_	include/stddef.h	66;"	d
_PlotFile_h	g++/PlotFile.h	38;"	d
_READLINE_H_	readline/readline.h	24;"	d
_REGEXP	tclRegexp.h	11;"	d
_SFile_h	g++/SFile.h	30;"	d
_SIZET_	include/stddef.h	164;"	d
_SIZE_T	include/stddef.h	153;"	d
_SIZE_T	include/stddef.h	36;"	d
_SIZE_T_	include/stddef.h	158;"	d
_SIZE_T_	include/stddef.h	297;"	d
_SIZE_T_	include/stddef.h	310;"	d
_SIZE_T_	include/stddef.h	54;"	d
_SIZE_T_DEFINED	include/stddef.h	161;"	d
_SIZE_T_DEFINED_	include/stddef.h	160;"	d
_STDARG_H	include/stdarg.h	9;"	d
_STDDEF_H	include/stddef.h	13;"	d
_STDDEF_H_	include/stddef.h	14;"	d
_STDIOSTREAM_H	g++/stdiostream.h	28;"	d
_STREAMBUF_H	g++/streambuf.h	26;"	d
_STREAM_COMPAT	g++/stream.h	32;"	d
_SYS_INT_STDARG_H	include/va-clipper.h	23;"	d
_SYS_SIZE_T_H	include/stddef.h	154;"	d
_SYS_VA_LIST_H	include/va-ppc.h	11;"	d
_TCL	expect_comm.h	102;"	d
_TCL	expect_comm.h	91;"	d
_TCL	tcl.h	18;"	d
_TIX_H_	tix.h	17;"	d
_TK	tk.h	18;"	d
_TYPE_ptrdiff_t	include/stddef.h	77;"	d
_TYPE_size_t	include/stddef.h	81;"	d
_TYPE_wchar_t	include/stddef.h	85;"	d
_T_PTRDIFF	include/stddef.h	109;"	d
_T_PTRDIFF_	include/stddef.h	108;"	d
_T_SIZE	include/stddef.h	156;"	d
_T_SIZE_	include/stddef.h	155;"	d
_T_WCHAR	include/stddef.h	217;"	d
_T_WCHAR_	include/stddef.h	216;"	d
_Tix_CmdInfo	tix.h	/^typedef struct _Tix_CmdInfo {$/;"	s
_Tix_SubCmdInfo	tix.h	/^typedef struct _Tix_SubCmdInfo {$/;"	s
_USING_PROTOTYPES_	expect_comm.h	68;"	d
_USING_PROTOTYPES_	tcl.h	144;"	d
_VARARGS_H	include/varargs.h	4;"	d
_VA_LIST	include/stdarg.h	144;"	d
_VA_LIST	include/stdarg.h	160;"	d
_VA_LIST	include/stdarg.h	189;"	d
_VA_LIST	include/va-alpha.h	33;"	d
_VA_LIST	include/va-clipper.h	21;"	d
_VA_LIST	include/va-m88k.h	58;"	d
_VA_LIST	include/varargs.h	158;"	d
_VA_LIST	include/varargs.h	170;"	d
_VA_LIST	include/varargs.h	203;"	d
_VA_LIST_	include/stdarg.h	157;"	d
_VA_LIST_	include/stdarg.h	186;"	d
_VA_LIST_	include/va-alpha.h	34;"	d
_VA_LIST_	include/va-clipper.h	22;"	d
_VA_LIST_	include/va-m88k.h	59;"	d
_VA_LIST_	include/varargs.h	167;"	d
_VA_LIST_	include/varargs.h	200;"	d
_VA_LIST_	include/varargs.h	66;"	d
_VA_LIST_DEFINED	include/stdarg.h	192;"	d
_VA_LIST_DEFINED	include/varargs.h	206;"	d
_VA_LIST_T_H	include/stdarg.h	195;"	d
_VA_LIST_T_H	include/varargs.h	209;"	d
_VA_MIPS_H_ENUM	include/va-mips.h	39;"	d
_WCHAR_T	include/stddef.h	215;"	d
_WCHAR_T	include/stddef.h	45;"	d
_WCHAR_T_	include/stddef.h	219;"	d
_WCHAR_T_	include/stddef.h	301;"	d
_WCHAR_T_	include/stddef.h	314;"	d
_WCHAR_T_	include/stddef.h	58;"	d
_WCHAR_T_DEFINED	include/stddef.h	222;"	d
_WCHAR_T_DEFINED_	include/stddef.h	221;"	d
_WCHAR_T_H	include/stddef.h	223;"	d
_WINDOWS	tix.h	39;"	d
_WINT_T	include/stddef.h	275;"	d
__ALIGN	g++/stl_alloc.h	/^    enum {__ALIGN = 8};                          \/\/$/;"	e	enum:__default_alloc_template::__anon5
__ALIGN	g++/stl_alloc.h	/^    enum {__ALIGN = 8};                          \/\/$/;"	e	enum:__default_alloc_template::__anon76
__ALLOC	g++/stl_alloc.h	17;"	d
__ALLOC_PAUSE	g++/stl_alloc.h	488;"	d
__BASTRING__	g++/std/bastring.h	29;"	d
__BFD_H_SEEN__	bfd.h	46;"	d
__BVECTOR	g++/stl_bvector.h	/^  __BVECTOR() : start(iterator()), finish(iterator()), end_of_storage(0) {}$/;"	f	class:vector
__BVECTOR	g++/stl_bvector.h	/^  __BVECTOR(InputIterator first, InputIterator last) {$/;"	f	class:vector
__BVECTOR	g++/stl_bvector.h	/^  __BVECTOR(const __BVECTOR& x) {$/;"	f	class:vector
__BVECTOR	g++/stl_bvector.h	/^  __BVECTOR(const bool* first, const bool* last) {$/;"	f	class:vector
__BVECTOR	g++/stl_bvector.h	/^  __BVECTOR(const_iterator first, const_iterator last) {$/;"	f	class:vector
__BVECTOR	g++/stl_bvector.h	/^  __BVECTOR(int n, bool value) {$/;"	f	class:vector
__BVECTOR	g++/stl_bvector.h	/^  __BVECTOR(long n, bool value) {$/;"	f	class:vector
__BVECTOR	g++/stl_bvector.h	/^  __BVECTOR(size_type n, bool value) {$/;"	f	class:vector
__BVECTOR	g++/stl_bvector.h	/^  explicit __BVECTOR(size_type n) {$/;"	f	class:vector
__BVECTOR	g++/stl_bvector.h	247;"	d
__BVECTOR	g++/stl_bvector.h	250;"	d
__BVECTOR	g++/stl_bvector.h	604;"	d
__COMPLEXT__	g++/std/complext.h	28;"	d
__DCOMPLEX__	g++/std/dcomplex.h	29;"	d
__DEFINE_IOMANIP_FN1	g++/iomanip.h	162;"	d
__FCOMPLEX__	g++/std/fcomplex.h	29;"	d
__FLEX_LEXER_H	FlexLexer.h	45;"	d
__FUNCTION_DEF	readline/keymaps.h	31;"	d
__GC_CONST	g++/stl_rope.h	22;"	d
__GC_CONST	g++/stl_rope.h	24;"	d
__GNUC_VA_LIST	include/stdarg.h	66;"	d
__GNUC_VA_LIST	include/va-alpha.h	11;"	d
__GNUC_VA_LIST	include/va-arc.h	6;"	d
__GNUC_VA_LIST	include/va-clipper.h	6;"	d
__GNUC_VA_LIST	include/va-h8300.h	6;"	d
__GNUC_VA_LIST	include/va-i860.h	10;"	d
__GNUC_VA_LIST	include/va-i960.h	6;"	d
__GNUC_VA_LIST	include/va-m32r.h	5;"	d
__GNUC_VA_LIST	include/va-m88k.h	6;"	d
__GNUC_VA_LIST	include/va-mips.h	15;"	d
__GNUC_VA_LIST	include/va-mn10200.h	5;"	d
__GNUC_VA_LIST	include/va-mn10300.h	4;"	d
__GNUC_VA_LIST	include/va-pa.h	5;"	d
__GNUC_VA_LIST	include/va-ppc.h	185;"	d
__GNUC_VA_LIST	include/va-ppc.h	8;"	d
__GNUC_VA_LIST	include/va-pyr.h	50;"	d
__GNUC_VA_LIST	include/va-sh.h	7;"	d
__GNUC_VA_LIST	include/va-sparc.h	7;"	d
__GNUC_VA_LIST	include/va-v850.h	4;"	d
__GNUC_VA_LIST	include/varargs.h	98;"	d
__HAVE_COLUMN	g++/libio.h	233;"	d
__INT_MAX__	include/limits.h	65;"	d
__INT_VARARGS_H	include/va-m88k.h	62;"	d
__INT_WCHAR_T_H	include/stddef.h	225;"	d
__LDCOMPLEX__	g++/std/ldcomplex.h	29;"	d
__LITTLE_ENDIAN_P	include/va-sh.h	117;"	d
__LITTLE_ENDIAN_P	include/va-sh.h	119;"	d
__LONG_LONG_MAX__	include/limits.h	97;"	d
__LONG_MAX__	include/limits.h	80;"	d
__LONG_MAX__	include/limits.h	82;"	d
__MAX_BYTES	g++/stl_alloc.h	/^    enum {__MAX_BYTES = 128};                    \/\/$/;"	e	enum:__default_alloc_template::__anon6
__MAX_BYTES	g++/stl_alloc.h	/^    enum {__MAX_BYTES = 128};                    \/\/$/;"	e	enum:__default_alloc_template::__anon77
__NEW_H__	include/new.h	4;"	d
__NFREELISTS	g++/stl_alloc.h	/^    enum {__NFREELISTS = __MAX_BYTES\/__ALIGN};   \/\/free-lists$/;"	e	enum:__default_alloc_template::__anon7
__NFREELISTS	g++/stl_alloc.h	/^    enum {__NFREELISTS = __MAX_BYTES\/__ALIGN};   \/\/free-lists$/;"	e	enum:__default_alloc_template::__anon78
__NUM_PARM_FREGS	include/va-i860.h	98;"	d
__NUM_PARM_IREGS	include/va-i860.h	99;"	d
__P	g++/libio.h	62;"	d
__P	g++/libio.h	64;"	d
__PASS_AS_FLOAT	include/va-sh.h	159;"	d
__PRIVATE	g++/stl_alloc.h	573;"	d
__PTRDIFF_T	include/stddef.h	110;"	d
__PTRDIFF_TYPE__	include/stddef.h	116;"	d
__SCALAR_TYPE	include/va-sh.h	122;"	d
__SGI_STL_ALGOBASE_H	g++/algobase.h	27;"	d
__SGI_STL_ALGO_H	g++/algo.h	28;"	d
__SGI_STL_ALLOC_H	g++/alloc.h	15;"	d
__SGI_STL_BVECTOR_H	g++/bvector.h	28;"	d
__SGI_STL_DEQUE_H	g++/deque.h	28;"	d
__SGI_STL_FUNCTION_H	g++/function.h	28;"	d
__SGI_STL_HASHTABLE_H	g++/hashtable.h	32;"	d
__SGI_STL_HASH_FUN_H	g++/stl_hash_fun.h	32;"	d
__SGI_STL_HASH_MAP_H	g++/hash_map.h	28;"	d
__SGI_STL_HASH_SET_H	g++/hash_set.h	28;"	d
__SGI_STL_HEAP_H	g++/heap.h	27;"	d
__SGI_STL_INTERNAL_ALGOBASE_H	g++/stl_algobase.h	2;"	d
__SGI_STL_INTERNAL_ALGO_H	g++/stl_algo.h	32;"	d
__SGI_STL_INTERNAL_ALLOC_H	g++/stl_alloc.h	2;"	d
__SGI_STL_INTERNAL_BVECTOR_H	g++/stl_bvector.h	32;"	d
__SGI_STL_INTERNAL_CONSTRUCT_H	g++/stl_construct.h	2;"	d
__SGI_STL_INTERNAL_DEQUE_H	g++/stl_deque.h	2;"	d
__SGI_STL_INTERNAL_FUNCTION_H	g++/stl_function.h	32;"	d
__SGI_STL_INTERNAL_HASHTABLE_H	g++/stl_hashtable.h	32;"	d
__SGI_STL_INTERNAL_HASH_MAP_H	g++/stl_hash_map.h	32;"	d
__SGI_STL_INTERNAL_HASH_SET_H	g++/stl_hash_set.h	32;"	d
__SGI_STL_INTERNAL_HEAP_H	g++/stl_heap.h	2;"	d
__SGI_STL_INTERNAL_ITERATOR_H	g++/stl_iterator.h	32;"	d
__SGI_STL_INTERNAL_LIST_H	g++/stl_list.h	4;"	d
__SGI_STL_INTERNAL_MAP_H	g++/stl_map.h	32;"	d
__SGI_STL_INTERNAL_MULTIMAP_H	g++/stl_multimap.h	32;"	d
__SGI_STL_INTERNAL_MULTISET_H	g++/stl_multiset.h	32;"	d
__SGI_STL_INTERNAL_NUMERIC_H	g++/stl_numeric.h	33;"	d
__SGI_STL_INTERNAL_PAIR_H	g++/stl_pair.h	32;"	d
__SGI_STL_INTERNAL_QUEUE_H	g++/stl_queue.h	2;"	d
__SGI_STL_INTERNAL_RAW_STORAGE_ITERATOR_H	g++/stl_raw_storage_iter.h	32;"	d
__SGI_STL_INTERNAL_RELOPS	g++/stl_relops.h	32;"	d
__SGI_STL_INTERNAL_ROPE_H	g++/stl_rope.h	19;"	d
__SGI_STL_INTERNAL_SET_H	g++/stl_set.h	32;"	d
__SGI_STL_INTERNAL_SLIST_H	g++/stl_slist.h	2;"	d
__SGI_STL_INTERNAL_STACK_H	g++/stl_stack.h	2;"	d
__SGI_STL_INTERNAL_TEMPBUF_H	g++/stl_tempbuf.h	32;"	d
__SGI_STL_INTERNAL_TREE_H	g++/stl_tree.h	2;"	d
__SGI_STL_INTERNAL_UNINITIALIZED_H	g++/stl_uninitialized.h	6;"	d
__SGI_STL_INTERNAL_VECTOR_H	g++/stl_vector.h	2;"	d
__SGI_STL_ITERATOR_H	g++/iterator.h	28;"	d
__SGI_STL_LIST_H	g++/list.h	28;"	d
__SGI_STL_MAP_H	g++/map.h	28;"	d
__SGI_STL_MULTIMAP_H	g++/multimap.h	28;"	d
__SGI_STL_MULTISET_H	g++/multiset.h	28;"	d
__SGI_STL_NO_ARROW_OPERATOR	g++/stl_config.h	144;"	d
__SGI_STL_NO_ARROW_OPERATOR	g++/stl_config.h	163;"	d
__SGI_STL_PAIR_H	g++/pair.h	28;"	d
__SGI_STL_PTHREAD_ALLOC_H	g++/pthread_alloc.h	15;"	d
__SGI_STL_ROPE_H	g++/rope.h	15;"	d
__SGI_STL_SET_H	g++/set.h	28;"	d
__SGI_STL_SLIST_H	g++/slist.h	16;"	d
__SGI_STL_STACK_H	g++/stack.h	28;"	d
__SGI_STL_TEMPBUF_H	g++/tempbuf.h	28;"	d
__SGI_STL_TREE_H	g++/tree.h	30;"	d
__SGI_STL_VECBOOL_TEMPLATE	g++/stl_bvector.h	246;"	d
__SGI_STL_VECBOOL_TEMPLATE	g++/stl_bvector.h	249;"	d
__SGI_STL_VECBOOL_TEMPLATE	g++/stl_bvector.h	603;"	d
__SGI_STL_VECTOR_H	g++/vector.h	28;"	d
__SIZE_T	include/stddef.h	157;"	d
__SIZE_TYPE__	include/stddef.h	167;"	d
__STD	g++/stl_config.h	209;"	d
__STD	g++/stl_config.h	219;"	d
__STDBOOL_H__	include/stdbool.h	3;"	d
__STDDEF_H__	include/stddef.h	18;"	d
__STD_RELOPS	g++/stl_config.h	217;"	d
__STD_RELOPS	g++/stl_config.h	231;"	d
__STL_BEGIN_NAMESPACE	g++/stl_config.h	211;"	d
__STL_BEGIN_NAMESPACE	g++/stl_config.h	221;"	d
__STL_BEGIN_RELOPS_NAMESPACE	g++/stl_config.h	214;"	d
__STL_BEGIN_RELOPS_NAMESPACE	g++/stl_config.h	227;"	d
__STL_CATCH_ALL	g++/stl_config.h	236;"	d
__STL_CATCH_ALL	g++/stl_config.h	242;"	d
__STL_CLASS_PARTIAL_SPECIALIZATION	g++/stl_config.h	122;"	d
__STL_CLASS_PARTIAL_SPECIALIZATION	g++/stl_config.h	64;"	d
__STL_CLASS_PARTIAL_SPECIALIZATION	g++/stl_config.h	96;"	d
__STL_CONFIG_H	g++/stl_config.h	3;"	d
__STL_END_NAMESPACE	g++/stl_config.h	212;"	d
__STL_END_NAMESPACE	g++/stl_config.h	223;"	d
__STL_END_RELOPS_NAMESPACE	g++/stl_config.h	215;"	d
__STL_END_RELOPS_NAMESPACE	g++/stl_config.h	229;"	d
__STL_EXPLICIT_FUNCTION_TMPL_ARGS	g++/stl_config.h	98;"	d
__STL_FUNCTION_TMPL_PARTIAL_ORDER	g++/stl_config.h	97;"	d
__STL_LIMITED_DEFAULT_TEMPLATES	g++/stl_config.h	161;"	d
__STL_MEMBER_TEMPLATES	g++/stl_config.h	121;"	d
__STL_MEMBER_TEMPLATES	g++/stl_config.h	68;"	d
__STL_MEMBER_TEMPLATES	g++/stl_config.h	99;"	d
__STL_NEED_BOOL	g++/stl_config.h	114;"	d
__STL_NEED_BOOL	g++/stl_config.h	131;"	d
__STL_NEED_BOOL	g++/stl_config.h	56;"	d
__STL_NEED_EXPLICIT	g++/stl_config.h	116;"	d
__STL_NEED_EXPLICIT	g++/stl_config.h	139;"	d
__STL_NEED_EXPLICIT	g++/stl_config.h	72;"	d
__STL_NEED_EXPLICIT	g++/stl_config.h	94;"	d
__STL_NEED_TYPENAME	g++/stl_config.h	115;"	d
__STL_NEED_TYPENAME	g++/stl_config.h	136;"	d
__STL_NEED_TYPENAME	g++/stl_config.h	159;"	d
__STL_NEED_TYPENAME	g++/stl_config.h	60;"	d
__STL_NEED_TYPENAME	g++/stl_config.h	93;"	d
__STL_NON_TYPE_TMPL_PARAM_BUG	g++/stl_config.h	142;"	d
__STL_NON_TYPE_TMPL_PARAM_BUG	g++/stl_config.h	165;"	d
__STL_NOTHROW	g++/stl_config.h	238;"	d
__STL_NOTHROW	g++/stl_config.h	244;"	d
__STL_NO_DRAND48	g++/stl_config.h	134;"	d
__STL_NO_DRAND48	g++/stl_config.h	157;"	d
__STL_NULL_TMPL_ARGS	g++/stl_config.h	195;"	d
__STL_NULL_TMPL_ARGS	g++/stl_config.h	197;"	d
__STL_PTHREADS	g++/stl_config.h	104;"	d
__STL_PTHREADS	g++/stl_config.h	50;"	d
__STL_RETHROW	g++/stl_config.h	237;"	d
__STL_RETHROW	g++/stl_config.h	243;"	d
__STL_SGI_THREADS	g++/stl_config.h	84;"	d
__STL_STATIC_TEMPLATE_MEMBER_BUG	g++/stl_config.h	92;"	d
__STL_TEMPLATE_NULL	g++/stl_config.h	201;"	d
__STL_TEMPLATE_NULL	g++/stl_config.h	203;"	d
__STL_TRY	g++/stl_config.h	235;"	d
__STL_TRY	g++/stl_config.h	241;"	d
__STL_UNWIND	g++/stl_config.h	239;"	d
__STL_UNWIND	g++/stl_config.h	245;"	d
__STL_USE_EXCEPTIONS	g++/stl_config.h	108;"	d
__STL_USE_EXCEPTIONS	g++/stl_config.h	117;"	d
__STL_USE_EXCEPTIONS	g++/stl_config.h	123;"	d
__STL_USE_EXCEPTIONS	g++/stl_config.h	147;"	d
__STL_USE_EXCEPTIONS	g++/stl_config.h	168;"	d
__STL_USE_EXCEPTIONS	g++/stl_config.h	76;"	d
__STL_USE_NAMESPACES	g++/stl_config.h	124;"	d
__STL_USE_NAMESPACES	g++/stl_config.h	80;"	d
__STL_USE_NAMESPACE_FOR_RELOPS	g++/stl_config.h	213;"	d
__STL_USE_NAMESPACE_FOR_RELOPS	g++/stl_config.h	225;"	d
__STL_WIN32THREADS	g++/stl_config.h	151;"	d
__STL_WIN32THREADS	g++/stl_config.h	172;"	d
__STRING_CHAR_TRAITS__	g++/std/straits.h	29;"	d
__STRSTREAM_H	g++/strstream.h	28;"	d
__THROW_BAD_ALLOC	g++/stl_alloc.h	13;"	d
__TYPEDEF_WORKAROUND	g++/stl_rope.h	97;"	d
__TYPE_TRAITS_H	g++/type_traits.h	2;"	d
__VA_FP_REGSAVE	include/va-ppc.h	54;"	d
__VA_GP_REGSAVE	include/va-ppc.h	58;"	d
__VA_LIST	include/stdarg.h	165;"	d
__VA_LIST	include/varargs.h	175;"	d
__VA_PPC_H__	include/va-ppc.h	45;"	d
__WCHAR_T	include/stddef.h	218;"	d
__WCHAR_TYPE__	include/stddef.h	249;"	d
__WCHAR_TYPE__	include/stddef.h	251;"	d
__WIN32__	tcl.h	53;"	d
__WINT_TYPE__	include/stddef.h	278;"	d
__WORD_BIT	g++/stl_bvector.h	/^static const int __WORD_BIT = int(CHAR_BIT*sizeof(unsigned int));$/;"	v
___int_ptrdiff_t_h	include/stddef.h	113;"	d
___int_size_t_h	include/stddef.h	162;"	d
___int_wchar_t_h	include/stddef.h	224;"	d
__add_and_fetch	g++/stl_rope.h	288;"	d
__adjacent_difference	g++/stl_numeric.h	/^OutputIterator __adjacent_difference(InputIterator first, InputIterator last, $/;"	f
__adjust_heap	g++/stl_heap.h	/^void __adjust_heap(RandomAccessIterator first, Distance holeIndex, Distance len, T value) $/;"	f
__adjust_heap	g++/stl_heap.h	/^void __adjust_heap(RandomAccessIterator first, Distance holeIndex, Distance len, T value, Compare comp) $/;"	f
__advance	g++/stl_iterator.h	/^inline void __advance(BidirectionalIterator& i, Distance n, bidirectional_iterator_tag) {$/;"	f
__advance	g++/stl_iterator.h	/^inline void __advance(InputIterator& i, Distance n, input_iterator_tag) {$/;"	f
__advance	g++/stl_iterator.h	/^inline void __advance(RandomAccessIterator& i, Distance n, random_access_iterator_tag) {$/;"	f
__array_type_class	include/va-alpha.h	/^  __array_type_class,$/;"	e	enum:__anon23
__array_type_class	include/va-alpha.h	/^  __array_type_class,$/;"	e	enum:__anon48
__array_type_class	include/va-arc.h	/^  __array_type_class,$/;"	e	enum:__va_type_classes
__array_type_class	include/va-i860.h	/^  __array_type_class,$/;"	e	enum:__anon27
__array_type_class	include/va-i860.h	/^  __array_type_class,$/;"	e	enum:__anon52
__array_type_class	include/va-m32r.h	/^  __array_type_class,$/;"	e	enum:__type_class
__array_type_class	include/va-mips.h	/^  __array_type_class,$/;"	e	enum:__anon17
__array_type_class	include/va-mips.h	/^  __array_type_class,$/;"	e	enum:__anon42
__array_type_class	include/va-sh.h	/^  __array_type_class,$/;"	e	enum:__va_type_classes
__array_type_class	include/va-sparc.h	/^  __array_type_class,$/;"	e	enum:__va_type_classes
__attribute__	g++/std/complext.h	37;"	d
__base	include/va-alpha.h	/^  char *__base;			\/* Pointer to first integer register. *\/$/;"	m	struct:__anon22
__base	include/va-alpha.h	/^  char *__base;			\/* Pointer to first integer register. *\/$/;"	m	struct:__anon47
__bit_const_iterator	g++/stl_bvector.h	/^  __bit_const_iterator() : p(0), offset(0) {}$/;"	f	struct:__bit_const_iterator
__bit_const_iterator	g++/stl_bvector.h	/^  __bit_const_iterator(const __bit_iterator& x) : p(x.p), offset(x.offset) {}$/;"	f	struct:__bit_const_iterator
__bit_const_iterator	g++/stl_bvector.h	/^  __bit_const_iterator(unsigned int* x, unsigned int y) : p(x), offset(y) {}$/;"	f	struct:__bit_const_iterator
__bit_const_iterator	g++/stl_bvector.h	/^struct __bit_const_iterator$/;"	s
__bit_iterator	g++/stl_bvector.h	/^  __bit_iterator() : p(0), offset(0) {}$/;"	f	struct:__bit_iterator
__bit_iterator	g++/stl_bvector.h	/^  __bit_iterator(unsigned int* x, unsigned int y) : p(x), offset(y) {}$/;"	f	struct:__bit_iterator
__bit_iterator	g++/stl_bvector.h	/^struct __bit_iterator : public random_access_iterator<bool, ptrdiff_t> {$/;"	s
__bit_reference	g++/stl_bvector.h	/^  __bit_reference() : p(0), mask(0) {}$/;"	f	struct:__bit_reference
__bit_reference	g++/stl_bvector.h	/^  __bit_reference(unsigned int* x, unsigned int y) : p(x), mask(y) {}$/;"	f	struct:__bit_reference
__bit_reference	g++/stl_bvector.h	/^struct __bit_reference {$/;"	s
__black_count	g++/stl_tree.h	/^inline int __black_count(__rb_tree_node_base* node, __rb_tree_node_base* root)$/;"	f
__bool_true_false_are_defined	include/stdbool.h	18;"	d
__boolean_type_class	include/va-alpha.h	/^  __boolean_type_class,$/;"	e	enum:__anon23
__boolean_type_class	include/va-alpha.h	/^  __boolean_type_class,$/;"	e	enum:__anon48
__boolean_type_class	include/va-arc.h	/^  __boolean_type_class,$/;"	e	enum:__va_type_classes
__boolean_type_class	include/va-i860.h	/^  __boolean_type_class,$/;"	e	enum:__anon27
__boolean_type_class	include/va-i860.h	/^  __boolean_type_class,$/;"	e	enum:__anon52
__boolean_type_class	include/va-m32r.h	/^  __boolean_type_class,$/;"	e	enum:__type_class
__boolean_type_class	include/va-mips.h	/^  __boolean_type_class,$/;"	e	enum:__anon17
__boolean_type_class	include/va-mips.h	/^  __boolean_type_class,$/;"	e	enum:__anon42
__boolean_type_class	include/va-sh.h	/^  __boolean_type_class,$/;"	e	enum:__va_type_classes
__boolean_type_class	include/va-sparc.h	/^  __boolean_type_class,$/;"	e	enum:__va_type_classes
__char_type_class	include/va-alpha.h	/^  __char_type_class,$/;"	e	enum:__anon23
__char_type_class	include/va-alpha.h	/^  __char_type_class,$/;"	e	enum:__anon48
__char_type_class	include/va-arc.h	/^  __char_type_class,$/;"	e	enum:__va_type_classes
__char_type_class	include/va-i860.h	/^  __char_type_class,$/;"	e	enum:__anon27
__char_type_class	include/va-i860.h	/^  __char_type_class,$/;"	e	enum:__anon52
__char_type_class	include/va-m32r.h	/^  __char_type_class,$/;"	e	enum:__type_class
__char_type_class	include/va-mips.h	/^  __char_type_class,$/;"	e	enum:__anon17
__char_type_class	include/va-mips.h	/^  __char_type_class,$/;"	e	enum:__anon42
__char_type_class	include/va-sh.h	/^  __char_type_class,$/;"	e	enum:__va_type_classes
__char_type_class	include/va-sparc.h	/^  __char_type_class,$/;"	e	enum:__va_type_classes
__chunk_insertion_sort	g++/stl_algo.h	/^void __chunk_insertion_sort(RandomAccessIterator first, $/;"	f
__complex_type_class	include/va-alpha.h	/^  __complex_type_class,$/;"	e	enum:__anon23
__complex_type_class	include/va-alpha.h	/^  __complex_type_class,$/;"	e	enum:__anon48
__complex_type_class	include/va-arc.h	/^  __complex_type_class,$/;"	e	enum:__va_type_classes
__complex_type_class	include/va-i860.h	/^  __complex_type_class,$/;"	e	enum:__anon27
__complex_type_class	include/va-i860.h	/^  __complex_type_class,$/;"	e	enum:__anon52
__complex_type_class	include/va-m32r.h	/^  __complex_type_class,$/;"	e	enum:__type_class
__complex_type_class	include/va-mips.h	/^  __complex_type_class,$/;"	e	enum:__anon17
__complex_type_class	include/va-mips.h	/^  __complex_type_class,$/;"	e	enum:__anon42
__complex_type_class	include/va-sh.h	/^  __complex_type_class,$/;"	e	enum:__va_type_classes
__complex_type_class	include/va-sparc.h	/^  __complex_type_class,$/;"	e	enum:__va_type_classes
__cond_store_eos	g++/stl_rope.h	/^inline void __cond_store_eos(char& c) { c = 0; }$/;"	f
__cond_store_eos	g++/stl_rope.h	/^inline void __cond_store_eos(charT&) {}$/;"	f
__cond_store_eos	g++/stl_rope.h	/^inline void __cond_store_eos(wchar_t& c) { c = 0; }$/;"	f
__copy	g++/stl_algobase.h	/^__copy(InputIterator first, InputIterator last, OutputIterator result, input_iterator_tag)$/;"	f
__copy	g++/stl_algobase.h	/^__copy(RandomAccessIterator first, RandomAccessIterator last, OutputIterator result, random_access_iterator_tag)$/;"	f
__copy	g++/stl_tree.h	/^rb_tree<K, V, KeyOfValue, Compare, Alloc>::__copy(link_type x, link_type p) {$/;"	f	class:rb_tree
__copy_backward	g++/stl_algobase.h	/^inline BidirectionalIterator2 __copy_backward(BidirectionalIterator1 first, $/;"	f
__copy_backward_dispatch	g++/stl_algobase.h	/^struct __copy_backward_dispatch$/;"	s
__copy_backward_dispatch	g++/stl_algobase.h	/^struct __copy_backward_dispatch<T*, T*>$/;"	s
__copy_backward_dispatch	g++/stl_algobase.h	/^struct __copy_backward_dispatch<const T*, T*>$/;"	s
__copy_backward_t	g++/stl_algobase.h	/^__copy_backward_t(const T* first, const T* last, T* result, __false_type) $/;"	f
__copy_backward_t	g++/stl_algobase.h	/^__copy_backward_t(const T* first, const T* last, T* result,$/;"	f
__copy_d	g++/stl_algobase.h	/^__copy_d(RandomAccessIterator first, RandomAccessIterator last, OutputIterator result, Distance*)$/;"	f
__copy_dispatch	g++/stl_algobase.h	/^struct __copy_dispatch$/;"	s
__copy_dispatch	g++/stl_algobase.h	/^struct __copy_dispatch<T*, T*>$/;"	s
__copy_dispatch	g++/stl_algobase.h	/^struct __copy_dispatch<const T*, T*>$/;"	s
__copy_n	g++/stl_algobase.h	/^__copy_n(RandomAccessIterator first, Size count, OutputIterator result, random_access_iterator_tag) $/;"	f
__copy_n	g++/stl_algobase.h	/^pair<InputIterator, OutputIterator> __copy_n(InputIterator first, Size count,$/;"	f
__copy_t	g++/stl_algobase.h	/^__copy_t(const T* first, const T* last, T* result, __true_type) $/;"	f
__copy_t	g++/stl_algobase.h	/^inline T* __copy_t(const T* first, const T* last, T* result, __false_type) $/;"	f
__count	include/va-pyr.h	/^      __voidptr __stackp,__regp,__count;$/;"	m	struct:__va_regs
__default_alloc_template	g++/stl_alloc.h	/^class __default_alloc_template $/;"	c
__deque_buf_size	g++/stl_deque.h	/^inline size_t __deque_buf_size(size_t n, size_t sz)$/;"	f	namespace:std
__deque_iterator	g++/stl_deque.h	/^	__deque_iterator() : cur(0), first(0), last(0), node(0) {}$/;"	f	struct:std::__deque_iterator
__deque_iterator	g++/stl_deque.h	/^	__deque_iterator(T* x, map_pointer y) : cur(x), first(*y), last(*y + buffer_size()), node(y) {}$/;"	f	struct:std::__deque_iterator
__deque_iterator	g++/stl_deque.h	/^	__deque_iterator(const iterator& x) : cur(x.cur), first(x.first), last(x.last), node(x.node) {}$/;"	f	struct:std::__deque_iterator
__deque_iterator	g++/stl_deque.h	/^struct __deque_iterator $/;"	s	namespace:std
__destroy	g++/stl_construct.h	/^__destroy(ForwardIterator first, ForwardIterator last, T*) $/;"	f	namespace:std
__destroy_aux	g++/stl_construct.h	/^__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) $/;"	f	namespace:std
__destroy_aux	g++/stl_construct.h	/^inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}$/;"	f	namespace:std
__distance	g++/stl_iterator.h	/^__distance(InputIterator first, InputIterator last, Distance& n, input_iterator_tag) $/;"	f
__distance	g++/stl_iterator.h	/^__distance(InputIterator first, InputIterator last, input_iterator_tag) {$/;"	f
__distance	g++/stl_iterator.h	/^__distance(RandomAccessIterator first, RandomAccessIterator last, Distance& n, random_access_iterator_tag) $/;"	f
__distance	g++/stl_iterator.h	/^__distance(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__doadv	g++/std/complext.cc	/^__doadv (complex<FLOAT>* ths, const complex<FLOAT>& y)$/;"	f
__doami	g++/std/complext.h	/^__doami (complex<_FLT>* ths, const complex<_FLT>& r)$/;"	f
__doaml	g++/std/complext.h	/^__doaml (complex<_FLT>* ths, const complex<_FLT>& r)$/;"	f
__doapl	g++/std/complext.h	/^__doapl (complex<_FLT>* ths, const complex<_FLT>& r)$/;"	f
__dreg	include/va-i860.h	/^  double	__dreg[4];$/;"	m	union:__anon24
__dreg	include/va-i860.h	/^  double	__dreg[4];$/;"	m	union:__anon49
__enumeral_type_class	include/va-alpha.h	/^  __enumeral_type_class,$/;"	e	enum:__anon23
__enumeral_type_class	include/va-alpha.h	/^  __enumeral_type_class,$/;"	e	enum:__anon48
__enumeral_type_class	include/va-arc.h	/^  __enumeral_type_class,$/;"	e	enum:__va_type_classes
__enumeral_type_class	include/va-i860.h	/^  __enumeral_type_class,$/;"	e	enum:__anon27
__enumeral_type_class	include/va-i860.h	/^  __enumeral_type_class,$/;"	e	enum:__anon52
__enumeral_type_class	include/va-m32r.h	/^  __enumeral_type_class,$/;"	e	enum:__type_class
__enumeral_type_class	include/va-mips.h	/^  __enumeral_type_class,$/;"	e	enum:__anon17
__enumeral_type_class	include/va-mips.h	/^  __enumeral_type_class,$/;"	e	enum:__anon42
__enumeral_type_class	include/va-sh.h	/^  __enumeral_type_class,$/;"	e	enum:__va_type_classes
__enumeral_type_class	include/va-sparc.h	/^  __enumeral_type_class,$/;"	e	enum:__va_type_classes
__eos	g++/stl_rope.h	/^inline charT __eos(charT*) { return charT(); }$/;"	f
__equal_range	g++/stl_algo.h	/^__equal_range(ForwardIterator first, ForwardIterator last, const T& value,$/;"	f
__equal_range	g++/stl_algo.h	/^__equal_range(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__erase	g++/stl_tree.h	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__erase(link_type x) {$/;"	f	class:rb_tree
__extension__	include/va-alpha.h	102;"	d
__extension__	include/va-arc.h	73;"	d
__extension__	include/va-i860.h	121;"	d
__extension__	include/va-i960.h	35;"	d
__extension__	include/va-pyr.h	107;"	d
__extension__	include/va-sparc.h	82;"	d
__extension__	include/va-spur.h	36;"	d
__f_regs	include/va-i860.h	/^} __f_regs;$/;"	t	typeref:union:__anon24
__f_regs	include/va-i860.h	/^} __f_regs;$/;"	t	typeref:union:__anon49
__false_type	g++/type_traits.h	/^struct __false_type {};$/;"	s
__file_type_class	include/va-alpha.h	/^  __file_type_class,$/;"	e	enum:__anon23
__file_type_class	include/va-alpha.h	/^  __file_type_class,$/;"	e	enum:__anon48
__file_type_class	include/va-arc.h	/^  __file_type_class,$/;"	e	enum:__va_type_classes
__file_type_class	include/va-i860.h	/^  __file_type_class,$/;"	e	enum:__anon27
__file_type_class	include/va-i860.h	/^  __file_type_class,$/;"	e	enum:__anon52
__file_type_class	include/va-m32r.h	/^  __file_type_class,$/;"	e	enum:__type_class
__file_type_class	include/va-mips.h	/^  __file_type_class,$/;"	e	enum:__anon17
__file_type_class	include/va-mips.h	/^  __file_type_class,$/;"	e	enum:__anon42
__file_type_class	include/va-sh.h	/^  __file_type_class,$/;"	e	enum:__va_type_classes
__file_type_class	include/va-sparc.h	/^  __file_type_class,$/;"	e	enum:__va_type_classes
__final_insertion_sort	g++/stl_algo.h	/^void __final_insertion_sort(RandomAccessIterator first, $/;"	f
__find_end	g++/stl_algo.h	/^ForwardIterator1 __find_end(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f
__find_end	g++/stl_algo.h	/^__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,$/;"	f
__float_regs	include/va-i860.h	/^  __f_regs __float_regs; long __ireg[12];$/;"	m	struct:__anon25
__float_regs	include/va-i860.h	/^  __f_regs __float_regs; long __ireg[12];$/;"	m	struct:__anon50
__fmtflags	g++/streambuf.h	/^typedef unsigned long __fmtflags;$/;"	t
__fp_left	include/va-mips.h	/^  int __fp_left;$/;"	m	struct:__anon16
__fp_left	include/va-mips.h	/^  int __fp_left;$/;"	m	struct:__anon41
__fp_regs	include/va-mips.h	/^  char *__fp_regs;$/;"	m	struct:__anon16
__fp_regs	include/va-mips.h	/^  char *__fp_regs;$/;"	m	struct:__anon41
__fp_save	include/va-ppc.h	/^  double __fp_save[8];		\/* save area for FP registers *\/$/;"	m	struct:__anon19
__fp_save	include/va-ppc.h	/^  double __fp_save[8];		\/* save area for FP registers *\/$/;"	m	struct:__anon44
__freg	include/va-i860.h	/^  float		__freg[8];$/;"	m	union:__anon24
__freg	include/va-i860.h	/^  float		__freg[8];$/;"	m	union:__anon49
__freg_used	include/va-i860.h	/^  unsigned	__freg_used;	\/* How many flt regs consumed 'til now? *\/$/;"	m	struct:__anon26
__freg_used	include/va-i860.h	/^  unsigned	__freg_used;	\/* How many flt regs consumed 'til now? *\/$/;"	m	struct:__anon51
__function_type_class	include/va-alpha.h	/^  __function_type_class,$/;"	e	enum:__anon23
__function_type_class	include/va-alpha.h	/^  __function_type_class,$/;"	e	enum:__anon48
__function_type_class	include/va-arc.h	/^  __function_type_class,$/;"	e	enum:__va_type_classes
__function_type_class	include/va-i860.h	/^  __function_type_class,$/;"	e	enum:__anon27
__function_type_class	include/va-i860.h	/^  __function_type_class,$/;"	e	enum:__anon52
__function_type_class	include/va-m32r.h	/^  __function_type_class,$/;"	e	enum:__type_class
__function_type_class	include/va-mips.h	/^  __function_type_class,$/;"	e	enum:__anon17
__function_type_class	include/va-mips.h	/^  __function_type_class,$/;"	e	enum:__anon42
__function_type_class	include/va-sh.h	/^  __function_type_class,$/;"	e	enum:__va_type_classes
__function_type_class	include/va-sparc.h	/^  __function_type_class,$/;"	e	enum:__va_type_classes
__gap_end_pos	g++/editbuf.h	/^    buf_offset __gap_end_pos; \/\/ size of part 1 + size of gap$/;"	m	struct:edit_buffer
__gcd	g++/stl_algo.h	/^EuclideanRingElement __gcd(EuclideanRingElement m, EuclideanRingElement n)$/;"	f
__gnuc_va_list	include/stdarg.h	/^typedef char *__gnuc_va_list;$/;"	t
__gnuc_va_list	include/stdarg.h	/^typedef void *__gnuc_va_list;$/;"	t
__gnuc_va_list	include/va-alpha.h	/^typedef char *__gnuc_va_list;$/;"	t
__gnuc_va_list	include/va-alpha.h	/^} __gnuc_va_list;$/;"	t	typeref:struct:__anon22
__gnuc_va_list	include/va-alpha.h	/^} __gnuc_va_list;$/;"	t	typeref:struct:__anon47
__gnuc_va_list	include/va-arc.h	/^typedef void * __gnuc_va_list;$/;"	t
__gnuc_va_list	include/va-clipper.h	/^} __gnuc_va_list;$/;"	t	typeref:struct:__anon15
__gnuc_va_list	include/va-clipper.h	/^} __gnuc_va_list;$/;"	t	typeref:struct:__anon40
__gnuc_va_list	include/va-h8300.h	/^typedef void *__gnuc_va_list;$/;"	t
__gnuc_va_list	include/va-i860.h	/^} __gnuc_va_list;$/;"	t	typeref:struct:__anon26
__gnuc_va_list	include/va-i860.h	/^} __gnuc_va_list;$/;"	t	typeref:struct:__anon51
__gnuc_va_list	include/va-i960.h	/^typedef unsigned __gnuc_va_list[2];	$/;"	t
__gnuc_va_list	include/va-m32r.h	/^typedef void *__gnuc_va_list;$/;"	t
__gnuc_va_list	include/va-m88k.h	/^} __gnuc_va_list;$/;"	t	typeref:struct:__anon18
__gnuc_va_list	include/va-m88k.h	/^} __gnuc_va_list;$/;"	t	typeref:struct:__anon43
__gnuc_va_list	include/va-m88k.h	57;"	d
__gnuc_va_list	include/va-mips.h	/^typedef char * __gnuc_va_list;$/;"	t
__gnuc_va_list	include/va-mips.h	/^} __gnuc_va_list;$/;"	t	typeref:struct:__anon16
__gnuc_va_list	include/va-mips.h	/^} __gnuc_va_list;$/;"	t	typeref:struct:__anon41
__gnuc_va_list	include/va-mn10200.h	/^typedef void *__gnuc_va_list;$/;"	t
__gnuc_va_list	include/va-mn10300.h	/^typedef void *__gnuc_va_list;$/;"	t
__gnuc_va_list	include/va-pa.h	/^typedef void *__gnuc_va_list;$/;"	t
__gnuc_va_list	include/va-ppc.h	/^typedef __va_list __gnuc_va_list;$/;"	t
__gnuc_va_list	include/va-ppc.h	/^typedef char *__gnuc_va_list;$/;"	t
__gnuc_va_list	include/va-ppc.h	/^} __va_list[1], __gnuc_va_list[1];$/;"	t	typeref:struct:__va_list_tag
__gnuc_va_list	include/va-pyr.h	/^typedef __va_buf __gnuc_va_list;$/;"	t
__gnuc_va_list	include/va-sh.h	/^typedef void *__gnuc_va_list;$/;"	t
__gnuc_va_list	include/va-sh.h	/^} __gnuc_va_list;$/;"	t	typeref:struct:__anon20
__gnuc_va_list	include/va-sh.h	/^} __gnuc_va_list;$/;"	t	typeref:struct:__anon45
__gnuc_va_list	include/va-sparc.h	/^typedef char * __gnuc_va_list;$/;"	t
__gnuc_va_list	include/va-sparc.h	/^typedef void * __gnuc_va_list;$/;"	t
__gnuc_va_list	include/va-v850.h	/^typedef void *__gnuc_va_list;$/;"	t
__gnuc_va_list	include/varargs.h	/^typedef char *__gnuc_va_list;$/;"	t
__gnuc_va_list	include/varargs.h	/^typedef void *__gnuc_va_list;$/;"	t
__gnuc_va_start	include/va-mn10200.h	12;"	d
__gnuc_va_start	include/va-mn10300.h	11;"	d
__gnuc_va_start	include/va-pa.h	15;"	d
__gnuc_va_start	include/va-pa.h	19;"	d
__gp_regs	include/va-mips.h	/^  char *__gp_regs;$/;"	m	struct:__anon16
__gp_regs	include/va-mips.h	/^  char *__gp_regs;$/;"	m	struct:__anon41
__gp_save	include/va-ppc.h	/^  long   __gp_save[8];		\/* save area for GP registers *\/$/;"	m	struct:__anon19
__gp_save	include/va-ppc.h	/^  long   __gp_save[8];		\/* save area for GP registers *\/$/;"	m	struct:__anon44
__hashtable_const_iterator	g++/stl_hashtable.h	/^  __hashtable_const_iterator() {}$/;"	f	struct:__hashtable_const_iterator
__hashtable_const_iterator	g++/stl_hashtable.h	/^  __hashtable_const_iterator(const iterator& it) : cur(it.cur), ht(it.ht) {}$/;"	f	struct:__hashtable_const_iterator
__hashtable_const_iterator	g++/stl_hashtable.h	/^  __hashtable_const_iterator(const node* n, const hashtable* tab)$/;"	f	struct:__hashtable_const_iterator
__hashtable_const_iterator	g++/stl_hashtable.h	/^struct __hashtable_const_iterator {$/;"	s
__hashtable_iterator	g++/stl_hashtable.h	/^  __hashtable_iterator() {}$/;"	f	struct:__hashtable_iterator
__hashtable_iterator	g++/stl_hashtable.h	/^  __hashtable_iterator(node* n, hashtable* tab) : cur(n), ht(tab) {}$/;"	f	struct:__hashtable_iterator
__hashtable_iterator	g++/stl_hashtable.h	/^struct __hashtable_iterator {$/;"	s
__hashtable_node	g++/stl_hashtable.h	/^struct __hashtable_node$/;"	s
__imanip	g++/iostream.h	/^typedef istream& (*__imanip)(istream&);$/;"	t
__inplace_merge_aux	g++/stl_algo.h	/^inline void __inplace_merge_aux(BidirectionalIterator first,$/;"	f
__inplace_stable_partition	g++/stl_algo.h	/^ForwardIterator __inplace_stable_partition(ForwardIterator first,$/;"	f
__inplace_stable_sort	g++/stl_algo.h	/^void __inplace_stable_sort(RandomAccessIterator first,$/;"	f
__insert	g++/stl_tree.h	/^__insert(base_ptr x_, base_ptr y_, const Value& v) {$/;"	f	class:rb_tree
__insertion_sort	g++/stl_algo.h	/^void __insertion_sort(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f
__insertion_sort	g++/stl_algo.h	/^void __insertion_sort(RandomAccessIterator first,$/;"	f
__integer_type_class	include/va-alpha.h	/^  __integer_type_class,$/;"	e	enum:__anon23
__integer_type_class	include/va-alpha.h	/^  __integer_type_class,$/;"	e	enum:__anon48
__integer_type_class	include/va-arc.h	/^  __integer_type_class,$/;"	e	enum:__va_type_classes
__integer_type_class	include/va-i860.h	/^  __integer_type_class,$/;"	e	enum:__anon27
__integer_type_class	include/va-i860.h	/^  __integer_type_class,$/;"	e	enum:__anon52
__integer_type_class	include/va-m32r.h	/^  __integer_type_class,$/;"	e	enum:__type_class
__integer_type_class	include/va-mips.h	/^  __integer_type_class,$/;"	e	enum:__anon17
__integer_type_class	include/va-mips.h	/^  __integer_type_class,$/;"	e	enum:__anon42
__integer_type_class	include/va-sh.h	/^  __integer_type_class,$/;"	e	enum:__va_type_classes
__integer_type_class	include/va-sparc.h	/^  __integer_type_class,$/;"	e	enum:__va_type_classes
__introsort_loop	g++/stl_algo.h	/^void __introsort_loop(RandomAccessIterator first,$/;"	f
__iostate	g++/streambuf.h	/^typedef unsigned char __iostate;$/;"	t
__ireg	include/va-i860.h	/^  __f_regs __float_regs; long __ireg[12];$/;"	m	struct:__anon25
__ireg	include/va-i860.h	/^  __f_regs __float_regs; long __ireg[12];$/;"	m	struct:__anon50
__ireg_used	include/va-i860.h	/^  unsigned	__ireg_used;	\/* How many int regs consumed 'til now? *\/$/;"	m	struct:__anon26
__ireg_used	include/va-i860.h	/^  unsigned	__ireg_used;	\/* How many int regs consumed 'til now? *\/$/;"	m	struct:__anon51
__is_basic_char_type	g++/stl_rope.h	/^inline bool __is_basic_char_type(char *) { return true; }$/;"	f
__is_basic_char_type	g++/stl_rope.h	/^inline bool __is_basic_char_type(charT *) { return false; }$/;"	f
__is_basic_char_type	g++/stl_rope.h	/^inline bool __is_basic_char_type(wchar_t *) { return true; }$/;"	f
__is_heap	g++/stl_algo.h	/^bool __is_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__is_one_byte_char_type	g++/stl_rope.h	/^inline bool __is_one_byte_char_type(char *) { return true; }$/;"	f
__is_one_byte_char_type	g++/stl_rope.h	/^inline bool __is_one_byte_char_type(charT *) { return false; }$/;"	f
__iter_swap	g++/stl_algobase.h	/^__iter_swap(ForwardIterator1 a, ForwardIterator2 b, T*) {$/;"	f
__lang_type_class	include/va-alpha.h	/^  __lang_type_class$/;"	e	enum:__anon23
__lang_type_class	include/va-alpha.h	/^  __lang_type_class$/;"	e	enum:__anon48
__lang_type_class	include/va-arc.h	/^  __lang_type_class$/;"	e	enum:__va_type_classes
__lang_type_class	include/va-i860.h	/^  __lang_type_class$/;"	e	enum:__anon27
__lang_type_class	include/va-i860.h	/^  __lang_type_class$/;"	e	enum:__anon52
__lang_type_class	include/va-m32r.h	/^  __lang_type_class$/;"	e	enum:__type_class
__lang_type_class	include/va-mips.h	/^  __lang_type_class$/;"	e	enum:__anon17
__lang_type_class	include/va-mips.h	/^  __lang_type_class$/;"	e	enum:__anon42
__lang_type_class	include/va-sh.h	/^  __lang_type_class$/;"	e	enum:__va_type_classes
__lang_type_class	include/va-sparc.h	/^  __lang_type_class$/;"	e	enum:__va_type_classes
__lg	g++/stl_algo.h	/^inline Size __lg(Size n) {$/;"	f
__line_number	g++/parsestream.h	/^    unsigned long __line_number;$/;"	m	class:parsebuf
__linear_insert	g++/stl_algo.h	/^inline void __linear_insert(RandomAccessIterator first, $/;"	f
__list_iterator	g++/stl_list.h	/^	__list_iterator() {}$/;"	f	struct:std::__list_iterator
__list_iterator	g++/stl_list.h	/^	__list_iterator(const iterator& x) : node(x.node) {}$/;"	f	struct:std::__list_iterator
__list_iterator	g++/stl_list.h	/^	__list_iterator(link_type x) : node(x) {}$/;"	f	struct:std::__list_iterator
__list_iterator	g++/stl_list.h	/^struct __list_iterator $/;"	s	namespace:std
__list_node	g++/stl_list.h	/^struct __list_node $/;"	s	namespace:std
__lock	g++/stl_alloc.h	/^__default_alloc_template<threads, inst>::__lock(volatile unsigned long *lock)$/;"	f	class:__default_alloc_template
__lower_bound	g++/stl_algo.h	/^ForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,$/;"	f
__lower_bound	g++/stl_algo.h	/^RandomAccessIterator __lower_bound(RandomAccessIterator first,$/;"	f
__make_heap	g++/stl_heap.h	/^void __make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp, T*, Distance*) $/;"	f
__make_heap	g++/stl_heap.h	/^void __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*,  Distance*) $/;"	f
__malloc_alloc_oom_handler	g++/stl_alloc.h	/^	static void (* __malloc_alloc_oom_handler)(); $/;"	m	class:__malloc_alloc_template
__malloc_alloc_template	g++/stl_alloc.h	/^class __malloc_alloc_template $/;"	c
__manip	g++/iostream.h	/^typedef ios& (*__manip)(ios&);$/;"	t
__median	g++/stl_algo.h	/^inline const T& __median(const T& a, const T& b, const T& c) {$/;"	f
__median	g++/stl_algo.h	/^inline const T& __median(const T& a, const T& b, const T& c, Compare comp) {$/;"	f
__mem_ptr	include/va-i860.h	/^  long *	__mem_ptr;	\/* Address of memory overflow args area. *\/$/;"	m	struct:__anon26
__mem_ptr	include/va-i860.h	/^  long *	__mem_ptr;	\/* Address of memory overflow args area. *\/$/;"	m	struct:__anon51
__merge_adaptive	g++/stl_algo.h	/^void __merge_adaptive(BidirectionalIterator first, $/;"	f
__merge_backward	g++/stl_algo.h	/^BidirectionalIterator3 __merge_backward(BidirectionalIterator1 first1,$/;"	f
__merge_sort_loop	g++/stl_algo.h	/^void __merge_sort_loop(RandomAccessIterator1 first,$/;"	f
__merge_sort_with_buffer	g++/stl_algo.h	/^void __merge_sort_with_buffer(RandomAccessIterator first, $/;"	f
__merge_without_buffer	g++/stl_algo.h	/^void __merge_without_buffer(BidirectionalIterator first,$/;"	f
__method_type_class	include/va-alpha.h	/^  __method_type_class,$/;"	e	enum:__anon23
__method_type_class	include/va-alpha.h	/^  __method_type_class,$/;"	e	enum:__anon48
__method_type_class	include/va-arc.h	/^  __method_type_class,$/;"	e	enum:__va_type_classes
__method_type_class	include/va-i860.h	/^  __method_type_class,$/;"	e	enum:__anon27
__method_type_class	include/va-i860.h	/^  __method_type_class,$/;"	e	enum:__anon52
__method_type_class	include/va-m32r.h	/^  __method_type_class,$/;"	e	enum:__type_class
__method_type_class	include/va-mips.h	/^  __method_type_class,$/;"	e	enum:__anon17
__method_type_class	include/va-mips.h	/^  __method_type_class,$/;"	e	enum:__anon42
__method_type_class	include/va-sh.h	/^  __method_type_class,$/;"	e	enum:__va_type_classes
__method_type_class	include/va-sparc.h	/^  __method_type_class,$/;"	e	enum:__va_type_classes
__mutable_reference_at	g++/stl_rope.h	/^inline crope::reference __mutable_reference_at(crope& c, size_t i)$/;"	f
__mutable_reference_at	g++/stl_rope.h	/^inline wrope::reference __mutable_reference_at(wrope& c, size_t i)$/;"	f
__my_fb	g++/fstream.h	/^    mutable filebuf __my_fb; \/\/ mutable so rdbuf() can be const$/;"	m	class:fstreambase
__my_sb	g++/strstream.h	/^    strstreambuf __my_sb;$/;"	m	class:strstreambase
__need_NULL	include/stddef.h	331;"	d
__need___va_list	g++/libio.h	49;"	d
__need___va_list	include/stdarg.h	12;"	d
__need_ptrdiff_t	include/stddef.h	129;"	d
__need_size_t	include/stddef.h	189;"	d
__need_wchar_t	include/stddef.h	270;"	d
__need_wint_t	include/stddef.h	282;"	d
__no_type_class	include/va-alpha.h	/^  __no_type_class = -1,$/;"	e	enum:__anon23
__no_type_class	include/va-alpha.h	/^  __no_type_class = -1,$/;"	e	enum:__anon48
__no_type_class	include/va-arc.h	/^  __no_type_class = -1,$/;"	e	enum:__va_type_classes
__no_type_class	include/va-i860.h	/^  __no_type_class = -1,$/;"	e	enum:__anon27
__no_type_class	include/va-i860.h	/^  __no_type_class = -1,$/;"	e	enum:__anon52
__no_type_class	include/va-m32r.h	/^  __no_type_class = -1,$/;"	e	enum:__type_class
__no_type_class	include/va-mips.h	/^  __no_type_class = -1,$/;"	e	enum:__anon17
__no_type_class	include/va-mips.h	/^  __no_type_class = -1,$/;"	e	enum:__anon42
__no_type_class	include/va-sh.h	/^  __no_type_class = -1,$/;"	e	enum:__va_type_classes
__no_type_class	include/va-sparc.h	/^  __no_type_class = -1,$/;"	e	enum:__va_type_classes
__node_allocator_lock	g++/stl_alloc.h	/^__default_alloc_template<threads, inst>::__node_allocator_lock = 0;$/;"	m	class:__default_alloc_template
__node_allocator_lock	g++/stl_alloc.h	/^__default_alloc_template<threads, inst>::__node_allocator_lock;$/;"	m	class:__default_alloc_template
__node_allocator_lock	g++/stl_alloc.h	/^__default_alloc_template<threads, inst>::__node_allocator_lock= PTHREAD_MUTEX_INITIALIZER;$/;"	m	class:__default_alloc_template
__node_allocator_lock_initialize	g++/stl_alloc.h	/^__default_alloc_template<threads, inst>::__node_allocator_lock_initialize = false;$/;"	m	class:__default_alloc_template
__nth_element	g++/stl_algo.h	/^void __nth_element(RandomAccessIterator first, RandomAccessIterator nth,$/;"	f
__offset	include/va-alpha.h	/^  int __offset;			\/* Byte offset of args so far. *\/$/;"	m	struct:__anon22
__offset	include/va-alpha.h	/^  int __offset;			\/* Byte offset of args so far. *\/$/;"	m	struct:__anon47
__offset_type_class	include/va-alpha.h	/^  __offset_type_class,$/;"	e	enum:__anon23
__offset_type_class	include/va-alpha.h	/^  __offset_type_class,$/;"	e	enum:__anon48
__offset_type_class	include/va-arc.h	/^  __offset_type_class,$/;"	e	enum:__va_type_classes
__offset_type_class	include/va-i860.h	/^  __offset_type_class,$/;"	e	enum:__anon27
__offset_type_class	include/va-i860.h	/^  __offset_type_class,$/;"	e	enum:__anon52
__offset_type_class	include/va-m32r.h	/^  __offset_type_class,$/;"	e	enum:__type_class
__offset_type_class	include/va-mips.h	/^  __offset_type_class,$/;"	e	enum:__anon17
__offset_type_class	include/va-mips.h	/^  __offset_type_class,$/;"	e	enum:__anon42
__offset_type_class	include/va-sh.h	/^  __offset_type_class,$/;"	e	enum:__va_type_classes
__offset_type_class	include/va-sparc.h	/^  __offset_type_class,$/;"	e	enum:__va_type_classes
__omanip	g++/iostream.h	/^typedef ostream& (*__omanip)(ostream&);$/;"	t
__partial_sort	g++/stl_algo.h	/^void __partial_sort(RandomAccessIterator first, RandomAccessIterator middle,$/;"	f
__partial_sort_copy	g++/stl_algo.h	/^RandomAccessIterator __partial_sort_copy(InputIterator first,$/;"	f
__partial_sum	g++/stl_numeric.h	/^OutputIterator __partial_sum(InputIterator first, InputIterator last,$/;"	f
__pnt	include/va-spur.h	/^    int __pnt;$/;"	m	struct:__anon21
__pnt	include/va-spur.h	/^    int __pnt;$/;"	m	struct:__anon46
__pointer_type_class	include/va-alpha.h	/^  __pointer_type_class,$/;"	e	enum:__anon23
__pointer_type_class	include/va-alpha.h	/^  __pointer_type_class,$/;"	e	enum:__anon48
__pointer_type_class	include/va-arc.h	/^  __pointer_type_class,$/;"	e	enum:__va_type_classes
__pointer_type_class	include/va-i860.h	/^  __pointer_type_class,$/;"	e	enum:__anon27
__pointer_type_class	include/va-i860.h	/^  __pointer_type_class,$/;"	e	enum:__anon52
__pointer_type_class	include/va-m32r.h	/^  __pointer_type_class,$/;"	e	enum:__type_class
__pointer_type_class	include/va-mips.h	/^  __pointer_type_class,$/;"	e	enum:__anon17
__pointer_type_class	include/va-mips.h	/^  __pointer_type_class,$/;"	e	enum:__anon42
__pointer_type_class	include/va-sh.h	/^  __pointer_type_class,$/;"	e	enum:__va_type_classes
__pointer_type_class	include/va-sparc.h	/^  __pointer_type_class,$/;"	e	enum:__va_type_classes
__pop_heap	g++/stl_heap.h	/^inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last, $/;"	f
__pop_heap	g++/stl_heap.h	/^inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__pop_heap_aux	g++/stl_heap.h	/^inline void __pop_heap_aux(RandomAccessIterator first, RandomAccessIterator last, T*) $/;"	f
__pop_heap_aux	g++/stl_heap.h	/^inline void __pop_heap_aux(RandomAccessIterator first,RandomAccessIterator last, $/;"	f
__pr0	include/va-pyr.h	/^      __voidptr __pr0,__pr1,__pr2,__pr3,__pr4,__pr5,__pr6,__pr7,__pr8,__pr9,__pr10,__pr11;$/;"	m	struct:__va_regs
__pr1	include/va-pyr.h	/^      __voidptr __pr0,__pr1,__pr2,__pr3,__pr4,__pr5,__pr6,__pr7,__pr8,__pr9,__pr10,__pr11;$/;"	m	struct:__va_regs
__pr10	include/va-pyr.h	/^      __voidptr __pr0,__pr1,__pr2,__pr3,__pr4,__pr5,__pr6,__pr7,__pr8,__pr9,__pr10,__pr11;$/;"	m	struct:__va_regs
__pr11	include/va-pyr.h	/^      __voidptr __pr0,__pr1,__pr2,__pr3,__pr4,__pr5,__pr6,__pr7,__pr8,__pr9,__pr10,__pr11;$/;"	m	struct:__va_regs
__pr2	include/va-pyr.h	/^      __voidptr __pr0,__pr1,__pr2,__pr3,__pr4,__pr5,__pr6,__pr7,__pr8,__pr9,__pr10,__pr11;$/;"	m	struct:__va_regs
__pr3	include/va-pyr.h	/^      __voidptr __pr0,__pr1,__pr2,__pr3,__pr4,__pr5,__pr6,__pr7,__pr8,__pr9,__pr10,__pr11;$/;"	m	struct:__va_regs
__pr4	include/va-pyr.h	/^      __voidptr __pr0,__pr1,__pr2,__pr3,__pr4,__pr5,__pr6,__pr7,__pr8,__pr9,__pr10,__pr11;$/;"	m	struct:__va_regs
__pr5	include/va-pyr.h	/^      __voidptr __pr0,__pr1,__pr2,__pr3,__pr4,__pr5,__pr6,__pr7,__pr8,__pr9,__pr10,__pr11;$/;"	m	struct:__va_regs
__pr6	include/va-pyr.h	/^      __voidptr __pr0,__pr1,__pr2,__pr3,__pr4,__pr5,__pr6,__pr7,__pr8,__pr9,__pr10,__pr11;$/;"	m	struct:__va_regs
__pr7	include/va-pyr.h	/^      __voidptr __pr0,__pr1,__pr2,__pr3,__pr4,__pr5,__pr6,__pr7,__pr8,__pr9,__pr10,__pr11;$/;"	m	struct:__va_regs
__pr8	include/va-pyr.h	/^      __voidptr __pr0,__pr1,__pr2,__pr3,__pr4,__pr5,__pr6,__pr7,__pr8,__pr9,__pr10,__pr11;$/;"	m	struct:__va_regs
__pr9	include/va-pyr.h	/^      __voidptr __pr0,__pr1,__pr2,__pr3,__pr4,__pr5,__pr6,__pr7,__pr8,__pr9,__pr10,__pr11;$/;"	m	struct:__va_regs
__ptrint	include/va-sparc.h	/^typedef unsigned int __ptrint __attribute__ ((__mode__ (__DI__)));$/;"	t
__push_heap	g++/stl_heap.h	/^void __push_heap(RandomAccessIterator first, Distance holeIndex, Distance topIndex, T value) $/;"	f
__push_heap	g++/stl_heap.h	/^void __push_heap(RandomAccessIterator first, Distance holeIndex, Distance topIndex, T value, Compare comp) $/;"	f
__push_heap_aux	g++/stl_heap.h	/^inline void __push_heap_aux(RandomAccessIterator first, RandomAccessIterator last, Compare comp,Distance*, T*) $/;"	f
__push_heap_aux	g++/stl_heap.h	/^inline void __push_heap_aux(RandomAccessIterator first, RandomAccessIterator last, Distance*, T*) $/;"	f
__random_sample	g++/stl_algo.h	/^RandomAccessIterator __random_sample(InputIterator first, InputIterator last,$/;"	f
__random_shuffle	g++/stl_algo.h	/^void __random_shuffle(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__rb_tree_base_iterator	g++/stl_tree.h	/^struct __rb_tree_base_iterator$/;"	s
__rb_tree_black	g++/stl_tree.h	/^const __rb_tree_color_type __rb_tree_black = true;$/;"	v
__rb_tree_color_type	g++/stl_tree.h	/^typedef bool __rb_tree_color_type;$/;"	t
__rb_tree_iterator	g++/stl_tree.h	/^	__rb_tree_iterator() {}$/;"	f	struct:__rb_tree_iterator
__rb_tree_iterator	g++/stl_tree.h	/^	__rb_tree_iterator(const iterator& it) { node = it.node; }$/;"	f	struct:__rb_tree_iterator
__rb_tree_iterator	g++/stl_tree.h	/^	__rb_tree_iterator(link_type x) { node = x; }$/;"	f	struct:__rb_tree_iterator
__rb_tree_iterator	g++/stl_tree.h	/^struct __rb_tree_iterator : public __rb_tree_base_iterator$/;"	s
__rb_tree_node	g++/stl_tree.h	/^struct __rb_tree_node : public __rb_tree_node_base$/;"	s
__rb_tree_node_base	g++/stl_tree.h	/^struct __rb_tree_node_base$/;"	s
__rb_tree_rebalance	g++/stl_tree.h	/^__rb_tree_rebalance(__rb_tree_node_base* x, __rb_tree_node_base*& root)$/;"	f
__rb_tree_rebalance_for_erase	g++/stl_tree.h	/^__rb_tree_rebalance_for_erase(__rb_tree_node_base* z,$/;"	f
__rb_tree_red	g++/stl_tree.h	/^const __rb_tree_color_type __rb_tree_red = false;$/;"	v
__rb_tree_rotate_left	g++/stl_tree.h	/^__rb_tree_rotate_left(__rb_tree_node_base* x, __rb_tree_node_base*& root)$/;"	f
__rb_tree_rotate_right	g++/stl_tree.h	/^__rb_tree_rotate_right(__rb_tree_node_base* x, __rb_tree_node_base*& root)$/;"	f
__rb_verify	g++/stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__rb_verify() const$/;"	f	class:rb_tree
__real_type_class	include/va-alpha.h	/^  __real_type_class,$/;"	e	enum:__anon23
__real_type_class	include/va-alpha.h	/^  __real_type_class,$/;"	e	enum:__anon48
__real_type_class	include/va-arc.h	/^  __real_type_class,$/;"	e	enum:__va_type_classes
__real_type_class	include/va-i860.h	/^  __real_type_class,$/;"	e	enum:__anon27
__real_type_class	include/va-i860.h	/^  __real_type_class,$/;"	e	enum:__anon52
__real_type_class	include/va-m32r.h	/^  __real_type_class,$/;"	e	enum:__type_class
__real_type_class	include/va-mips.h	/^  __real_type_class,$/;"	e	enum:__anon17
__real_type_class	include/va-mips.h	/^  __real_type_class,$/;"	e	enum:__anon42
__real_type_class	include/va-sh.h	/^  __real_type_class,$/;"	e	enum:__va_type_classes
__real_type_class	include/va-sparc.h	/^  __real_type_class,$/;"	e	enum:__va_type_classes
__record_type_class	include/va-alpha.h	/^  __record_type_class,$/;"	e	enum:__anon23
__record_type_class	include/va-alpha.h	/^  __record_type_class,$/;"	e	enum:__anon48
__record_type_class	include/va-arc.h	/^  __record_type_class,$/;"	e	enum:__va_type_classes
__record_type_class	include/va-i860.h	/^  __record_type_class,$/;"	e	enum:__anon27
__record_type_class	include/va-i860.h	/^  __record_type_class,$/;"	e	enum:__anon52
__record_type_class	include/va-m32r.h	/^  __record_type_class,$/;"	e	enum:__type_class
__record_type_class	include/va-mips.h	/^  __record_type_class,$/;"	e	enum:__anon17
__record_type_class	include/va-mips.h	/^  __record_type_class,$/;"	e	enum:__anon42
__record_type_class	include/va-sh.h	/^  __record_type_class,$/;"	e	enum:__va_type_classes
__record_type_class	include/va-sparc.h	/^  __record_type_class,$/;"	e	enum:__va_type_classes
__reference_type_class	include/va-alpha.h	/^  __reference_type_class,$/;"	e	enum:__anon23
__reference_type_class	include/va-alpha.h	/^  __reference_type_class,$/;"	e	enum:__anon48
__reference_type_class	include/va-arc.h	/^  __reference_type_class,$/;"	e	enum:__va_type_classes
__reference_type_class	include/va-i860.h	/^  __reference_type_class,$/;"	e	enum:__anon27
__reference_type_class	include/va-i860.h	/^  __reference_type_class,$/;"	e	enum:__anon52
__reference_type_class	include/va-m32r.h	/^  __reference_type_class,$/;"	e	enum:__type_class
__reference_type_class	include/va-mips.h	/^  __reference_type_class,$/;"	e	enum:__anon17
__reference_type_class	include/va-mips.h	/^  __reference_type_class,$/;"	e	enum:__anon42
__reference_type_class	include/va-sh.h	/^  __reference_type_class,$/;"	e	enum:__va_type_classes
__reference_type_class	include/va-sparc.h	/^  __reference_type_class,$/;"	e	enum:__va_type_classes
__reg_base	include/va-i860.h	/^  long		*__reg_base;	\/* Address of where we stored the regs. *\/$/;"	m	struct:__anon26
__reg_base	include/va-i860.h	/^  long		*__reg_base;	\/* Address of where we stored the regs. *\/$/;"	m	struct:__anon51
__regp	include/va-pyr.h	/^      __voidptr __stackp,__regp,__count;$/;"	m	struct:__va_regs
__regs	include/va-spur.h	/^    char *__regs;$/;"	m	struct:__anon21
__regs	include/va-spur.h	/^    char *__regs;$/;"	m	struct:__anon46
__regs	include/va-spur.h	/^struct __va_struct { char __regs[20]; };$/;"	m	struct:__va_struct
__reverse	g++/stl_algo.h	/^void __reverse(BidirectionalIterator first, BidirectionalIterator last, $/;"	f
__reverse	g++/stl_algo.h	/^void __reverse(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__rope_RopeBase	g++/stl_rope.h	/^struct __rope_RopeBase {$/;"	s
__rope_RopeConcatenation	g++/stl_rope.h	/^struct __rope_RopeConcatenation : public __rope_RopeBase<charT,Alloc> {$/;"	s
__rope_RopeFunction	g++/stl_rope.h	/^struct __rope_RopeFunction : public __rope_RopeBase<charT,Alloc> {$/;"	s
__rope_RopeLeaf	g++/stl_rope.h	/^struct __rope_RopeLeaf : public __rope_RopeBase<charT,Alloc> {$/;"	s
__rope_RopeSubstring	g++/stl_rope.h	/^    __rope_RopeSubstring(__rope_RopeBase<charT,Alloc> * b, size_t s, size_t l) :$/;"	f	struct:__rope_RopeSubstring
__rope_RopeSubstring	g++/stl_rope.h	/^struct __rope_RopeSubstring: public __rope_RopeFunction<charT,Alloc>,$/;"	s
__rope_charT_ptr_proxy	g++/stl_rope.h	/^    __rope_charT_ptr_proxy() {}$/;"	f	class:__rope_charT_ptr_proxy
__rope_charT_ptr_proxy	g++/stl_rope.h	/^    __rope_charT_ptr_proxy(charT * x) : root(0), pos(0) {$/;"	f	class:__rope_charT_ptr_proxy
__rope_charT_ptr_proxy	g++/stl_rope.h	/^    __rope_charT_ptr_proxy(const __rope_charT_ptr_proxy & x) :$/;"	f	class:__rope_charT_ptr_proxy
__rope_charT_ptr_proxy	g++/stl_rope.h	/^    __rope_charT_ptr_proxy(const __rope_charT_ref_proxy<charT,Alloc> & x) :$/;"	f	class:__rope_charT_ptr_proxy
__rope_charT_ptr_proxy	g++/stl_rope.h	/^class __rope_charT_ptr_proxy {$/;"	c
__rope_charT_ref_proxy	g++/stl_rope.h	/^    __rope_charT_ref_proxy(my_rope * r, size_t p) :$/;"	f	class:__rope_charT_ref_proxy
__rope_charT_ref_proxy	g++/stl_rope.h	/^    __rope_charT_ref_proxy(my_rope * r, size_t p,$/;"	f	class:__rope_charT_ref_proxy
__rope_charT_ref_proxy	g++/stl_rope.h	/^class __rope_charT_ref_proxy {$/;"	c
__rope_char_consumer	g++/stl_rope.h	/^class __rope_char_consumer {$/;"	c
__rope_const_iterator	g++/ropeimpl.h	/^inline __rope_const_iterator<charT, Alloc>::__rope_const_iterator$/;"	f	class:__rope_const_iterator
__rope_const_iterator	g++/stl_rope.h	/^    __rope_const_iterator() {};$/;"	f	class:__rope_const_iterator
__rope_const_iterator	g++/stl_rope.h	/^    __rope_const_iterator(const RopeBase * root, size_t pos):$/;"	f	class:__rope_const_iterator
__rope_const_iterator	g++/stl_rope.h	/^    __rope_const_iterator(const __rope_const_iterator & x) :$/;"	f	class:__rope_const_iterator
__rope_const_iterator	g++/stl_rope.h	/^    __rope_const_iterator(const rope<charT,Alloc> &r, size_t pos) :$/;"	f	class:__rope_const_iterator
__rope_const_iterator	g++/stl_rope.h	/^class __rope_const_iterator : public __rope_iterator_base<charT,Alloc> {$/;"	c
__rope_fill	g++/ropeimpl.h	/^inline void __rope_fill(ostream& o, size_t n)$/;"	f
__rope_find_char_char_consumer	g++/ropeimpl.h	/^	__rope_find_char_char_consumer(charT p) : pattern(p), count(0) {}$/;"	f	class:__rope_find_char_char_consumer
__rope_find_char_char_consumer	g++/ropeimpl.h	/^class __rope_find_char_char_consumer : public __rope_char_consumer<charT> {$/;"	c
__rope_flatten_char_consumer	g++/ropeimpl.h	/^	__rope_flatten_char_consumer(charT * buffer) {$/;"	f	class:__rope_flatten_char_consumer
__rope_flatten_char_consumer	g++/ropeimpl.h	/^class __rope_flatten_char_consumer : public __rope_char_consumer<charT> {$/;"	c
__rope_insert_char_consumer	g++/ropeimpl.h	/^	__rope_insert_char_consumer(insert_ostream & writer) : o(writer) {};$/;"	f	class:__rope_insert_char_consumer
__rope_insert_char_consumer	g++/ropeimpl.h	/^class __rope_insert_char_consumer : public __rope_char_consumer<charT> {$/;"	c
__rope_is_simple	g++/ropeimpl.h	/^inline bool __rope_is_simple(char *) { return true; }$/;"	f
__rope_is_simple	g++/ropeimpl.h	/^inline bool __rope_is_simple(wchar_t *) { return true; }$/;"	f
__rope_is_simple	g++/ropeimpl.h	/^template <class charT> inline bool __rope_is_simple(charT *) { return false; }$/;"	f
__rope_iterator	g++/ropeimpl.h	/^inline __rope_iterator<charT,Alloc>::__rope_iterator$/;"	f	class:__rope_iterator
__rope_iterator	g++/stl_rope.h	/^    __rope_iterator() {$/;"	f	class:__rope_iterator
__rope_iterator	g++/stl_rope.h	/^    __rope_iterator(const __rope_iterator & x) :$/;"	f	class:__rope_iterator
__rope_iterator	g++/stl_rope.h	/^    __rope_iterator(rope<charT,Alloc> * r, size_t pos):$/;"	f	class:__rope_iterator
__rope_iterator	g++/stl_rope.h	/^class __rope_iterator : public __rope_iterator_base<charT,Alloc> {$/;"	c
__rope_iterator_base	g++/stl_rope.h	/^    __rope_iterator_base() {}$/;"	f	class:__rope_iterator_base
__rope_iterator_base	g++/stl_rope.h	/^    __rope_iterator_base(RopeBase * root, size_t pos):$/;"	f	class:__rope_iterator_base
__rope_iterator_base	g++/stl_rope.h	/^    __rope_iterator_base(const __rope_iterator_base& x) {$/;"	f	class:__rope_iterator_base
__rope_iterator_base	g++/stl_rope.h	/^class __rope_iterator_base:$/;"	c
__rope_rotate	g++/ropeimpl.h	/^__rope_rotate(__rope_iterator<charT,Alloc> first,$/;"	f
__rope_self_destruct_ptr	g++/stl_rope.h	/^	__rope_self_destruct_ptr() : ptr(0) {};$/;"	f	struct:__rope_self_destruct_ptr
__rope_self_destruct_ptr	g++/stl_rope.h	/^	__rope_self_destruct_ptr() {};$/;"	f	struct:__rope_self_destruct_ptr
__rope_self_destruct_ptr	g++/stl_rope.h	/^    __rope_self_destruct_ptr(__rope_RopeBase<charT,Alloc> * p) : ptr(p) {}$/;"	f	struct:__rope_self_destruct_ptr
__rope_self_destruct_ptr	g++/stl_rope.h	/^  struct __rope_self_destruct_ptr {$/;"	s
__rotate	g++/stl_algo.h	/^void __rotate(BidirectionalIterator first, BidirectionalIterator middle,$/;"	f
__rotate	g++/stl_algo.h	/^void __rotate(ForwardIterator first, ForwardIterator middle,$/;"	f
__rotate	g++/stl_algo.h	/^void __rotate(RandomAccessIterator first, RandomAccessIterator middle,$/;"	f
__rotate_adaptive	g++/stl_algo.h	/^BidirectionalIterator1 __rotate_adaptive(BidirectionalIterator1 first,$/;"	f
__rotate_cycle	g++/stl_algo.h	/^void __rotate_cycle(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__savereg	include/va-i860.h	101;"	d
__search	g++/stl_algo.h	/^ForwardIterator1 __search(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f
__set_errno	g++/libioP.h	28;"	d
__set_type_class	include/va-alpha.h	/^  __set_type_class,$/;"	e	enum:__anon23
__set_type_class	include/va-alpha.h	/^  __set_type_class,$/;"	e	enum:__anon48
__set_type_class	include/va-arc.h	/^  __set_type_class,$/;"	e	enum:__va_type_classes
__set_type_class	include/va-i860.h	/^  __set_type_class,$/;"	e	enum:__anon27
__set_type_class	include/va-i860.h	/^  __set_type_class,$/;"	e	enum:__anon52
__set_type_class	include/va-m32r.h	/^  __set_type_class,$/;"	e	enum:__type_class
__set_type_class	include/va-mips.h	/^  __set_type_class,$/;"	e	enum:__anon17
__set_type_class	include/va-mips.h	/^  __set_type_class,$/;"	e	enum:__anon42
__set_type_class	include/va-sh.h	/^  __set_type_class,$/;"	e	enum:__va_type_classes
__set_type_class	include/va-sparc.h	/^  __set_type_class,$/;"	e	enum:__va_type_classes
__size_t	include/stddef.h	165;"	d
__size_t__	include/stddef.h	152;"	d
__slist_iterator	g++/stl_slist.h	/^	__slist_iterator() : __slist_iterator_base(0) {}$/;"	f	struct:std::__slist_iterator
__slist_iterator	g++/stl_slist.h	/^	__slist_iterator(const iterator& x) : __slist_iterator_base(x.node) {}$/;"	f	struct:std::__slist_iterator
__slist_iterator	g++/stl_slist.h	/^	__slist_iterator(list_node* x) : __slist_iterator_base(x) {}$/;"	f	struct:std::__slist_iterator
__slist_iterator	g++/stl_slist.h	/^struct __slist_iterator : public __slist_iterator_base$/;"	s	namespace:std
__slist_iterator_base	g++/stl_slist.h	/^	__slist_iterator_base(__slist_node_base* x) : node(x) {}$/;"	f	struct:std::__slist_iterator_base
__slist_iterator_base	g++/stl_slist.h	/^struct __slist_iterator_base$/;"	s	namespace:std
__slist_make_link	g++/stl_slist.h	/^__slist_make_link(__slist_node_base* prev_node, __slist_node_base* new_node)$/;"	f	namespace:std
__slist_node	g++/stl_slist.h	/^struct __slist_node : public __slist_node_base$/;"	s	namespace:std
__slist_node_base	g++/stl_slist.h	/^struct __slist_node_base$/;"	s	namespace:std
__slist_previous	g++/stl_slist.h	/^__slist_previous(__slist_node_base* head, const __slist_node_base* node)$/;"	f	namespace:std
__slist_previous	g++/stl_slist.h	/^__slist_previous(const __slist_node_base* head, const __slist_node_base* node)$/;"	f	namespace:std
__slist_reverse	g++/stl_slist.h	/^__slist_reverse(__slist_node_base* node)$/;"	f	namespace:std
__slist_size	g++/stl_slist.h	/^inline size_t __slist_size(__slist_node_base* node){$/;"	f	namespace:std
__slist_splice_after	g++/stl_slist.h	/^__slist_splice_after(__slist_node_base* pos, __slist_node_base* before_first, __slist_node_base* before_last)$/;"	f	namespace:std
__stable_partition_adaptive	g++/stl_algo.h	/^ForwardIterator __stable_partition_adaptive(ForwardIterator first,$/;"	f
__stable_partition_aux	g++/stl_algo.h	/^inline ForwardIterator __stable_partition_aux(ForwardIterator first,$/;"	f
__stable_sort_adaptive	g++/stl_algo.h	/^void __stable_sort_adaptive(RandomAccessIterator first, $/;"	f
__stable_sort_aux	g++/stl_algo.h	/^inline void __stable_sort_aux(RandomAccessIterator first,$/;"	f
__stack	include/va-spur.h	/^    char *__stack;$/;"	m	struct:__anon21
__stack	include/va-spur.h	/^    char *__stack;$/;"	m	struct:__anon46
__stackp	include/va-pyr.h	/^      __voidptr __stackp,__regp,__count;$/;"	m	struct:__va_regs
__stl_assert	g++/stl_config.h	250;"	d
__stl_assert	g++/stl_config.h	254;"	d
__stl_chunk_size	g++/stl_algo.h	/^const int __stl_chunk_size = 7;$/;"	v
__stl_hash_string	g++/stl_hash_fun.h	/^inline size_t __stl_hash_string(const char* s)$/;"	f
__stl_next_prime	g++/stl_hashtable.h	/^inline unsigned long __stl_next_prime(unsigned long n)$/;"	f
__stl_num_primes	g++/stl_hashtable.h	/^static const int __stl_num_primes = 28;$/;"	v
__stl_prime_list	g++/stl_hashtable.h	/^static const unsigned long __stl_prime_list[__stl_num_primes] =$/;"	v
__stl_threshold	g++/stl_algo.h	/^const int __stl_threshold = 16;$/;"	v
__string_type_class	include/va-alpha.h	/^  __string_type_class,$/;"	e	enum:__anon23
__string_type_class	include/va-alpha.h	/^  __string_type_class,$/;"	e	enum:__anon48
__string_type_class	include/va-arc.h	/^  __string_type_class,$/;"	e	enum:__va_type_classes
__string_type_class	include/va-i860.h	/^  __string_type_class,$/;"	e	enum:__anon27
__string_type_class	include/va-i860.h	/^  __string_type_class,$/;"	e	enum:__anon52
__string_type_class	include/va-m32r.h	/^  __string_type_class,$/;"	e	enum:__type_class
__string_type_class	include/va-mips.h	/^  __string_type_class,$/;"	e	enum:__anon17
__string_type_class	include/va-mips.h	/^  __string_type_class,$/;"	e	enum:__anon42
__string_type_class	include/va-sh.h	/^  __string_type_class,$/;"	e	enum:__va_type_classes
__string_type_class	include/va-sparc.h	/^  __string_type_class,$/;"	e	enum:__va_type_classes
__test_and_set	g++/stl_alloc.h	473;"	d
__true_type	g++/type_traits.h	/^struct __true_type {};$/;"	s
__type_class	include/va-m32r.h	/^enum __type_class$/;"	g
__type_traits	g++/type_traits.h	/^struct __type_traits $/;"	s
__type_traits	g++/type_traits.h	/^struct __type_traits<T*> $/;"	s
__type_traits	g++/type_traits.h	/^struct __type_traits<char*> {$/;"	s
__type_traits	g++/type_traits.h	/^struct __type_traits<char> $/;"	s
__type_traits	g++/type_traits.h	/^struct __type_traits<double> $/;"	s
__type_traits	g++/type_traits.h	/^struct __type_traits<float> $/;"	s
__type_traits	g++/type_traits.h	/^struct __type_traits<int> $/;"	s
__type_traits	g++/type_traits.h	/^struct __type_traits<long> $/;"	s
__type_traits	g++/type_traits.h	/^struct __type_traits<short> $/;"	s
__type_traits	g++/type_traits.h	/^struct __type_traits<signed char*> {$/;"	s
__type_traits	g++/type_traits.h	/^struct __type_traits<signed char> $/;"	s
__type_traits	g++/type_traits.h	/^struct __type_traits<unsigned char*> {$/;"	s
__type_traits	g++/type_traits.h	/^struct __type_traits<unsigned char> $/;"	s
__type_traits	g++/type_traits.h	/^struct __type_traits<unsigned int> $/;"	s
__type_traits	g++/type_traits.h	/^struct __type_traits<unsigned long> $/;"	s
__type_traits	g++/type_traits.h	/^struct __type_traits<unsigned short> $/;"	s
__unguarded_insertion_sort	g++/stl_algo.h	/^inline void __unguarded_insertion_sort(RandomAccessIterator first, $/;"	f
__unguarded_insertion_sort_aux	g++/stl_algo.h	/^void __unguarded_insertion_sort_aux(RandomAccessIterator first, $/;"	f
__unguarded_linear_insert	g++/stl_algo.h	/^void __unguarded_linear_insert(RandomAccessIterator last, T value) {$/;"	f
__unguarded_linear_insert	g++/stl_algo.h	/^void __unguarded_linear_insert(RandomAccessIterator last, T value, $/;"	f
__unguarded_partition	g++/stl_algo.h	/^RandomAccessIterator __unguarded_partition(RandomAccessIterator first, $/;"	f
__uninitialized_copy	g++/stl_uninitialized.h	/^__uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result, T*) $/;"	f	namespace:std
__uninitialized_copy_aux	g++/stl_uninitialized.h	/^__uninitialized_copy_aux(InputIterator first, InputIterator last, ForwardIterator result, __false_type) $/;"	f	namespace:std
__uninitialized_copy_aux	g++/stl_uninitialized.h	/^__uninitialized_copy_aux(InputIterator first, InputIterator last,ForwardIterator result, __true_type) $/;"	f	namespace:std
__uninitialized_copy_copy	g++/stl_uninitialized.h	/^__uninitialized_copy_copy(InputIterator1 first1, InputIterator1 last1,$/;"	f	namespace:std
__uninitialized_copy_fill	g++/stl_uninitialized.h	/^__uninitialized_copy_fill(InputIterator first1, InputIterator last1,$/;"	f	namespace:std
__uninitialized_copy_n	g++/stl_uninitialized.h	/^__uninitialized_copy_n(InputIterator first, Size count, ForwardIterator result, input_iterator_tag) $/;"	f	namespace:std
__uninitialized_copy_n	g++/stl_uninitialized.h	/^__uninitialized_copy_n(RandomAccessIterator first, Size count, ForwardIterator result,$/;"	f	namespace:std
__uninitialized_fill	g++/stl_uninitialized.h	/^__uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x, T1*) $/;"	f	namespace:std
__uninitialized_fill_aux	g++/stl_uninitialized.h	/^__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, const T& x, __true_type)$/;"	f	namespace:std
__uninitialized_fill_aux	g++/stl_uninitialized.h	/^void __uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, const T& x, __false_type)$/;"	f	namespace:std
__uninitialized_fill_copy	g++/stl_uninitialized.h	/^__uninitialized_fill_copy(ForwardIterator result, ForwardIterator mid,$/;"	f	namespace:std
__uninitialized_fill_n	g++/stl_uninitialized.h	/^__uninitialized_fill_n(ForwardIterator first, Size n, const T& x, T1*) $/;"	f	namespace:std
__uninitialized_fill_n_aux	g++/stl_uninitialized.h	/^__uninitialized_fill_n_aux(ForwardIterator first, Size n, const T& x, __false_type) $/;"	f	namespace:std
__uninitialized_fill_n_aux	g++/stl_uninitialized.h	/^__uninitialized_fill_n_aux(ForwardIterator first, Size n, const T& x, __true_type) $/;"	f	namespace:std
__union_type_class	include/va-alpha.h	/^  __union_type_class,$/;"	e	enum:__anon23
__union_type_class	include/va-alpha.h	/^  __union_type_class,$/;"	e	enum:__anon48
__union_type_class	include/va-arc.h	/^  __union_type_class,$/;"	e	enum:__va_type_classes
__union_type_class	include/va-i860.h	/^  __union_type_class,$/;"	e	enum:__anon27
__union_type_class	include/va-i860.h	/^  __union_type_class,$/;"	e	enum:__anon52
__union_type_class	include/va-m32r.h	/^  __union_type_class,$/;"	e	enum:__type_class
__union_type_class	include/va-mips.h	/^  __union_type_class,$/;"	e	enum:__anon17
__union_type_class	include/va-mips.h	/^  __union_type_class,$/;"	e	enum:__anon42
__union_type_class	include/va-sh.h	/^  __union_type_class,$/;"	e	enum:__va_type_classes
__union_type_class	include/va-sparc.h	/^  __union_type_class,$/;"	e	enum:__va_type_classes
__unique_copy	g++/stl_algo.h	/^ForwardIterator __unique_copy(InputIterator first, InputIterator last,$/;"	f
__unique_copy	g++/stl_algo.h	/^OutputIterator __unique_copy(InputIterator first, InputIterator last,$/;"	f
__unique_copy	g++/stl_algo.h	/^inline OutputIterator __unique_copy(InputIterator first, InputIterator last,$/;"	f
__unlock	g++/stl_alloc.h	/^__default_alloc_template<threads, inst>::__unlock(volatile unsigned long *lock)$/;"	f	class:__default_alloc_template
__upper_bound	g++/stl_algo.h	/^ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,$/;"	f
__upper_bound	g++/stl_algo.h	/^RandomAccessIterator __upper_bound(RandomAccessIterator first,$/;"	f
__va_aggregate_p	include/va-ppc.h	115;"	d
__va_align	include/va-ppc.h	218;"	d
__va_ap	include/va-clipper.h	/^  int __va_ap;				\/* pointer to stack args *\/$/;"	m	struct:__anon15
__va_ap	include/va-clipper.h	/^  int __va_ap;				\/* pointer to stack args *\/$/;"	m	struct:__anon40
__va_arg	include/va-m88k.h	/^  int  __va_arg;		\/* argument number *\/$/;"	m	struct:__anon18
__va_arg	include/va-m88k.h	/^  int  __va_arg;		\/* argument number *\/$/;"	m	struct:__anon43
__va_arg_sh1	include/va-sh.h	139;"	d
__va_buf	include/va-pyr.h	/^typedef __va_regs __va_buf;$/;"	t
__va_buf	include/va-pyr.h	/^typedef __voidptr(*__va_buf);$/;"	t
__va_by_reference_p	include/va-m32r.h	63;"	d
__va_copy	include/stdarg.h	114;"	d
__va_copy	include/va-alpha.h	128;"	d
__va_copy	include/va-clipper.h	58;"	d
__va_copy	include/va-h8300.h	54;"	d
__va_copy	include/va-i860.h	211;"	d
__va_copy	include/va-i960.h	76;"	d
__va_copy	include/va-m88k.h	85;"	d
__va_copy	include/va-mips.h	275;"	d
__va_copy	include/va-pa.h	50;"	d
__va_copy	include/va-ppc.h	174;"	d
__va_copy	include/va-ppc.h	230;"	d
__va_copy	include/va-sh.h	197;"	d
__va_copy	include/va-sparc.h	163;"	d
__va_copy	include/va-spur.h	64;"	d
__va_copy	include/varargs.h	133;"	d
__va_ellipsis	include/va-arc.h	18;"	d
__va_ellipsis	include/va-arc.h	20;"	d
__va_ellipsis	include/va-h8300.h	18;"	d
__va_ellipsis	include/va-h8300.h	20;"	d
__va_ellipsis	include/va-i960.h	20;"	d
__va_ellipsis	include/va-i960.h	22;"	d
__va_ellipsis	include/va-mips.h	68;"	d
__va_ellipsis	include/va-mips.h	70;"	d
__va_ellipsis	include/va-mn10200.h	13;"	d
__va_ellipsis	include/va-mn10300.h	12;"	d
__va_ellipsis	include/va-pa.h	14;"	d
__va_ellipsis	include/va-pa.h	18;"	d
__va_ellipsis	include/va-pyr.h	83;"	d
__va_ellipsis	include/va-pyr.h	85;"	d
__va_ellipsis	include/va-spur.h	15;"	d
__va_ellipsis	include/va-spur.h	17;"	d
__va_ellipsis	include/va-v850.h	16;"	d
__va_ellipsis	include/varargs.h	83;"	d
__va_ellipsis	include/varargs.h	85;"	d
__va_float_p	include/va-ppc.h	107;"	d
__va_float_p	include/va-ppc.h	109;"	d
__va_freg	include/va-sh.h	/^typedef double __va_freg;$/;"	t
__va_fregno	include/va-ppc.h	72;"	d
__va_greg	include/va-sh.h	/^typedef long __va_greg;$/;"	t
__va_list	include/va-clipper.h	19;"	d
__va_list	include/va-ppc.h	/^} __va_list[1], __gnuc_va_list[1];$/;"	t	typeref:struct:__va_list_tag
__va_list_tag	include/va-ppc.h	/^typedef struct __va_list_tag {$/;"	s
__va_longlong_p	include/va-ppc.h	112;"	d
__va_nargs	include/va-ppc.h	73;"	d
__va_next_addr	include/va-mips.h	176;"	d
__va_next_addr	include/va-mips.h	182;"	d
__va_next_addr	include/va-mips.h	197;"	d
__va_next_addr	include/va-mips.h	200;"	d
__va_next_fp	include/va-sh.h	/^  __va_freg * __va_next_fp;		\/* next available fp register *\/$/;"	m	struct:__anon20
__va_next_fp	include/va-sh.h	/^  __va_freg * __va_next_fp;		\/* next available fp register *\/$/;"	m	struct:__anon45
__va_next_fp_limit	include/va-sh.h	/^  __va_freg * __va_next_fp_limit;	\/* last available fp register *\/$/;"	m	struct:__anon20
__va_next_fp_limit	include/va-sh.h	/^  __va_freg * __va_next_fp_limit;	\/* last available fp register *\/$/;"	m	struct:__anon45
__va_next_o	include/va-sh.h	/^  __va_greg * __va_next_o;		\/* next available register *\/$/;"	m	struct:__anon20
__va_next_o	include/va-sh.h	/^  __va_greg * __va_next_o;		\/* next available register *\/$/;"	m	struct:__anon45
__va_next_o_limit	include/va-sh.h	/^  __va_greg * __va_next_o_limit;	\/* past last available register *\/$/;"	m	struct:__anon20
__va_next_o_limit	include/va-sh.h	/^  __va_greg * __va_next_o_limit;	\/* past last available register *\/$/;"	m	struct:__anon45
__va_next_stack	include/va-sh.h	/^  __va_greg * __va_next_stack;		\/* next extended word on stack *\/$/;"	m	struct:__anon20
__va_next_stack	include/va-sh.h	/^  __va_greg * __va_next_stack;		\/* next extended word on stack *\/$/;"	m	struct:__anon45
__va_num	include/va-clipper.h	/^  int __va_num;				\/* number of args processed *\/$/;"	m	struct:__anon15
__va_num	include/va-clipper.h	/^  int __va_num;				\/* number of args processed *\/$/;"	m	struct:__anon40
__va_orig_nargs	include/va-ppc.h	74;"	d
__va_overflow	include/va-ppc.h	15;"	d
__va_overflow	include/va-ppc.h	34;"	d
__va_reg	include/va-clipper.h	/^  void *__va_reg[4];			\/* pointer to r0,f0,r1,f1 *\/$/;"	m	struct:__anon15
__va_reg	include/va-clipper.h	/^  void *__va_reg[4];			\/* pointer to r0,f0,r1,f1 *\/$/;"	m	struct:__anon40
__va_reg	include/va-m88k.h	/^  int *__va_reg;		\/* start of args passed in regs *\/$/;"	m	struct:__anon18
__va_reg	include/va-m88k.h	/^  int *__va_reg;		\/* start of args passed in regs *\/$/;"	m	struct:__anon43
__va_reg_p	include/va-m88k.h	56;"	d
__va_reg_p	include/va-m88k.h	65;"	d
__va_reg_size	include/va-mips.h	82;"	d
__va_reg_size	include/va-mips.h	84;"	d
__va_regs	include/va-pyr.h	/^  } __va_regs;$/;"	t	typeref:struct:__va_regs
__va_regs	include/va-pyr.h	/^typedef struct __va_regs {$/;"	s
__va_regsave_t	include/va-ppc.h	/^} __va_regsave_t;$/;"	t	typeref:struct:__anon19
__va_regsave_t	include/va-ppc.h	/^} __va_regsave_t;$/;"	t	typeref:struct:__anon44
__va_round	include/va-clipper.h	43;"	d
__va_rounded_size	include/stdarg.h	82;"	d
__va_rounded_size	include/stdarg.h	85;"	d
__va_rounded_size	include/va-arc.h	82;"	d
__va_rounded_size	include/va-h8300.h	24;"	d
__va_rounded_size	include/va-h8300.h	27;"	d
__va_rounded_size	include/va-m32r.h	15;"	d
__va_rounded_size	include/va-mips.h	74;"	d
__va_rounded_size	include/va-mips.h	77;"	d
__va_rounded_size	include/va-mn10200.h	25;"	d
__va_rounded_size	include/va-mn10300.h	24;"	d
__va_rounded_size	include/va-ppc.h	217;"	d
__va_rounded_size	include/va-sparc.h	136;"	d
__va_rounded_size	include/va-v850.h	23;"	d
__va_rounded_size	include/varargs.h	111;"	d
__va_rounded_size	include/varargs.h	114;"	d
__va_rounded_size	include/varargs.h	75;"	d
__va_saved_regs	include/va-i860.h	/^} __va_saved_regs;$/;"	t	typeref:struct:__anon25
__va_saved_regs	include/va-i860.h	/^} __va_saved_regs;$/;"	t	typeref:struct:__anon50
__va_size	include/va-m88k.h	55;"	d
__va_size	include/va-m88k.h	69;"	d
__va_size	include/va-ppc.h	116;"	d
__va_start_common	include/va-ppc.h	193;"	d
__va_start_common	include/va-ppc.h	77;"	d
__va_stk	include/va-m88k.h	/^  int *__va_stk;		\/* start of args passed on stack *\/$/;"	m	struct:__anon18
__va_stk	include/va-m88k.h	/^  int *__va_stk;		\/* start of args passed on stack *\/$/;"	m	struct:__anon43
__va_struct	include/va-spur.h	/^struct __va_struct { char __regs[20]; };$/;"	s
__va_tsize	include/va-alpha.h	108;"	d
__va_type_classes	include/va-arc.h	/^enum __va_type_classes {$/;"	g
__va_type_classes	include/va-sh.h	/^enum __va_type_classes {$/;"	g
__va_type_classes	include/va-sparc.h	/^enum __va_type_classes {$/;"	g
__va_varargs_offset	include/va-ppc.h	75;"	d
__va_words	include/va-ppc.h	71;"	d
__vali	include/va-i960.h	28;"	d
__void_type_class	include/va-alpha.h	/^  __void_type_class,$/;"	e	enum:__anon23
__void_type_class	include/va-alpha.h	/^  __void_type_class,$/;"	e	enum:__anon48
__void_type_class	include/va-arc.h	/^  __void_type_class,$/;"	e	enum:__va_type_classes
__void_type_class	include/va-i860.h	/^  __void_type_class,$/;"	e	enum:__anon27
__void_type_class	include/va-i860.h	/^  __void_type_class,$/;"	e	enum:__anon52
__void_type_class	include/va-m32r.h	/^  __void_type_class,$/;"	e	enum:__type_class
__void_type_class	include/va-mips.h	/^  __void_type_class,$/;"	e	enum:__anon17
__void_type_class	include/va-mips.h	/^  __void_type_class,$/;"	e	enum:__anon42
__void_type_class	include/va-sh.h	/^  __void_type_class,$/;"	e	enum:__va_type_classes
__void_type_class	include/va-sparc.h	/^  __void_type_class,$/;"	e	enum:__va_type_classes
__voidptr	include/va-pyr.h	/^typedef void *__voidptr;$/;"	t
__vpad	include/va-i960.h	30;"	d
__vsiz	include/va-i960.h	26;"	d
__wchar_t__	include/stddef.h	214;"	d
_a	g++/iomanip.h	/^    TP _a;$/;"	m	class:imanip
_a	g++/iomanip.h	/^    TP _a;$/;"	m	class:omanip
_a	g++/iomanip.h	/^    TP _a;$/;"	m	class:smanip
_a	g++/iomanip.h	/^    imanip(istream& (*f)(istream&, TP), TP a) : _f(f), _a(a) {}$/;"	f	class:imanip
_a	g++/iomanip.h	/^    omanip(ostream& (*f)(ostream&, TP), TP a) : _f(f), _a(a) {}$/;"	f	class:omanip
_a	g++/iomanip.h	/^    smanip(ios& (*f)(ios&, TP), TP a) : _f(f), _a(a) {}$/;"	f	class:smanip
_allocate_buffer	g++/strfile.h	/^  _IO_alloc_type _allocate_buffer;$/;"	m	struct:_IO_str_fields
_arrays	g++/streambuf.h	/^    void *_arrays; \/* Support for ios::iword and ios::pword. *\/$/;"	m	struct:_ios_fields
_bad	g++/streambuf.h	/^    _bad = _IOS_BAD };$/;"	e	enum:state_value
_bfd	bfd.h	/^struct _bfd $/;"	s
_bfd_canonicalize_dynamic_reloc	bfd.h	/^  long  (*_bfd_canonicalize_dynamic_reloc)$/;"	m	struct:bfd_target
_bfd_canonicalize_dynamic_symtab	bfd.h	/^  long  (*_bfd_canonicalize_dynamic_symtab)$/;"	m	struct:bfd_target
_bfd_canonicalize_reloc	bfd.h	/^  long  (*_bfd_canonicalize_reloc) PARAMS ((bfd *, sec_ptr, arelent **,$/;"	m	struct:bfd_target
_bfd_canonicalize_symtab	bfd.h	/^  long  (*_bfd_canonicalize_symtab) PARAMS ((bfd *,$/;"	m	struct:bfd_target
_bfd_check_format	bfd.h	/^  const struct bfd_target *(*_bfd_check_format[bfd_type_end]) PARAMS ((bfd *));$/;"	m	struct:bfd_target	typeref:struct:bfd_target::_bfd_check_format
_bfd_construct_extended_name_table	bfd.h	/^  boolean  (*_bfd_construct_extended_name_table)$/;"	m	struct:bfd_target
_bfd_copy_private_bfd_data	bfd.h	/^  boolean       (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));$/;"	m	struct:bfd_target
_bfd_copy_private_section_data	bfd.h	/^  boolean       (*_bfd_copy_private_section_data) PARAMS ((bfd *, sec_ptr,$/;"	m	struct:bfd_target
_bfd_copy_private_symbol_data	bfd.h	/^  boolean       (*_bfd_copy_private_symbol_data) PARAMS ((bfd *, asymbol *,$/;"	m	struct:bfd_target
_bfd_final_link	bfd.h	/^  boolean (*_bfd_final_link) PARAMS ((bfd *, struct bfd_link_info *));$/;"	m	struct:bfd_target
_bfd_find_nearest_line	bfd.h	/^  boolean    (*_bfd_find_nearest_line) PARAMS ((bfd *abfd,$/;"	m	struct:bfd_target
_bfd_free_cached_info	bfd.h	/^  boolean (*_bfd_free_cached_info) PARAMS ((bfd *));$/;"	m	struct:bfd_target
_bfd_gc_sections	bfd.h	/^  boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));$/;"	m	struct:bfd_target
_bfd_get_dynamic_reloc_upper_bound	bfd.h	/^  long  (*_bfd_get_dynamic_reloc_upper_bound) PARAMS ((bfd *));$/;"	m	struct:bfd_target
_bfd_get_dynamic_symtab_upper_bound	bfd.h	/^  long  (*_bfd_get_dynamic_symtab_upper_bound) PARAMS ((bfd *));$/;"	m	struct:bfd_target
_bfd_get_elt_at_index	bfd.h	/^  bfd *    (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));$/;"	m	struct:bfd_target
_bfd_get_relocated_section_contents	bfd.h	/^  bfd_byte * (*_bfd_get_relocated_section_contents) PARAMS ((bfd *,$/;"	m	struct:bfd_target
_bfd_get_section_contents	bfd.h	/^  boolean       (*_bfd_get_section_contents) PARAMS ((bfd *, sec_ptr, PTR, $/;"	m	struct:bfd_target
_bfd_get_section_contents_in_window	bfd.h	/^  boolean       (*_bfd_get_section_contents_in_window)$/;"	m	struct:bfd_target
_bfd_get_symbol_info	bfd.h	/^  void          (*_bfd_get_symbol_info) PARAMS ((bfd *,$/;"	m	struct:bfd_target
_bfd_get_symtab_upper_bound	bfd.h	/^  long  (*_bfd_get_symtab_upper_bound) PARAMS ((bfd *));$/;"	m	struct:bfd_target
_bfd_int64_high	bfd.h	151;"	d
_bfd_int64_low	bfd.h	150;"	d
_bfd_is_local_label_name	bfd.h	/^  boolean       (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));$/;"	m	struct:bfd_target
_bfd_link_add_symbols	bfd.h	/^  boolean (*_bfd_link_add_symbols) PARAMS ((bfd *, struct bfd_link_info *));$/;"	m	struct:bfd_target
_bfd_link_hash_table_create	bfd.h	/^  struct bfd_link_hash_table *(*_bfd_link_hash_table_create) PARAMS ((bfd *));$/;"	m	struct:bfd_target	typeref:struct:bfd_target::_bfd_link_hash_table_create
_bfd_link_info	bfd.h	/^typedef struct bfd_link_info _bfd_link_info;$/;"	t	typeref:struct:bfd_link_info
_bfd_link_split_section	bfd.h	/^  boolean (*_bfd_link_split_section) PARAMS ((bfd *, struct sec *));$/;"	m	struct:bfd_target
_bfd_make_debug_symbol	bfd.h	/^  asymbol *  (*_bfd_make_debug_symbol) PARAMS (($/;"	m	struct:bfd_target
_bfd_make_empty_symbol	bfd.h	/^                (*_bfd_make_empty_symbol) PARAMS ((bfd *));$/;"	m	struct:bfd_target	typeref:struct:bfd_target::_bfd_make_empty_symbol
_bfd_merge_private_bfd_data	bfd.h	/^  boolean       (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));$/;"	m	struct:bfd_target
_bfd_print_private_bfd_data	bfd.h	/^  boolean       (*_bfd_print_private_bfd_data) PARAMS ((bfd *, PTR));$/;"	m	struct:bfd_target
_bfd_print_symbol	bfd.h	/^  void          (*_bfd_print_symbol) PARAMS ((bfd *, PTR,$/;"	m	struct:bfd_target
_bfd_read_ar_hdr_fn	bfd.h	/^  PTR (*_bfd_read_ar_hdr_fn) PARAMS ((bfd *));$/;"	m	struct:bfd_target
_bfd_relax_section	bfd.h	/^  boolean    (*_bfd_relax_section) PARAMS ((bfd *, struct sec *,$/;"	m	struct:bfd_target
_bfd_set_arch_mach	bfd.h	/^  boolean    (*_bfd_set_arch_mach) PARAMS ((bfd *, enum bfd_architecture,$/;"	m	struct:bfd_target
_bfd_set_format	bfd.h	/^  boolean             (*_bfd_set_format[bfd_type_end]) PARAMS ((bfd *));$/;"	m	struct:bfd_target
_bfd_set_private_flags	bfd.h	/^  boolean       (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));$/;"	m	struct:bfd_target
_bfd_set_section_contents	bfd.h	/^  boolean       (*_bfd_set_section_contents) PARAMS ((bfd *, sec_ptr, PTR,$/;"	m	struct:bfd_target
_bfd_sizeof_headers	bfd.h	/^  int        (*_bfd_sizeof_headers) PARAMS ((bfd *, boolean));$/;"	m	struct:bfd_target
_bfd_slurp_armap	bfd.h	/^  boolean  (*_bfd_slurp_armap) PARAMS ((bfd *));$/;"	m	struct:bfd_target
_bfd_slurp_extended_name_table	bfd.h	/^  boolean  (*_bfd_slurp_extended_name_table) PARAMS ((bfd *));$/;"	m	struct:bfd_target
_bfd_stat_arch_elt	bfd.h	/^  int      (*_bfd_stat_arch_elt) PARAMS ((bfd *, struct stat *));$/;"	m	struct:bfd_target
_bfd_truncate_arname	bfd.h	/^  void     (*_bfd_truncate_arname) PARAMS ((bfd *, CONST char *, char *));$/;"	m	struct:bfd_target
_bfd_update_armap_timestamp	bfd.h	/^  boolean  (*_bfd_update_armap_timestamp) PARAMS ((bfd *));$/;"	m	struct:bfd_target
_bfd_window	bfd.h	/^typedef struct _bfd_window {$/;"	s
_bfd_write_contents	bfd.h	/^  boolean             (*_bfd_write_contents[bfd_type_end]) PARAMS ((bfd *));$/;"	m	struct:bfd_target
_blksize	g++/libio.h	/^  int _blksize;$/;"	m	struct:_IO_FILE
_chain	g++/libio.h	/^  struct _IO_FILE *_chain;$/;"	m	struct:_IO_FILE	typeref:struct:_IO_FILE::_IO_FILE
_close_and_cleanup	bfd.h	/^  boolean       (*_close_and_cleanup) PARAMS ((bfd *));$/;"	m	struct:bfd_target
_cooked_size	bfd.h	/^   bfd_size_type _cooked_size;$/;"	m	struct:sec
_core_file_failing_command	bfd.h	/^  char *   (*_core_file_failing_command) PARAMS ((bfd *));$/;"	m	struct:bfd_target
_core_file_failing_signal	bfd.h	/^  int      (*_core_file_failing_signal) PARAMS ((bfd *));$/;"	m	struct:bfd_target
_core_file_matches_executable_p	bfd.h	/^  boolean  (*_core_file_matches_executable_p) PARAMS ((bfd *, bfd *));$/;"	m	struct:bfd_target
_cur_column	g++/libio.h	/^  unsigned short _cur_column;$/;"	m	struct:_IO_FILE
_delete_flags	g++/indstream.h	/^    int _delete_flags;$/;"	m	class:indirectbuf
_dummy_first_bfd_reloc_code_real	bfd.h	/^  _dummy_first_bfd_reloc_code_real,$/;"	e	enum:bfd_reloc_code_real
_eof	g++/streambuf.h	/^    _eof = _IOS_EOF,$/;"	e	enum:state_value
_exceptions	g++/streambuf.h	/^    __iostate _exceptions;$/;"	m	struct:_ios_fields
_f	g++/iomanip.h	/^    ios& (*_f)(ios&, TP);$/;"	m	class:sapp
_f	g++/iomanip.h	/^    ios& (*_f)(ios&, TP);$/;"	m	class:smanip
_f	g++/iomanip.h	/^    istream& (*_f)(istream&, TP);$/;"	m	class:iapp
_f	g++/iomanip.h	/^    istream& (*_f)(istream&, TP);$/;"	m	class:imanip
_f	g++/iomanip.h	/^    ostream& (*_f)(ostream&, TP);$/;"	m	class:oapp
_f	g++/iomanip.h	/^    ostream& (*_f)(ostream&, TP);$/;"	m	class:omanip
_f	g++/strfile.h	/^  struct _IO_FILE _f;$/;"	m	struct:_IO_streambuf	typeref:struct:_IO_streambuf::_IO_FILE
_fail	g++/streambuf.h	/^    _fail = _IOS_FAIL,$/;"	e	enum:state_value
_file	g++/stdiostream.h	/^    FILE *_file;$/;"	m	class:stdiobuf
_file	g++/stdiostream.h	/^  stdiobuf _file;$/;"	m	class:istdiostream
_file	g++/stdiostream.h	/^  stdiobuf _file;$/;"	m	class:ostdiostream
_fileno	g++/libio.h	/^  int _fileno;$/;"	m	struct:_IO_FILE
_fill	g++/streambuf.h	/^    _IO_wchar_t _fill;$/;"	m	struct:_ios_fields
_find	g++/std/bastring.cc	/^_find(const charT* ptr, charT c, size_type xpos, size_type len)$/;"	f	class:basic_string
_flags	g++/libio.h	/^  int _flags;		\/* High-order word is _IO_MAGIC; rest is flags. *\/$/;"	m	struct:_IO_FILE
_flags	g++/streambuf.h	/^    __fmtflags _flags;$/;"	m	struct:_ios_fields
_free_buffer	g++/strfile.h	/^  _IO_free_type _free_buffer;$/;"	m	struct:_IO_str_fields
_gap_start	g++/editbuf.h	/^    buf_char *_gap_start;$/;"	m	struct:edit_buffer
_gcount	g++/iostream.h	/^    _IO_size_t _gcount;$/;"	m	class:istream
_get_lineno	bfd.h	/^  alent *    (*_get_lineno) PARAMS ((bfd *, struct symbol_cache_entry *));$/;"	m	struct:bfd_target
_get_reloc_upper_bound	bfd.h	/^  long  (*_get_reloc_upper_bound) PARAMS ((bfd *, sec_ptr));$/;"	m	struct:bfd_target
_get_stream	g++/indstream.h	/^    streambuf *_get_stream;  \/\/ Optional cache for get_stream().$/;"	m	class:indirectbuf
_good	g++/streambuf.h	/^    _good = _IOS_GOOD,$/;"	e	enum:state_value
_insert_after	g++/stl_slist.h	/^	list_node* _insert_after(list_node_base* pos, const value_type& x) {$/;"	f	class:std::slist
_insert_after_fill	g++/stl_slist.h	/^	void _insert_after_fill(list_node_base* pos, size_type n, const value_type& x) {$/;"	f	class:std::slist
_insert_after_range	g++/stl_slist.h	/^	void _insert_after_range(list_node_base* pos, InIter first, InIter last) {$/;"	f	class:std::slist
_inserting	g++/editbuf.h	/^    int _inserting;$/;"	m	struct:edit_streambuf
_ios_fields	g++/streambuf.h	/^struct _ios_fields$/;"	s
_keymap_entry	readline/keymaps.h	/^typedef struct _keymap_entry {$/;"	s
_line_length	g++/parsestream.h	/^    long _line_length;$/;"	m	class:parsebuf
_list_all	g++/streambuf.h	/^    static streambuf* _list_all; \/* List of open streambufs. *\/$/;"	m	struct:streambuf
_lock	g++/libio.h	/^  _IO_LOCK_T _lock;$/;"	m	struct:_IO_FILE
_markers	g++/libio.h	/^  struct _IO_marker *_markers;$/;"	m	struct:_IO_FILE	typeref:struct:_IO_FILE::_IO_marker
_minisymbol_to_symbol	bfd.h	/^  asymbol *(*_minisymbol_to_symbol) PARAMS ((bfd *, boolean, const PTR,$/;"	m	struct:bfd_target
_mode	g++/editbuf.h	/^    short _mode;$/;"	m	struct:edit_streambuf
_new_section_hook	bfd.h	/^  boolean       (*_new_section_hook) PARAMS ((bfd *, sec_ptr));$/;"	m	struct:bfd_target
_next	g++/libio.h	/^  struct _IO_marker *_next;$/;"	m	struct:_IO_marker	typeref:struct:_IO_marker::_IO_marker
_next	g++/procbuf.h	/^    procbuf *_next;$/;"	m	class:procbuf
_offset	g++/libio.h	/^  _IO_off64_t _offset;$/;"	m	struct:_IO_FILE
_offset	g++/libio.h	/^  _IO_off_t _offset;$/;"	m	struct:_IO_FILE
_old_offset	g++/libio.h	/^  _IO_off_t _old_offset;$/;"	m	struct:_IO_FILE
_pid	g++/procbuf.h	/^    _IO_pid_t _pid;$/;"	m	class:procbuf
_pos	g++/editbuf.h	/^    mark_pointer _pos;$/;"	m	struct:edit_mark
_pos	g++/libio.h	/^  int _pos;$/;"	m	struct:_IO_marker
_precision	g++/streambuf.h	/^    int _precision;$/;"	m	struct:_ios_fields
_put_stream	g++/indstream.h	/^    streambuf *_put_stream;  \/\/ Optional cache for put_stream().$/;"	m	class:indirectbuf
_raw_size	bfd.h	/^   bfd_size_type _raw_size;$/;"	m	struct:sec
_read_minisymbols	bfd.h	/^  long  (*_read_minisymbols) PARAMS ((bfd *, boolean, PTR *,$/;"	m	struct:bfd_target
_s	g++/strfile.h	/^  struct _IO_str_fields _s;$/;"	m	struct:_IO_strfile_	typeref:struct:_IO_strfile_::_IO_str_fields
_s	g++/strstream.h	/^  struct _IO_str_fields _s;$/;"	m	class:strstreambuf	typeref:struct:strstreambuf::_IO_str_fields
_sbf	g++/strfile.h	/^  struct _IO_streambuf _sbf;$/;"	m	struct:_IO_strfile_	typeref:struct:_IO_strfile_::_IO_streambuf
_sbuf	g++/libio.h	/^  struct _IO_FILE *_sbuf;$/;"	m	struct:_IO_marker	typeref:struct:_IO_marker::_IO_FILE
_seek_dir	g++/streambuf.h	/^typedef int _seek_dir;$/;"	t
_seek_dir	g++/streambuf.h	/^typedef ios::seek_dir _seek_dir;$/;"	t
_shortbuf	g++/libio.h	/^  char _shortbuf[1];$/;"	m	struct:_IO_FILE
_state	g++/streambuf.h	/^    __iostate _state;$/;"	m	struct:_ios_fields
_strbuf	g++/streambuf.h	/^    streambuf *_strbuf;$/;"	m	struct:_ios_fields
_stream	g++/streambuf.h	/^	ios* _stream;$/;"	m	class:ios::failure
_symbol_info	bfd.h	/^typedef struct _symbol_info$/;"	s
_throw_failure	g++/streambuf.h	/^    void _throw_failure() const { throw new ios::failure(this); }$/;"	f	class:ios
_throw_failure	g++/streambuf.h	/^    void _throw_failure() const { }$/;"	f	class:ios
_tie	g++/streambuf.h	/^    ostream* _tie;$/;"	m	struct:_ios_fields
_unused	g++/libio.h	/^  char _unused;$/;"	m	struct:_IO_FILE
_unused2	g++/libio.h	/^  int _unused2[16];	\/* Make sure we don't get into trouble again.  *\/$/;"	m	struct:_IO_FILE
_vtable	g++/streambuf.h	/^    const void *&_vtable() { return *(const void**)((_IO_FILE*)this + 1); }$/;"	f	struct:streambuf
_vtable	g++/strfile.h	/^  const void *_vtable;$/;"	m	struct:_IO_streambuf
_width	g++/streambuf.h	/^    int _width;$/;"	m	struct:_ios_fields
_writer	g++/editbuf.h	/^    edit_streambuf* _writer; \/\/ If non-NULL, currently writing stream$/;"	m	struct:edit_buffer
abfd	bfdlink.h	/^	  bfd *abfd;		\/* BFD symbol was found in.  *\/$/;"	m	struct:bfd_link_hash_entry::__anon59::__anon60
abs	g++/std/complext.h	/^abs (const complex<_FLT>& x)$/;"	f
accumulate	g++/stl_numeric.h	/^T accumulate(InputIterator first, InputIterator last, T init) {$/;"	f
accumulate	g++/stl_numeric.h	/^T accumulate(InputIterator first, InputIterator last, T init,$/;"	f
add_archive_element	bfdlink.h	/^  boolean (*add_archive_element) PARAMS ((struct bfd_link_info *,$/;"	m	struct:bfd_link_callbacks
add_leaf_to_forest	g++/ropeimpl.h	/^rope<charT,Alloc>::add_leaf_to_forest(RopeBase *r, RopeBase **forest)$/;"	f	class:rope
add_to_forest	g++/ropeimpl.h	/^rope<charT,Alloc>::add_to_forest(RopeBase *r, RopeBase **forest)$/;"	f	class:rope
add_to_set	bfdlink.h	/^  boolean (*add_to_set) PARAMS ((struct bfd_link_info *,$/;"	m	struct:bfd_link_callbacks
addend	bfd.h	/^  bfd_vma addend;$/;"	m	struct:reloc_cache_entry
addend	bfdlink.h	/^  bfd_vma addend;$/;"	m	struct:bfd_link_order_reloc
address	bfd.h	/^  bfd_size_type address;$/;"	m	struct:reloc_cache_entry
address	g++/defalloc.h	/^    pointer address(reference x) $/;"	f	class:allocator
adjacent_difference	g++/stl_numeric.h	/^OutputIterator adjacent_difference(InputIterator first, InputIterator last, $/;"	f
adjacent_difference	g++/stl_numeric.h	/^OutputIterator adjacent_difference(InputIterator first, InputIterator last,$/;"	f
adjacent_find	g++/stl_algo.h	/^ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last) {$/;"	f
adjacent_find	g++/stl_algo.h	/^ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred) $/;"	f
adjustfield	g++/streambuf.h	/^	adjustfield = left+right+internal$/;"	e	enum:ios::__anon2
adjustfield	g++/streambuf.h	/^	adjustfield = left+right+internal$/;"	e	enum:ios::__anon73
advance	g++/stl_iterator.h	/^inline void advance(InputIterator& i, Distance n) {$/;"	f
alent	bfd.h	/^} alent;$/;"	t	typeref:struct:lineno_cache_entry
align_power	bfd.h	302;"	d
alignment_power	bfd.h	/^   unsigned int alignment_power;$/;"	m	struct:sec
alignment_power	bfdlink.h	/^	      unsigned int alignment_power;	\/* Alignment.  *\/$/;"	m	struct:bfd_link_hash_entry::__anon59::__anon63::bfd_link_hash_common_entry
alloc	g++/std/bastring.cc	/^alloc(basic_string::size_type size, bool save)$/;"	f	class:basic_string
alloc	g++/stl_alloc.h	/^typedef __default_alloc_template<__NODE_ALLOCATOR_THREADS, 0> alloc;$/;"	t
alloc	g++/stl_alloc.h	/^typedef malloc_alloc alloc;  \/\/alloc$/;"	t
alloc_copy	g++/stl_rope.h	/^	static charT * alloc_copy(const charT *s, size_t size)$/;"	f	class:rope
alloc_granularity	g++/stl_rope.h	/^    enum { alloc_granularity = 8 };$/;"	e	enum:__rope_RopeBase::__anon10
alloc_granularity	g++/stl_rope.h	/^    enum { alloc_granularity = 8 };$/;"	e	enum:__rope_RopeBase::__anon81
allocate	g++/defalloc.h	/^    pointer allocate(size_type n) $/;"	f	class:allocator
allocate	g++/defalloc.h	/^inline T* allocate(ptrdiff_t size, T*) $/;"	f
allocate	g++/stl_alloc.h	/^	static void * allocate(size_t n)$/;"	f	class:debug_alloc
allocate	g++/stl_alloc.h	/^	static void* allocate(size_t n)$/;"	f	class:__default_alloc_template
allocate	g++/stl_alloc.h	/^	static void* allocate(size_t n)$/;"	f	class:__malloc_alloc_template
allocate	g++/stl_alloc.h	/^    static T* allocate(size_t n)$/;"	f	class:simple_alloc
allocate	g++/stl_alloc.h	/^    static T* allocate(void)$/;"	f	class:simple_alloc
allocate	g++/streambuf.h	/^    int allocate() { \/\/ For AT&T compatibility$/;"	f	struct:streambuf
allocate_and_copy	g++/stl_vector.h	/^	iterator allocate_and_copy(size_type n, ForwardIterator first, ForwardIterator last)$/;"	f	class:vector
allocate_and_fill	g++/stl_vector.h	/^	iterator allocate_and_fill(size_type n, const T& x) $/;"	f	class:vector
allocate_buffer	g++/stl_tempbuf.h	/^  void allocate_buffer() {$/;"	f	class:temporary_buffer
allocate_node	g++/stl_deque.h	/^	pointer allocate_node() { return data_allocator::allocate(buffer_size()); }$/;"	f	class:std::deque
allocated_capacity	g++/stl_rope.h	/^	static size_t allocated_capacity(size_t n) {$/;"	f	class:rope
allocator	g++/defalloc.h	/^class allocator $/;"	c
allocator	g++/defalloc.h	/^class allocator<void> $/;"	c
allocator_type	g++/std/bastring.h	/^	typedef Allocator								allocator_type;$/;"	t	class:basic_string
allocbuf	g++/streambuf.h	/^    void allocbuf() { if (base() == NULL) doallocbuf(); }$/;"	f	struct:streambuf
alwaysRedraw	tk.h	/^    int alwaysRedraw;			\/* Non-zero means displayProc should$/;"	m	struct:Tk_ItemType
anchorItemPtr	tk.h	/^    Tk_Item *anchorItemPtr;	\/* Item corresponding to "selectAnchor":$/;"	m	struct:Tk_CanvasTextInfo
and	include/iso646.h	4;"	d
and_eq	include/iso646.h	5;"	d
any	bfd.h	/^      PTR any;$/;"	m	union:_bfd::__anon38
aout_ar_data	bfd.h	/^      struct artdata *aout_ar_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::artdata
aout_data	bfd.h	/^      struct aout_data_struct *aout_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::aout_data_struct
app	g++/streambuf.h	/^	app = _IO_APPEND,$/;"	e	enum:ios::open_mode
append	g++/std/bastring.h	/^	basic_string& append(const basic_string& str, size_type pos = 0,size_type n = npos)$/;"	f	class:basic_string
append	g++/std/bastring.h	/^	basic_string& append(const charT* s)$/;"	f	class:basic_string
append	g++/std/bastring.h	/^	basic_string& append(const charT* s, size_type n)$/;"	f	class:basic_string
append	g++/std/bastring.h	/^	basic_string& append(const_iterator first, const_iterator last)$/;"	f	class:basic_string
append	g++/std/bastring.h	/^	basic_string& append(size_type n, charT c)$/;"	f	class:basic_string
append	g++/std/bastring.h	/^    basic_string& append(InputIterator first, InputIterator last)$/;"	f	class:basic_string
append	g++/stl_rope.h	/^	rope& append() { return append(charT()); }$/;"	f	class:rope
append	g++/stl_rope.h	/^	rope& append(charT c) {$/;"	f	class:rope
append	g++/stl_rope.h	/^	rope& append(const charT* c_string) {$/;"	f	class:rope
append	g++/stl_rope.h	/^	rope& append(const charT* iter, size_t n) {$/;"	f	class:rope
append	g++/stl_rope.h	/^	rope& append(const charT* s, const charT* e) {$/;"	f	class:rope
append	g++/stl_rope.h	/^	rope& append(const rope& y) {$/;"	f	class:rope
append	g++/stl_rope.h	/^	rope& append(const_iterator s, const_iterator e) {$/;"	f	class:rope
append	g++/stl_rope.h	/^	rope& append(size_t n, charT c) {$/;"	f	class:rope
append	g++/stl_rope.h	/^	void append(value_type *s, size_t len)$/;"	f	class:sequence_buffer
append	g++/streambuf.h	/^    append = _IO_APPEND };$/;"	e	enum:open_mode
apply_to_pieces	g++/ropeimpl.h	/^bool rope<charT, Alloc>::apply_to_pieces($/;"	f	class:rope
apply_to_pieces	g++/stl_rope.h	/^	void apply_to_pieces( size_t begin, size_t end,$/;"	f	class:rope
ar_max_namelen	bfd.h	/^  unsigned short ar_max_namelen;$/;"	m	struct:bfd_target
ar_pad_char	bfd.h	/^  char ar_pad_char;            $/;"	m	struct:bfd_target
arch	bfd.h	/^  enum bfd_architecture arch;$/;"	m	struct:bfd_arch_info	typeref:enum:bfd_arch_info::bfd_architecture
arch_info	bfd.h	/^    const struct bfd_arch_info *arch_info;$/;"	m	struct:_bfd	typeref:struct:_bfd::bfd_arch_info
arch_name	bfd.h	/^  const char *arch_name;$/;"	m	struct:bfd_arch_info
archive_head	bfd.h	/^    struct _bfd *archive_head;    \/* The first BFD in the archive.  *\/$/;"	m	struct:_bfd	typeref:struct:_bfd::_bfd
archive_pass	bfd.h	/^    int archive_pass;$/;"	m	struct:_bfd
areaProc	tk.h	/^    Tk_ItemAreaProc *areaProc;		\/* Computes whether item is inside,$/;"	m	struct:Tk_ItemType
arelent	bfd.h	/^} arelent;$/;"	t	typeref:struct:reloc_cache_entry
arelent_chain	bfd.h	/^} arelent_chain;$/;"	t	typeref:struct:relent_chain
arelt_data	bfd.h	/^    PTR arelt_data;              $/;"	m	struct:_bfd
arg	g++/parsestream.h	/^    void *arg;$/;"	m	class:func_parsebuf
arg	g++/std/complext.h	/^arg (const complex<_FLT>& x)$/;"	f
argument_type	g++/stl_function.h	/^    typedef Arg argument_type;$/;"	t	struct:unary_function
argvName	tk.h	/^    char *argvName;		\/* Switch used to specify option in argv.$/;"	m	struct:Tk_ConfigSpec
ascent	tk.h	/^    int ascent;			\/* The amount in pixels that the tallest$/;"	m	struct:Tk_FontMetrics
asection	bfd.h	/^} asection ;$/;"	t	typeref:struct:sec
assign	g++/std/bastring.h	/^	basic_string& assign(const basic_string& str, size_type pos = 0, size_type n = npos)$/;"	f	class:basic_string
assign	g++/std/bastring.h	/^	basic_string& assign(const charT* s) $/;"	f	class:basic_string
assign	g++/std/bastring.h	/^	basic_string& assign(const charT* s, size_type n) $/;"	f	class:basic_string
assign	g++/std/bastring.h	/^	basic_string& assign(const_iterator first, const_iterator last)$/;"	f	class:basic_string
assign	g++/std/bastring.h	/^	basic_string& assign(size_type n, charT c) $/;"	f	class:basic_string
assign	g++/std/bastring.h	/^    basic_string& assign(InputIterator first, InputIterator last)$/;"	f	class:basic_string
assign	g++/std/straits.h	/^	static void assign(char_type& c1, const char_type& c2) { c1 = c2; }$/;"	f	struct:string_char_traits
assign	g++/std/straits.h	/^  static void assign (char_type& c1, const char_type& c2)$/;"	f	struct:string_char_traits
asymbol	bfd.h	/^} asymbol;$/;"	t	typeref:struct:symbol_cache_entry
at	g++/std/bastring.h	/^	const_reference at (size_type pos) const$/;"	f	class:basic_string
at	g++/std/bastring.h	/^	reference at (size_type pos)$/;"	f	class:basic_string
at	g++/stl_rope.h	/^	    reference at(size_type pos) {$/;"	f	class:rope
at	g++/stl_rope.h	/^	charT at(size_type pos) const {$/;"	f	class:rope
ate	g++/streambuf.h	/^	ate = _IO_ATEND,$/;"	e	enum:ios::open_mode
atend	g++/streambuf.h	/^    atend = _IO_ATEND,$/;"	e	enum:open_mode
atomic_swap	g++/stl_rope.h	/^	    static cstrptr atomic_swap(cstrptr *p, cstrptr q) {$/;"	f	class:rope
atts	tk.h	/^    XSetWindowAttributes atts;$/;"	m	struct:Tk_FakeWin
back	g++/stl_bvector.h	/^  const_reference back() const { return *(end() - 1); }$/;"	f	class:vector
back	g++/stl_bvector.h	/^  reference back() { return *(end() - 1); }$/;"	f	class:vector
back	g++/stl_deque.h	/^	const_reference back() const $/;"	f	class:std::deque
back	g++/stl_deque.h	/^	reference back() $/;"	f	class:std::deque
back	g++/stl_list.h	/^	const_reference back() const { 	$/;"	f	class:std::list
back	g++/stl_list.h	/^	reference back() { $/;"	f	class:std::list
back	g++/stl_queue.h	/^	const_reference back() const { return c.back(); }$/;"	f	class:queue
back	g++/stl_queue.h	/^	reference back() { return c.back(); }$/;"	f	class:queue
back	g++/stl_rope.h	/^	charT back() const$/;"	f	class:rope
back	g++/stl_vector.h	/^	const_reference back() const { return *(end() - 1); }$/;"	f	class:vector
back	g++/stl_vector.h	/^	reference back() { return *(end() - 1); }$/;"	f	class:vector
back_insert_iterator	g++/stl_iterator.h	/^  explicit back_insert_iterator(Container& x) : container(&x) {}$/;"	f	class:back_insert_iterator
back_insert_iterator	g++/stl_iterator.h	/^class back_insert_iterator {$/;"	c
back_inserter	g++/stl_iterator.h	/^inline back_insert_iterator<Container> back_inserter(Container& x) {$/;"	f
backed_up_to_newline	g++/parsestream.h	/^    int backed_up_to_newline;$/;"	m	class:func_parsebuf
backend_data	bfd.h	/^ PTR backend_data;$/;"	m	struct:bfd_target
bad	g++/streambuf.h	/^    int bad() const { return _state & ios::badbit; }$/;"	f	class:ios
badbit	g++/streambuf.h	/^	badbit = _IOS_BAD };$/;"	e	enum:ios::io_state
balance	g++/ropeimpl.h	/^rope<charT,Alloc>::balance(RopeBase *r)$/;"	f	class:rope
balance	g++/stl_rope.h	/^	void balance()$/;"	f	class:rope
base	g++/stl_iterator.h	/^  BidirectionalIterator base() const { return current; }$/;"	f	class:reverse_bidirectional_iterator
base	g++/stl_iterator.h	/^  RandomAccessIterator base() const { return current; }$/;"	f	class:reverse_iterator
base	g++/stl_iterator.h	/^  iterator_type base() const { return current; }$/;"	f	class:reverse_iterator
base	g++/stl_rope.h	/^    __rope_RopeBase<charT,Alloc> * base;	\/\/ not 0$/;"	m	struct:__rope_RopeSubstring
base	g++/streambuf.h	/^    char* base() const { return _IO_buf_base; }$/;"	f	struct:streambuf
base_file	bfdlink.h	/^  PTR base_file;$/;"	m	struct:bfd_link_info
base_ptr	g++/stl_tree.h	/^	typedef __rb_tree_node_base* base_ptr;$/;"	t	struct:__rb_tree_node_base
base_ptr	g++/stl_tree.h	/^	typedef __rb_tree_node_base::base_ptr base_ptr;$/;"	t	struct:__rb_tree_base_iterator
base_ptr	g++/stl_tree.h	/^  typedef __rb_tree_node_base* base_ptr;$/;"	t	class:rb_tree
basefield	g++/streambuf.h	/^	basefield=dec+oct+hex,$/;"	e	enum:ios::__anon2
basefield	g++/streambuf.h	/^	basefield=dec+oct+hex,$/;"	e	enum:ios::__anon73
basic_string	g++/std/bastring.h	/^	basic_string(const basic_string& str): dat(str.rep()->grab()) { }$/;"	f	class:basic_string
basic_string	g++/std/bastring.h	/^	basic_string(const basic_string& str, size_type pos, size_type n = npos): dat(nilRep.grab()) $/;"	f	class:basic_string
basic_string	g++/std/bastring.h	/^	basic_string(const charT* s) : dat(nilRep.grab()) $/;"	f	class:basic_string
basic_string	g++/std/bastring.h	/^	basic_string(const charT* s, size_type n) : dat(nilRep.grab()) $/;"	f	class:basic_string
basic_string	g++/std/bastring.h	/^	basic_string(const_iterator begin, const_iterator end): dat(nilRep.grab()) $/;"	f	class:basic_string
basic_string	g++/std/bastring.h	/^	basic_string(size_type n, charT c) : dat(nilRep.grab()) $/;"	f	class:basic_string
basic_string	g++/std/bastring.h	/^	explicit basic_string(): dat(nilRep.grab()) { }$/;"	f	class:basic_string
basic_string	g++/std/bastring.h	/^    basic_string(InputIterator begin, InputIterator end) : dat(nilRep.grab()) $/;"	f	class:basic_string
basic_string	g++/std/bastring.h	/^class basic_string$/;"	c
beg	g++/streambuf.h	/^    enum seek_dir { beg, cur, end};$/;"	e	enum:ios::seek_dir
begin	g++/std/bastring.h	/^	const_iterator begin () const { return ibegin (); }$/;"	f	class:basic_string
begin	g++/std/bastring.h	/^	iterator begin () { selfish (); return &(*this)[0]; }$/;"	f	class:basic_string
begin	g++/stl_bvector.h	/^  const_iterator begin() const { return start; }$/;"	f	class:vector
begin	g++/stl_bvector.h	/^  iterator begin() { return start; }$/;"	f	class:vector
begin	g++/stl_deque.h	/^	const_iterator begin() const { return start; }$/;"	f	class:std::deque
begin	g++/stl_deque.h	/^	iterator begin() { return start; }$/;"	f	class:std::deque
begin	g++/stl_hash_map.h	/^  const_iterator begin() const { return rep.begin(); }$/;"	f	class:hash_map
begin	g++/stl_hash_map.h	/^  const_iterator begin() const { return rep.begin(); }$/;"	f	class:hash_multimap
begin	g++/stl_hash_map.h	/^  iterator begin() { return rep.begin(); }$/;"	f	class:hash_map
begin	g++/stl_hash_map.h	/^  iterator begin() { return rep.begin(); }$/;"	f	class:hash_multimap
begin	g++/stl_hash_set.h	/^  iterator begin() const { return rep.begin(); }$/;"	f	class:hash_multiset
begin	g++/stl_hash_set.h	/^  iterator begin() const { return rep.begin(); }$/;"	f	class:hash_set
begin	g++/stl_hashtable.h	/^  const_iterator begin() const$/;"	f	class:hashtable
begin	g++/stl_hashtable.h	/^  iterator begin()$/;"	f	class:hashtable
begin	g++/stl_list.h	/^	const_iterator begin() const { return (link_type)((*node).next); $/;"	f	class:std::list
begin	g++/stl_list.h	/^	iterator begin() { 	return (link_type)((*node).next); }$/;"	f	class:std::list
begin	g++/stl_map.h	/^  const_iterator begin() const { return t.begin(); }$/;"	f	class:map
begin	g++/stl_map.h	/^  iterator begin() { return t.begin(); }$/;"	f	class:map
begin	g++/stl_multimap.h	/^  const_iterator begin() const { return t.begin(); }$/;"	f	class:multimap
begin	g++/stl_multimap.h	/^  iterator begin() { return t.begin(); }$/;"	f	class:multimap
begin	g++/stl_multiset.h	/^  iterator begin() const { return t.begin(); }$/;"	f	class:multiset
begin	g++/stl_rope.h	/^	    const_iterator begin() { return const_begin(); }$/;"	f	class:rope
begin	g++/stl_rope.h	/^	    iterator begin() { return mutable_begin(); }$/;"	f	class:rope
begin	g++/stl_rope.h	/^	const_iterator begin() const {$/;"	f	class:rope
begin	g++/stl_set.h	/^  iterator begin() const { return t.begin(); }$/;"	f	class:set
begin	g++/stl_slist.h	/^	const_iterator begin() const { return const_iterator((list_node*)head.next);}$/;"	f	class:std::slist
begin	g++/stl_slist.h	/^	iterator begin() { return iterator((list_node*)head.next); }$/;"	f	class:std::slist
begin	g++/stl_tempbuf.h	/^  T* begin() { return buffer; }$/;"	f	class:temporary_buffer
begin	g++/stl_tree.h	/^  const_iterator begin() const { return leftmost(); }$/;"	f	class:rb_tree
begin	g++/stl_tree.h	/^  iterator begin() { return leftmost(); }$/;"	f	class:rb_tree
begin	g++/stl_vector.h	/^	const_iterator begin() const { return start; }$/;"	f	class:vector
begin	g++/stl_vector.h	/^	iterator begin() { return start; }$/;"	f	class:vector
bfd	bfd.h	/^typedef struct _bfd bfd;$/;"	t	typeref:struct:_bfd
bfd_abs_section_ptr	bfd.h	1127;"	d
bfd_applicable_file_flags	bfd.h	493;"	d
bfd_applicable_section_flags	bfd.h	494;"	d
bfd_arch_a29k	bfd.h	/^  bfd_arch_a29k,       \/* AMD 29000 *\/$/;"	e	enum:bfd_architecture
bfd_arch_alliant	bfd.h	/^  bfd_arch_alliant,    \/* Alliant *\/$/;"	e	enum:bfd_architecture
bfd_arch_alpha	bfd.h	/^  bfd_arch_alpha,      \/* Dec Alpha *\/$/;"	e	enum:bfd_architecture
bfd_arch_arc	bfd.h	/^  bfd_arch_arc,        \/* Argonaut RISC Core *\/$/;"	e	enum:bfd_architecture
bfd_arch_arm	bfd.h	/^  bfd_arch_arm,        \/* Advanced Risc Machines ARM *\/$/;"	e	enum:bfd_architecture
bfd_arch_convex	bfd.h	/^  bfd_arch_convex,     \/* Convex *\/$/;"	e	enum:bfd_architecture
bfd_arch_d10v	bfd.h	/^  bfd_arch_d10v,       \/* Mitsubishi D10V *\/$/;"	e	enum:bfd_architecture
bfd_arch_d30v	bfd.h	/^  bfd_arch_d30v,       \/* Mitsubishi D30V *\/$/;"	e	enum:bfd_architecture
bfd_arch_h8300	bfd.h	/^  bfd_arch_h8300,      \/* Hitachi H8\/300 *\/$/;"	e	enum:bfd_architecture
bfd_arch_h8500	bfd.h	/^  bfd_arch_h8500,      \/* Hitachi H8\/500 *\/$/;"	e	enum:bfd_architecture
bfd_arch_hppa	bfd.h	/^  bfd_arch_hppa,       \/* HP PA RISC *\/$/;"	e	enum:bfd_architecture
bfd_arch_i386	bfd.h	/^  bfd_arch_i386,       \/* Intel 386 *\/$/;"	e	enum:bfd_architecture
bfd_arch_i860	bfd.h	/^  bfd_arch_i860,       \/* Intel 860 *\/$/;"	e	enum:bfd_architecture
bfd_arch_i960	bfd.h	/^  bfd_arch_i960,       \/* Intel 960 *\/$/;"	e	enum:bfd_architecture
bfd_arch_info	bfd.h	/^typedef struct bfd_arch_info $/;"	s
bfd_arch_info_type	bfd.h	/^} bfd_arch_info_type;$/;"	t	typeref:struct:bfd_arch_info
bfd_arch_last	bfd.h	/^  bfd_arch_last$/;"	e	enum:bfd_architecture
bfd_arch_m32r	bfd.h	/^  bfd_arch_m32r,       \/* Mitsubishi M32R\/D *\/$/;"	e	enum:bfd_architecture
bfd_arch_m68k	bfd.h	/^  bfd_arch_m68k,       \/* Motorola 68xxx *\/$/;"	e	enum:bfd_architecture
bfd_arch_m88k	bfd.h	/^  bfd_arch_m88k,       \/* Motorola 88xxx *\/$/;"	e	enum:bfd_architecture
bfd_arch_mips	bfd.h	/^  bfd_arch_mips,       \/* MIPS Rxxxx *\/$/;"	e	enum:bfd_architecture
bfd_arch_mn10200	bfd.h	/^  bfd_arch_mn10200,    \/* Matsushita MN10200 *\/$/;"	e	enum:bfd_architecture
bfd_arch_mn10300	bfd.h	/^  bfd_arch_mn10300,    \/* Matsushita MN10300 *\/$/;"	e	enum:bfd_architecture
bfd_arch_ns32k	bfd.h	/^  bfd_arch_ns32k,      \/* National Semiconductors ns32000 *\/$/;"	e	enum:bfd_architecture
bfd_arch_obscure	bfd.h	/^  bfd_arch_obscure,    \/* Arch known, not one of these *\/$/;"	e	enum:bfd_architecture
bfd_arch_powerpc	bfd.h	/^  bfd_arch_powerpc,    \/* PowerPC *\/$/;"	e	enum:bfd_architecture
bfd_arch_pyramid	bfd.h	/^  bfd_arch_pyramid,    \/* Pyramid Technology *\/$/;"	e	enum:bfd_architecture
bfd_arch_romp	bfd.h	/^  bfd_arch_romp,       \/* IBM ROMP PC\/RT *\/$/;"	e	enum:bfd_architecture
bfd_arch_rs6000	bfd.h	/^  bfd_arch_rs6000,     \/* IBM RS\/6000 *\/$/;"	e	enum:bfd_architecture
bfd_arch_sh	bfd.h	/^  bfd_arch_sh,         \/* Hitachi SH *\/$/;"	e	enum:bfd_architecture
bfd_arch_sparc	bfd.h	/^  bfd_arch_sparc,      \/* SPARC *\/$/;"	e	enum:bfd_architecture
bfd_arch_tahoe	bfd.h	/^  bfd_arch_tahoe,      \/* CCI\/Harris Tahoe *\/$/;"	e	enum:bfd_architecture
bfd_arch_tic30	bfd.h	/^  bfd_arch_tic30,      \/* Texas Instruments TMS320C30 *\/$/;"	e	enum:bfd_architecture
bfd_arch_unknown	bfd.h	/^  bfd_arch_unknown,    \/* File arch not known *\/$/;"	e	enum:bfd_architecture
bfd_arch_v850	bfd.h	/^  bfd_arch_v850,       \/* NEC V850 *\/$/;"	e	enum:bfd_architecture
bfd_arch_vax	bfd.h	/^  bfd_arch_vax,        \/* DEC Vax *\/   $/;"	e	enum:bfd_architecture
bfd_arch_w65	bfd.h	/^  bfd_arch_w65,        \/* WDC 65816 *\/$/;"	e	enum:bfd_architecture
bfd_arch_we32k	bfd.h	/^  bfd_arch_we32k,      \/* AT&T WE32xxx *\/$/;"	e	enum:bfd_architecture
bfd_arch_z8k	bfd.h	/^  bfd_arch_z8k,        \/* Zilog Z8000 *\/$/;"	e	enum:bfd_architecture
bfd_architecture	bfd.h	/^enum bfd_architecture $/;"	g
bfd_archive	bfd.h	/^	      bfd_archive,	\/* object archive file *\/$/;"	e	enum:bfd_format
bfd_asymbol_base	bfd.h	267;"	d
bfd_asymbol_bfd	bfd.h	271;"	d
bfd_asymbol_flavour	bfd.h	272;"	d
bfd_asymbol_name	bfd.h	269;"	d
bfd_asymbol_value	bfd.h	268;"	d
bfd_big_endian	bfd.h	486;"	d
bfd_boolean	bfd.h	/^typedef enum bfd_boolean {bfd_fffalse, bfd_tttrue} boolean;$/;"	g
bfd_boolean	bfd.h	/^typedef enum bfd_boolean {false, true} boolean;$/;"	g
bfd_byte	bfd.h	/^typedef unsigned char bfd_byte;$/;"	t
bfd_canonicalize_dynamic_reloc	bfd.h	2568;"	d
bfd_canonicalize_dynamic_symtab	bfd.h	2562;"	d
bfd_canonicalize_symtab	bfd.h	2230;"	d
bfd_com_section_ptr	bfd.h	1135;"	d
bfd_copy_private_bfd_data	bfd.h	2497;"	d
bfd_copy_private_section_data	bfd.h	1190;"	d
bfd_copy_private_symbol_data	bfd.h	2252;"	d
bfd_core	bfd.h	/^	      bfd_core,		\/* core dump *\/$/;"	e	enum:bfd_format
bfd_count_sections	bfd.h	504;"	d
bfd_data_link_order	bfdlink.h	/^  bfd_data_link_order,		\/* Set to explicit data.  *\/$/;"	e	enum:bfd_link_order_type
bfd_debug_info_accumulate	bfd.h	2525;"	d
bfd_debug_info_end	bfd.h	2522;"	d
bfd_debug_info_start	bfd.h	2519;"	d
bfd_direction	bfd.h	/^    enum bfd_direction {no_direction = 0,$/;"	g	struct:_bfd
bfd_elf_version_deps	bfdlink.h	/^struct bfd_elf_version_deps$/;"	s
bfd_elf_version_expr	bfdlink.h	/^struct bfd_elf_version_expr$/;"	s
bfd_elf_version_tree	bfdlink.h	/^struct bfd_elf_version_tree$/;"	s
bfd_endian	bfd.h	/^enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };$/;"	g
bfd_error	bfd.h	/^typedef enum bfd_error$/;"	g
bfd_error_bad_value	bfd.h	/^  bfd_error_bad_value,$/;"	e	enum:bfd_error
bfd_error_file_ambiguously_recognized	bfd.h	/^  bfd_error_file_ambiguously_recognized,$/;"	e	enum:bfd_error
bfd_error_file_not_recognized	bfd.h	/^  bfd_error_file_not_recognized,$/;"	e	enum:bfd_error
bfd_error_file_too_big	bfd.h	/^  bfd_error_file_too_big,$/;"	e	enum:bfd_error
bfd_error_file_truncated	bfd.h	/^  bfd_error_file_truncated,$/;"	e	enum:bfd_error
bfd_error_handler_type	bfd.h	/^typedef void (*bfd_error_handler_type) PARAMS ((const char *, ...));$/;"	t
bfd_error_invalid_error_code	bfd.h	/^  bfd_error_invalid_error_code$/;"	e	enum:bfd_error
bfd_error_invalid_operation	bfd.h	/^  bfd_error_invalid_operation,$/;"	e	enum:bfd_error
bfd_error_invalid_target	bfd.h	/^  bfd_error_invalid_target,$/;"	e	enum:bfd_error
bfd_error_malformed_archive	bfd.h	/^  bfd_error_malformed_archive,$/;"	e	enum:bfd_error
bfd_error_no_armap	bfd.h	/^  bfd_error_no_armap,$/;"	e	enum:bfd_error
bfd_error_no_contents	bfd.h	/^  bfd_error_no_contents,$/;"	e	enum:bfd_error
bfd_error_no_debug_section	bfd.h	/^  bfd_error_no_debug_section,$/;"	e	enum:bfd_error
bfd_error_no_error	bfd.h	/^  bfd_error_no_error = 0,$/;"	e	enum:bfd_error
bfd_error_no_memory	bfd.h	/^  bfd_error_no_memory,$/;"	e	enum:bfd_error
bfd_error_no_more_archived_files	bfd.h	/^  bfd_error_no_more_archived_files,$/;"	e	enum:bfd_error
bfd_error_no_symbols	bfd.h	/^  bfd_error_no_symbols,$/;"	e	enum:bfd_error
bfd_error_nonrepresentable_section	bfd.h	/^  bfd_error_nonrepresentable_section,$/;"	e	enum:bfd_error
bfd_error_system_call	bfd.h	/^  bfd_error_system_call,$/;"	e	enum:bfd_error
bfd_error_type	bfd.h	/^} bfd_error_type;$/;"	t	typeref:enum:bfd_error
bfd_error_wrong_format	bfd.h	/^  bfd_error_wrong_format,$/;"	e	enum:bfd_error
bfd_fffalse	bfd.h	/^typedef enum bfd_boolean {bfd_fffalse, bfd_tttrue} boolean;$/;"	e	enum:bfd_boolean
bfd_fill_link_order	bfdlink.h	/^  bfd_fill_link_order,		\/* Fill with a 16 bit constant.  *\/$/;"	e	enum:bfd_link_order_type
bfd_final_link	bfd.h	2550;"	d
bfd_find_nearest_line	bfd.h	2515;"	d
bfd_flavour	bfd.h	/^enum bfd_flavour {$/;"	g
bfd_format	bfd.h	/^         bfd_format;$/;"	t	typeref:enum:bfd_format
bfd_format	bfd.h	/^typedef enum bfd_format {$/;"	g
bfd_free_cached_info	bfd.h	2553;"	d
bfd_gc_sections	bfd.h	2541;"	d
bfd_get_16	bfd.h	762;"	d
bfd_get_32	bfd.h	771;"	d
bfd_get_64	bfd.h	780;"	d
bfd_get_8	bfd.h	753;"	d
bfd_get_cacheable	bfd.h	482;"	d
bfd_get_dynamic_reloc_upper_bound	bfd.h	2565;"	d
bfd_get_dynamic_symtab_upper_bound	bfd.h	2556;"	d
bfd_get_elt_at_index	bfd.h	2755;"	d
bfd_get_file_flags	bfd.h	492;"	d
bfd_get_filename	bfd.h	481;"	d
bfd_get_flavour	bfd.h	485;"	d
bfd_get_format	bfd.h	483;"	d
bfd_get_output_section	bfd.h	265;"	d
bfd_get_outsymbols	bfd.h	503;"	d
bfd_get_section	bfd.h	264;"	d
bfd_get_section_alignment	bfd.h	309;"	d
bfd_get_section_flags	bfd.h	315;"	d
bfd_get_section_name	bfd.h	307;"	d
bfd_get_section_size_after_reloc	bfd.h	1147;"	d
bfd_get_section_size_before_reloc	bfd.h	1145;"	d
bfd_get_section_userdata	bfd.h	316;"	d
bfd_get_section_vma	bfd.h	308;"	d
bfd_get_signed_16	bfd.h	764;"	d
bfd_get_signed_32	bfd.h	773;"	d
bfd_get_signed_64	bfd.h	782;"	d
bfd_get_signed_8	bfd.h	755;"	d
bfd_get_start_address	bfd.h	501;"	d
bfd_get_symbol_info	bfd.h	2785;"	d
bfd_get_symbol_leading_char	bfd.h	506;"	d
bfd_get_symcount	bfd.h	502;"	d
bfd_get_symtab_upper_bound	bfd.h	2220;"	d
bfd_get_target	bfd.h	484;"	d
bfd_getx16	bfd.h	/^  bfd_vma      (*bfd_getx16) PARAMS ((const bfd_byte *));$/;"	m	struct:bfd_target
bfd_getx32	bfd.h	/^  bfd_vma      (*bfd_getx32) PARAMS ((const bfd_byte *));$/;"	m	struct:bfd_target
bfd_getx64	bfd.h	/^  bfd_vma      (*bfd_getx64) PARAMS ((const bfd_byte *));$/;"	m	struct:bfd_target
bfd_getx_signed_16	bfd.h	/^  bfd_signed_vma (*bfd_getx_signed_16) PARAMS ((const bfd_byte *));$/;"	m	struct:bfd_target
bfd_getx_signed_32	bfd.h	/^  bfd_signed_vma (*bfd_getx_signed_32) PARAMS ((const bfd_byte *));$/;"	m	struct:bfd_target
bfd_getx_signed_64	bfd.h	/^  bfd_signed_vma (*bfd_getx_signed_64) PARAMS ((const bfd_byte *));$/;"	m	struct:bfd_target
bfd_h_get_16	bfd.h	801;"	d
bfd_h_get_32	bfd.h	810;"	d
bfd_h_get_64	bfd.h	819;"	d
bfd_h_get_8	bfd.h	792;"	d
bfd_h_get_signed_16	bfd.h	803;"	d
bfd_h_get_signed_32	bfd.h	812;"	d
bfd_h_get_signed_64	bfd.h	821;"	d
bfd_h_get_signed_8	bfd.h	794;"	d
bfd_h_getx16	bfd.h	/^  bfd_vma      (*bfd_h_getx16) PARAMS ((const bfd_byte *));$/;"	m	struct:bfd_target
bfd_h_getx32	bfd.h	/^  bfd_vma      (*bfd_h_getx32) PARAMS ((const bfd_byte *));$/;"	m	struct:bfd_target
bfd_h_getx64	bfd.h	/^  bfd_vma      (*bfd_h_getx64) PARAMS ((const bfd_byte *));$/;"	m	struct:bfd_target
bfd_h_getx_signed_16	bfd.h	/^  bfd_signed_vma (*bfd_h_getx_signed_16) PARAMS ((const bfd_byte *));$/;"	m	struct:bfd_target
bfd_h_getx_signed_32	bfd.h	/^  bfd_signed_vma (*bfd_h_getx_signed_32) PARAMS ((const bfd_byte *));$/;"	m	struct:bfd_target
bfd_h_getx_signed_64	bfd.h	/^  bfd_signed_vma (*bfd_h_getx_signed_64) PARAMS ((const bfd_byte *));$/;"	m	struct:bfd_target
bfd_h_put_16	bfd.h	797;"	d
bfd_h_put_32	bfd.h	806;"	d
bfd_h_put_64	bfd.h	815;"	d
bfd_h_put_8	bfd.h	788;"	d
bfd_h_put_signed_16	bfd.h	799;"	d
bfd_h_put_signed_32	bfd.h	808;"	d
bfd_h_put_signed_64	bfd.h	817;"	d
bfd_h_put_signed_8	bfd.h	790;"	d
bfd_h_putx16	bfd.h	/^  void         (*bfd_h_putx16) PARAMS ((bfd_vma, bfd_byte *));$/;"	m	struct:bfd_target
bfd_h_putx32	bfd.h	/^  void         (*bfd_h_putx32) PARAMS ((bfd_vma, bfd_byte *));$/;"	m	struct:bfd_target
bfd_h_putx64	bfd.h	/^  void         (*bfd_h_putx64) PARAMS ((bfd_vma, bfd_byte *));$/;"	m	struct:bfd_target
bfd_has_map	bfd.h	496;"	d
bfd_hash_entry	bfd.h	/^struct bfd_hash_entry$/;"	s
bfd_hash_table	bfd.h	/^struct bfd_hash_table$/;"	s
bfd_header_big_endian	bfd.h	488;"	d
bfd_header_little_endian	bfd.h	490;"	d
bfd_ind_section_ptr	bfd.h	1138;"	d
bfd_indirect_link_order	bfdlink.h	/^  bfd_indirect_link_order,	\/* Built from a section.  *\/$/;"	e	enum:bfd_link_order_type
bfd_is_abs_section	bfd.h	1128;"	d
bfd_is_com_section	bfd.h	318;"	d
bfd_is_ind_section	bfd.h	1139;"	d
bfd_is_local_label_name	bfd.h	2228;"	d
bfd_is_und_section	bfd.h	1132;"	d
bfd_link_add_symbols	bfd.h	2547;"	d
bfd_link_callbacks	bfdlink.h	/^struct bfd_link_callbacks$/;"	s
bfd_link_discard	bfdlink.h	/^enum bfd_link_discard$/;"	g
bfd_link_hash_common	bfdlink.h	/^  bfd_link_hash_common,		\/* Symbol is common.  *\/$/;"	e	enum:bfd_link_hash_type
bfd_link_hash_common_entry	bfdlink.h	/^	  struct bfd_link_hash_common_entry$/;"	s	struct:bfd_link_hash_entry::__anon59::__anon63
bfd_link_hash_defined	bfdlink.h	/^  bfd_link_hash_defined,	\/* Symbol is defined.  *\/$/;"	e	enum:bfd_link_hash_type
bfd_link_hash_defweak	bfdlink.h	/^  bfd_link_hash_defweak,	\/* Symbol is weak and defined.  *\/$/;"	e	enum:bfd_link_hash_type
bfd_link_hash_entry	bfdlink.h	/^struct bfd_link_hash_entry$/;"	s
bfd_link_hash_indirect	bfdlink.h	/^  bfd_link_hash_indirect,	\/* Symbol is an indirect link.  *\/$/;"	e	enum:bfd_link_hash_type
bfd_link_hash_new	bfdlink.h	/^  bfd_link_hash_new,		\/* Symbol is new.  *\/$/;"	e	enum:bfd_link_hash_type
bfd_link_hash_table	bfdlink.h	/^struct bfd_link_hash_table$/;"	s
bfd_link_hash_table_create	bfd.h	2544;"	d
bfd_link_hash_type	bfdlink.h	/^enum bfd_link_hash_type$/;"	g
bfd_link_hash_undefined	bfdlink.h	/^  bfd_link_hash_undefined,	\/* Symbol seen before, but undefined.  *\/$/;"	e	enum:bfd_link_hash_type
bfd_link_hash_undefweak	bfdlink.h	/^  bfd_link_hash_undefweak,	\/* Symbol is weak and undefined.  *\/$/;"	e	enum:bfd_link_hash_type
bfd_link_hash_warning	bfdlink.h	/^  bfd_link_hash_warning		\/* Like indirect, but warn if referenced.  *\/$/;"	e	enum:bfd_link_hash_type
bfd_link_info	bfdlink.h	/^struct bfd_link_info$/;"	s
bfd_link_needed_list	bfd.h	/^struct bfd_link_needed_list$/;"	s
bfd_link_order	bfdlink.h	/^struct bfd_link_order $/;"	s
bfd_link_order_reloc	bfdlink.h	/^struct bfd_link_order_reloc$/;"	s
bfd_link_order_type	bfdlink.h	/^enum bfd_link_order_type$/;"	g
bfd_link_strip	bfdlink.h	/^enum bfd_link_strip$/;"	g
bfd_little_endian	bfd.h	487;"	d
bfd_mach_alpha_ev4	bfd.h	1284;"	d
bfd_mach_alpha_ev5	bfd.h	1285;"	d
bfd_mach_alpha_ev6	bfd.h	1286;"	d
bfd_mach_arc_base	bfd.h	1300;"	d
bfd_mach_arm_2	bfd.h	1288;"	d
bfd_mach_arm_2a	bfd.h	1289;"	d
bfd_mach_arm_3	bfd.h	1290;"	d
bfd_mach_arm_3M	bfd.h	1291;"	d
bfd_mach_arm_4	bfd.h	1292;"	d
bfd_mach_arm_4T	bfd.h	1293;"	d
bfd_mach_cpu32	bfd.h	1205;"	d
bfd_mach_h8300	bfd.h	1266;"	d
bfd_mach_h8300h	bfd.h	1267;"	d
bfd_mach_h8300s	bfd.h	1268;"	d
bfd_mach_i386_i386	bfd.h	1255;"	d
bfd_mach_i386_i8086	bfd.h	1256;"	d
bfd_mach_i960_ca	bfd.h	1221;"	d
bfd_mach_i960_core	bfd.h	1216;"	d
bfd_mach_i960_hx	bfd.h	1223;"	d
bfd_mach_i960_jx	bfd.h	1222;"	d
bfd_mach_i960_ka_sa	bfd.h	1217;"	d
bfd_mach_i960_kb_sb	bfd.h	1218;"	d
bfd_mach_i960_mc	bfd.h	1219;"	d
bfd_mach_i960_xa	bfd.h	1220;"	d
bfd_mach_m32r	bfd.h	1302;"	d
bfd_mach_m68000	bfd.h	1198;"	d
bfd_mach_m68008	bfd.h	1199;"	d
bfd_mach_m68010	bfd.h	1200;"	d
bfd_mach_m68020	bfd.h	1201;"	d
bfd_mach_m68030	bfd.h	1202;"	d
bfd_mach_m68040	bfd.h	1203;"	d
bfd_mach_m68060	bfd.h	1204;"	d
bfd_mach_mips10000	bfd.h	1252;"	d
bfd_mach_mips16	bfd.h	1253;"	d
bfd_mach_mips3000	bfd.h	1240;"	d
bfd_mach_mips3900	bfd.h	1241;"	d
bfd_mach_mips4000	bfd.h	1242;"	d
bfd_mach_mips4010	bfd.h	1243;"	d
bfd_mach_mips4100	bfd.h	1244;"	d
bfd_mach_mips4300	bfd.h	1245;"	d
bfd_mach_mips4400	bfd.h	1246;"	d
bfd_mach_mips4600	bfd.h	1247;"	d
bfd_mach_mips4650	bfd.h	1248;"	d
bfd_mach_mips5000	bfd.h	1249;"	d
bfd_mach_mips6000	bfd.h	1250;"	d
bfd_mach_mips8000	bfd.h	1251;"	d
bfd_mach_mn10300	bfd.h	1305;"	d
bfd_mach_sh	bfd.h	1279;"	d
bfd_mach_sh3	bfd.h	1280;"	d
bfd_mach_sh3e	bfd.h	1281;"	d
bfd_mach_sh4	bfd.h	1282;"	d
bfd_mach_sparc	bfd.h	1227;"	d
bfd_mach_sparc_sparclet	bfd.h	1229;"	d
bfd_mach_sparc_sparclite	bfd.h	1230;"	d
bfd_mach_sparc_sparclite_le	bfd.h	1233;"	d
bfd_mach_sparc_v8plus	bfd.h	1231;"	d
bfd_mach_sparc_v8plusa	bfd.h	1232;"	d
bfd_mach_sparc_v9	bfd.h	1234;"	d
bfd_mach_sparc_v9_p	bfd.h	1237;"	d
bfd_mach_sparc_v9a	bfd.h	1235;"	d
bfd_mach_v850	bfd.h	1298;"	d
bfd_mach_z8001	bfd.h	1275;"	d
bfd_mach_z8002	bfd.h	1276;"	d
bfd_make_debug_symbol	bfd.h	2241;"	d
bfd_make_empty_symbol	bfd.h	2239;"	d
bfd_merge_private_bfd_data	bfd.h	2503;"	d
bfd_minisymbol_to_symbol	bfd.h	2804;"	d
bfd_my_archive	bfd.h	495;"	d
bfd_object	bfd.h	/^	      bfd_object,	\/* linker\/assember\/compiler output *\/$/;"	e	enum:bfd_format
bfd_print_private_bfd_data	bfd.h	2559;"	d
bfd_print_symbol	bfd.h	/^typedef enum bfd_print_symbol$/;"	g
bfd_print_symbol	bfd.h	2781;"	d
bfd_print_symbol_all	bfd.h	/^  bfd_print_symbol_all$/;"	e	enum:bfd_print_symbol
bfd_print_symbol_more	bfd.h	/^  bfd_print_symbol_more,$/;"	e	enum:bfd_print_symbol
bfd_print_symbol_name	bfd.h	/^  bfd_print_symbol_name,$/;"	e	enum:bfd_print_symbol
bfd_print_symbol_type	bfd.h	/^} bfd_print_symbol_type;$/;"	t	typeref:enum:bfd_print_symbol
bfd_put_16	bfd.h	758;"	d
bfd_put_32	bfd.h	767;"	d
bfd_put_64	bfd.h	776;"	d
bfd_put_8	bfd.h	749;"	d
bfd_put_signed_16	bfd.h	760;"	d
bfd_put_signed_32	bfd.h	769;"	d
bfd_put_signed_64	bfd.h	778;"	d
bfd_put_signed_8	bfd.h	751;"	d
bfd_putx16	bfd.h	/^  void         (*bfd_putx16) PARAMS ((bfd_vma, bfd_byte *));$/;"	m	struct:bfd_target
bfd_putx32	bfd.h	/^  void         (*bfd_putx32) PARAMS ((bfd_vma, bfd_byte *));$/;"	m	struct:bfd_target
bfd_putx64	bfd.h	/^  void         (*bfd_putx64) PARAMS ((bfd_vma, bfd_byte *));$/;"	m	struct:bfd_target
bfd_read_minisymbols	bfd.h	2800;"	d
bfd_relax_section	bfd.h	2538;"	d
bfd_reloc_code_real	bfd.h	/^enum bfd_reloc_code_real {$/;"	g
bfd_reloc_code_real_type	bfd.h	/^typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;$/;"	t	typeref:enum:bfd_reloc_code_real
bfd_reloc_continue	bfd.h	/^  bfd_reloc_continue,$/;"	e	enum:bfd_reloc_status
bfd_reloc_dangerous	bfd.h	/^  bfd_reloc_dangerous$/;"	e	enum:bfd_reloc_status
bfd_reloc_notsupported	bfd.h	/^  bfd_reloc_notsupported,$/;"	e	enum:bfd_reloc_status
bfd_reloc_ok	bfd.h	/^  bfd_reloc_ok,$/;"	e	enum:bfd_reloc_status
bfd_reloc_other	bfd.h	/^  bfd_reloc_other,$/;"	e	enum:bfd_reloc_status
bfd_reloc_outofrange	bfd.h	/^  bfd_reloc_outofrange,$/;"	e	enum:bfd_reloc_status
bfd_reloc_overflow	bfd.h	/^  bfd_reloc_overflow,$/;"	e	enum:bfd_reloc_status
bfd_reloc_status	bfd.h	/^typedef enum bfd_reloc_status$/;"	g
bfd_reloc_status_type	bfd.h	/^ bfd_reloc_status_type;$/;"	t	typeref:enum:bfd_reloc_status
bfd_reloc_undefined	bfd.h	/^  bfd_reloc_undefined,$/;"	e	enum:bfd_reloc_status
bfd_section_alignment	bfd.h	314;"	d
bfd_section_lma	bfd.h	313;"	d
bfd_section_name	bfd.h	310;"	d
bfd_section_reloc_link_order	bfdlink.h	/^  bfd_section_reloc_link_order,	\/* Relocate against a section.  *\/$/;"	e	enum:bfd_link_order_type
bfd_section_size	bfd.h	311;"	d
bfd_section_vma	bfd.h	312;"	d
bfd_set_arch_mach	bfd.h	2535;"	d
bfd_set_cacheable	bfd.h	508;"	d
bfd_set_private_flags	bfd.h	2509;"	d
bfd_set_section	bfd.h	266;"	d
bfd_set_section_alignment	bfd.h	321;"	d
bfd_set_section_userdata	bfd.h	322;"	d
bfd_set_section_vma	bfd.h	320;"	d
bfd_signed_vma	bfd.h	/^typedef BFD_HOST_64_BIT bfd_signed_vma;$/;"	t
bfd_signed_vma	bfd.h	/^typedef long bfd_signed_vma;$/;"	t
bfd_size_type	bfd.h	/^typedef BFD_HOST_U_64_BIT bfd_size_type;$/;"	t
bfd_size_type	bfd.h	/^typedef unsigned long bfd_size_type;$/;"	t
bfd_sizeof_headers	bfd.h	2512;"	d
bfd_stat_arch_elt	bfd.h	2529;"	d
bfd_symbol_reloc_link_order	bfdlink.h	/^  bfd_symbol_reloc_link_order	\/* Relocate against a symbol.  *\/$/;"	e	enum:bfd_link_order_type
bfd_target	bfd.h	/^typedef struct bfd_target$/;"	s
bfd_target	bfd.h	/^} bfd_target;$/;"	t	typeref:struct:bfd_target
bfd_target_aout_flavour	bfd.h	/^  bfd_target_aout_flavour,$/;"	e	enum:bfd_flavour
bfd_target_coff_flavour	bfd.h	/^  bfd_target_coff_flavour,$/;"	e	enum:bfd_flavour
bfd_target_ecoff_flavour	bfd.h	/^  bfd_target_ecoff_flavour,$/;"	e	enum:bfd_flavour
bfd_target_elf_flavour	bfd.h	/^  bfd_target_elf_flavour,$/;"	e	enum:bfd_flavour
bfd_target_evax_flavour	bfd.h	/^  bfd_target_evax_flavour$/;"	e	enum:bfd_flavour
bfd_target_ieee_flavour	bfd.h	/^  bfd_target_ieee_flavour,$/;"	e	enum:bfd_flavour
bfd_target_ihex_flavour	bfd.h	/^  bfd_target_ihex_flavour,$/;"	e	enum:bfd_flavour
bfd_target_msdos_flavour	bfd.h	/^  bfd_target_msdos_flavour,$/;"	e	enum:bfd_flavour
bfd_target_nlm_flavour	bfd.h	/^  bfd_target_nlm_flavour,$/;"	e	enum:bfd_flavour
bfd_target_oasys_flavour	bfd.h	/^  bfd_target_oasys_flavour,$/;"	e	enum:bfd_flavour
bfd_target_os9k_flavour	bfd.h	/^  bfd_target_os9k_flavour,$/;"	e	enum:bfd_flavour
bfd_target_ovax_flavour	bfd.h	/^  bfd_target_ovax_flavour,$/;"	e	enum:bfd_flavour
bfd_target_som_flavour	bfd.h	/^  bfd_target_som_flavour,$/;"	e	enum:bfd_flavour
bfd_target_srec_flavour	bfd.h	/^  bfd_target_srec_flavour,$/;"	e	enum:bfd_flavour
bfd_target_tekhex_flavour	bfd.h	/^  bfd_target_tekhex_flavour,$/;"	e	enum:bfd_flavour
bfd_target_unknown_flavour	bfd.h	/^  bfd_target_unknown_flavour,$/;"	e	enum:bfd_flavour
bfd_target_versados_flavour	bfd.h	/^  bfd_target_versados_flavour,$/;"	e	enum:bfd_flavour
bfd_tttrue	bfd.h	/^typedef enum bfd_boolean {bfd_fffalse, bfd_tttrue} boolean;$/;"	e	enum:bfd_boolean
bfd_type_end	bfd.h	/^	      bfd_type_end}	\/* marks the end; don't use it! *\/$/;"	e	enum:bfd_format
bfd_und_section_ptr	bfd.h	1131;"	d
bfd_undefined_link_order	bfdlink.h	/^  bfd_undefined_link_order,	\/* Undefined.  *\/$/;"	e	enum:bfd_link_order_type
bfd_unknown	bfd.h	/^	      bfd_unknown = 0,	\/* file format is unknown *\/$/;"	e	enum:bfd_format
bfd_update_armap_timestamp	bfd.h	2532;"	d
bfd_usrdata	bfd.h	499;"	d
bfd_valid_reloc_types	bfd.h	498;"	d
bfd_vma	bfd.h	/^typedef BFD_HOST_U_64_BIT bfd_vma;$/;"	t
bfd_vma	bfd.h	/^typedef unsigned long bfd_vma;$/;"	t
bfd_window	bfd.h	/^} bfd_window;$/;"	t	typeref:struct:_bfd_window
bfd_window_internal	bfd.h	/^typedef struct _bfd_window_internal bfd_window_internal;$/;"	t	typeref:struct:_bfd_window_internal
bidirectional_iterator	g++/stl_iterator.h	/^struct bidirectional_iterator {$/;"	s
bidirectional_iterator_tag	g++/stl_iterator.h	/^struct bidirectional_iterator_tag :       \/\/++--$/;"	s
bin	g++/streambuf.h	/^	bin = _IOS_BIN, \/\/ Deprecated - ANSI uses ios::binary.$/;"	e	enum:ios::open_mode
binary	g++/streambuf.h	/^	binary = _IOS_BIN };$/;"	e	enum:ios::open_mode
binary_compose	g++/stl_function.h	/^  binary_compose(const Operation1& x, const Operation2& y, $/;"	f	class:binary_compose
binary_compose	g++/stl_function.h	/^class binary_compose$/;"	c
binary_function	g++/stl_function.h	/^struct binary_function {$/;"	s
binary_negate	g++/stl_function.h	/^  explicit binary_negate(const Predicate& x) : pred(x) {}$/;"	f	class:binary_negate
binary_negate	g++/stl_function.h	/^class binary_negate $/;"	c
binary_search	g++/stl_algo.h	/^bool binary_search(ForwardIterator first, ForwardIterator last, const T& value,$/;"	f
binary_search	g++/stl_algo.h	/^bool binary_search(ForwardIterator first, ForwardIterator last,$/;"	f
bind1st	g++/stl_function.h	/^inline binder1st<Operation> bind1st(const Operation& op, const T& x) {$/;"	f
bind2nd	g++/stl_function.h	/^inline binder2nd<Operation> bind2nd(const Operation& op, const T& x) {$/;"	f
binder1st	g++/stl_function.h	/^  binder1st(const Operation& x,$/;"	f	class:binder1st
binder1st	g++/stl_function.h	/^class binder1st$/;"	c
binder2nd	g++/stl_function.h	/^  binder2nd(const Operation& x,$/;"	f	class:binder2nd
binder2nd	g++/stl_function.h	/^class binder2nd$/;"	c
bit_alloc	g++/stl_bvector.h	/^  unsigned int* bit_alloc(size_type n) {$/;"	f	class:vector
bit_vector	g++/stl_bvector.h	/^typedef vector<bool, alloc> bit_vector;$/;"	t
bitand	include/iso646.h	6;"	d
bitor	include/iso646.h	7;"	d
bitpos	bfd.h	/^  unsigned int bitpos;$/;"	m	struct:reloc_howto_struct
bits_per_address	bfd.h	/^  int bits_per_address;$/;"	m	struct:bfd_arch_info
bits_per_byte	bfd.h	/^  int bits_per_byte;$/;"	m	struct:bfd_arch_info
bits_per_word	bfd.h	/^  int bits_per_word;$/;"	m	struct:bfd_arch_info
bitsize	bfd.h	/^  unsigned int bitsize;$/;"	m	struct:reloc_howto_struct
bkt_num	g++/stl_hashtable.h	/^  size_type bkt_num(const value_type& obj) const$/;"	f	class:hashtable
bkt_num	g++/stl_hashtable.h	/^  size_type bkt_num(const value_type& obj, size_t n) const$/;"	f	class:hashtable
bkt_num_key	g++/stl_hashtable.h	/^  size_type bkt_num_key(const key_type& key) const$/;"	f	class:hashtable
bkt_num_key	g++/stl_hashtable.h	/^  size_type bkt_num_key(const key_type& key, size_t n) const$/;"	f	class:hashtable
blen	g++/streambuf.h	/^    int blen() const { return _IO_buf_end - _IO_buf_base; }$/;"	f	struct:streambuf
blockModeProc	tcl.h	/^    Tcl_DriverBlockModeProc *blockModeProc;$/;"	m	struct:Tcl_ChannelType
bool	g++/stl_config.h	/^    typedef int bool;$/;"	t
bool	include/stdbool.h	/^  } bool;$/;"	t	typeref:enum:__anon14
bool	include/stdbool.h	/^  } bool;$/;"	t	typeref:enum:__anon39
boolean	bfd.h	/^typedef enum bfd_boolean {bfd_fffalse, bfd_tttrue} boolean;$/;"	t	typeref:enum:bfd_boolean
boolean	bfd.h	/^typedef enum bfd_boolean {false, true} boolean;$/;"	t	typeref:enum:bfd_boolean
both_direction	bfd.h	/^                        both_direction = 3} direction;$/;"	e	enum:_bfd::bfd_direction
bout_data	bfd.h	/^      struct bout_data_struct *bout_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::bout_data_struct
bucketPtr	tcl.h	/^    struct Tcl_HashEntry **bucketPtr;	\/* Pointer to bucket that points to$/;"	m	struct:Tcl_HashEntry	typeref:struct:Tcl_HashEntry::Tcl_HashEntry
bucket_count	g++/stl_hash_map.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_map
bucket_count	g++/stl_hash_map.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_multimap
bucket_count	g++/stl_hash_set.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_multiset
bucket_count	g++/stl_hash_set.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_set
bucket_count	g++/stl_hashtable.h	/^  size_type bucket_count() const { return buckets.size(); }$/;"	f	class:hashtable
buckets	g++/stl_hashtable.h	/^  vector<node*,Alloc> buckets;$/;"	m	class:hashtable
buckets	tcl.h	/^    Tcl_HashEntry **buckets;		\/* Pointer to bucket array.  Each$/;"	m	struct:Tcl_HashTable
buf_char	g++/editbuf.h	/^typedef \/*unsigned*\/ char buf_char;$/;"	t
buf_count	g++/stl_rope.h	/^	size_t buf_count;$/;"	m	class:sequence_buffer
buf_end	g++/parsestream.h	/^    char *buf_end;$/;"	m	class:parsebuf
buf_end	g++/stl_rope.h	/^    __GC_CONST charT * buf_end;$/;"	m	class:__rope_iterator_base
buf_index	g++/editbuf.h	/^typedef long buf_index;$/;"	t
buf_offset	g++/editbuf.h	/^typedef long buf_offset; $/;"	t
buf_ptr	g++/ropeimpl.h	/^	charT * buf_ptr;$/;"	m	class:__rope_flatten_char_consumer
buf_ptr	g++/stl_rope.h	/^    __GC_CONST charT * buf_ptr;$/;"	m	class:__rope_iterator_base
buf_size	g++/editbuf.h	/^    int buf_size;$/;"	m	struct:edit_buffer
buf_start	g++/parsestream.h	/^    char *buf_start;$/;"	m	class:parsebuf
buf_start	g++/stl_rope.h	/^    __GC_CONST charT * buf_start;$/;"	m	class:__rope_iterator_base
buffer	g++/editbuf.h	/^    struct edit_buffer *buffer; \/\/ buffer that 'start' and 'end' belong to$/;"	m	struct:edit_string	typeref:struct:edit_string::edit_buffer
buffer	g++/ropeimpl.h	/^	charT * buffer;$/;"	m	class:__rope_flatten_char_consumer
buffer	g++/ropeimpl.h	/^	charT * buffer;$/;"	m	class:__rope_insert_char_consumer
buffer	g++/stl_rope.h	/^	value_type buffer[buf_sz];$/;"	m	class:sequence_buffer
buffer	g++/stl_tempbuf.h	/^  T* buffer;$/;"	m	class:temporary_buffer
buffer_size	g++/stl_deque.h	/^	static size_t buffer_size() {return __deque_buf_size(BufSiz, sizeof(T)); }$/;"	f	struct:std::__deque_iterator
buffer_size	g++/stl_deque.h	/^	static size_type buffer_size() { return __deque_buf_size(BufSiz, sizeof(value_type));}$/;"	f	class:std::deque
buffered	g++/stdiostream.h	/^    int buffered () const { return _flags & _IO_UNBUFFERED ? 0 : 1; }$/;"	f	class:stdiobuf
buffered	g++/stdiostream.h	/^  int buffered () const { return _file.buffered (); }$/;"	f	class:istdiostream
buffered	g++/stdiostream.h	/^  int buffered () const { return _file.buffered (); }$/;"	f	class:ostdiostream
buffered	g++/stdiostream.h	/^  void buffered (int _i) { _file.buffered (_i); }$/;"	f	class:istdiostream
buffered	g++/stdiostream.h	/^  void buffered (int _i) { _file.buffered (_i); }$/;"	f	class:ostdiostream
builtinbuf	g++/builtinbuf.h	/^  builtinbuf() { }$/;"	f	class:builtinbuf
builtinbuf	g++/builtinbuf.h	/^class builtinbuf : public streambuf {$/;"	c
bump_down	g++/stl_bvector.h	/^  void bump_down() {$/;"	f	struct:__bit_const_iterator
bump_down	g++/stl_bvector.h	/^  void bump_down() {$/;"	f	struct:__bit_iterator
bump_up	g++/stl_bvector.h	/^  void bump_up() {$/;"	f	struct:__bit_const_iterator
bump_up	g++/stl_bvector.h	/^  void bump_up() {$/;"	f	struct:__bit_iterator
by	bfd.h	/^  bfd *by;$/;"	m	struct:bfd_link_needed_list
byteorder	bfd.h	/^  enum bfd_endian byteorder;$/;"	m	struct:bfd_target	typeref:enum:bfd_target::bfd_endian
bytes	tcl.h	/^    char *bytes;		\/* This points to the first byte of the$/;"	m	struct:Tcl_Obj
c	bfdlink.h	/^	} c;$/;"	m	union:bfd_link_hash_entry::__anon59	typeref:struct:bfd_link_hash_entry::__anon59::__anon63
c	g++/stl_queue.h	/^	Sequence c;$/;"	m	class:priority_queue
c	g++/stl_queue.h	/^	Sequence c;$/;"	m	class:queue
c	g++/stl_stack.h	/^  Sequence c;$/;"	m	class:stack
c_str	g++/ropeimpl.h	/^const charT * rope<charT,Alloc>::c_str() const {$/;"	f	class:rope
c_str	g++/std/bastring.h	/^	const charT* c_str() const$/;"	f	class:basic_string
c_string	g++/stl_rope.h	/^    __GC_CONST charT * c_string;$/;"	m	struct:__rope_RopeBase
cacheable	bfd.h	/^    boolean cacheable;$/;"	m	struct:_bfd
callbacks	bfdlink.h	/^  const struct bfd_link_callbacks *callbacks;$/;"	m	struct:bfd_link_info	typeref:struct:bfd_link_info::bfd_link_callbacks
capacity	g++/std/bastring.h	/^	size_type capacity() const { return rep()->res; }$/;"	f	class:basic_string
capacity	g++/stl_bvector.h	/^  size_type capacity() const {$/;"	f	class:vector
capacity	g++/stl_rope.h	/^	    size_type capacity() const {$/;"	f	class:rope
capacity	g++/stl_vector.h	/^	size_type capacity() const { return size_type(end_of_storage - begin()); }$/;"	f	class:vector
carsym	bfd.h	/^typedef struct carsym {$/;"	s
carsym	bfd.h	/^} carsym;			\/* to make these you call a carsymogen *\/$/;"	t	typeref:struct:carsym
chain	g++/editbuf.h	/^    struct edit_mark *chain;$/;"	m	struct:edit_mark	typeref:struct:edit_mark::edit_mark
chain	g++/parsestream.h	/^    parsebuf *chain;$/;"	m	class:parsebuf
changes	tk.h	/^    XWindowChanges changes;$/;"	m	struct:Tk_FakeWin
char_producer	g++/stl_rope.h	/^class char_producer {$/;"	c
char_ptr_len	g++/ropeimpl.h	/^inline size_t rope<charT,Alloc>::char_ptr_len(const charT *s)$/;"	f	class:rope
char_type	g++/std/straits.h	/^	typedef charT char_type; \/\/ for users to acquire the basic character type$/;"	t	struct:string_char_traits
char_type	g++/std/straits.h	/^  typedef char char_type;$/;"	t	struct:string_char_traits
check	g++/ropeimpl.h	/^void __rope_iterator<charT,Alloc>::check() {$/;"	f	class:__rope_iterator
checkArgvProc	tix.h	/^    Tix_CheckArgvProc   checkArgvProc;$/;"	m	struct:_Tix_SubCmdInfo
check_realloc	g++/std/bastring.cc	/^check_realloc(basic_string::size_type s) const$/;"	f	class:basic_string
chunk_alloc	g++/stl_alloc.h	/^__default_alloc_template<threads, inst>::chunk_alloc(size_t size, int& nobjs) $/;"	f	class:__default_alloc_template
cisco_core_data	bfd.h	/^      struct cisco_core_struct *cisco_core_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::cisco_core_struct
ckalloc	tcl.h	669;"	d
ckalloc	tcl.h	692;"	d
ckalloc	tcl.h	696;"	d
ckfree	tcl.h	670;"	d
ckfree	tcl.h	693;"	d
ckfree	tcl.h	697;"	d
ckrealloc	tcl.h	671;"	d
ckrealloc	tcl.h	694;"	d
ckrealloc	tcl.h	698;"	d
classUid	tk.h	/^    Tk_Uid classUid;$/;"	m	struct:Tk_FakeWin
clear	g++/stl_bvector.h	/^  void clear() { erase(begin(), end()); }$/;"	f	class:vector
clear	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::clear() $/;"	f	class:std::deque
clear	g++/stl_hash_map.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_map
clear	g++/stl_hash_map.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_multimap
clear	g++/stl_hash_set.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_multiset
clear	g++/stl_hash_set.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_set
clear	g++/stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::clear()$/;"	f	class:hashtable
clear	g++/stl_list.h	/^void list<T, Alloc>::clear(){$/;"	f	class:std::list
clear	g++/stl_map.h	/^  void clear() { t.clear(); }$/;"	f	class:map
clear	g++/stl_multimap.h	/^  void clear() { t.clear(); }$/;"	f	class:multimap
clear	g++/stl_multiset.h	/^  void clear() { t.clear(); }$/;"	f	class:multiset
clear	g++/stl_set.h	/^  void clear() { t.clear(); }$/;"	f	class:set
clear	g++/stl_slist.h	/^	void clear() { erase_after(&head, 0); }$/;"	f	class:std::slist
clear	g++/stl_tree.h	/^  void clear() {$/;"	f	class:rb_tree
clear	g++/stl_vector.h	/^	void clear() { erase(begin(), end()); }$/;"	f	class:vector
clear	g++/streambuf.h	/^    void clear(iostate state = 0) {$/;"	f	class:ios
clearerr	g++/iostdio.h	62;"	d
clientData	tcl.h	/^    ClientData clientData;		\/* Application stores something here$/;"	m	struct:Tcl_HashEntry
clientData	tcl.h	/^    ClientData clientData;	 \/* ClientData for string proc. *\/$/;"	m	struct:Tcl_CmdInfo
clientData	tcl.h	/^    ClientData clientData;      \/* Arbitrary value associated with this$/;"	m	struct:Tcl_Namespace
clientData	tk.h	/^    ClientData clientData;		\/* Arbitrary one-word value used by$/;"	m	struct:Tk_CustomOption
client_data	g++/stl_alloc.h	/^        char client_data[1];    \/* The client sees this.*\/$/;"	m	union:__default_alloc_template::obj
clone	g++/std/bastring.cc	/^clone()$/;"	f	class:basic_string::Rep
clone_node	g++/stl_tree.h	/^  link_type clone_node(link_type x) {$/;"	f	class:rb_tree
close	g++/libio.h	/^  int (*close) __P ((struct _IO_FILE *));$/;"	m	struct:__anon3
close	g++/libio.h	/^  int (*close) __P ((struct _IO_FILE *));$/;"	m	struct:__anon74
close	g++/procbuf.h	/^    procbuf *close() { return (procbuf*)filebuf::close(); }$/;"	f	class:procbuf
close	g++/streambuf.h	71;"	d
closeProc	tcl.h	/^    Tcl_DriverCloseProc *closeProc;	\/* Procedure to call to close$/;"	m	struct:Tcl_ChannelType
cmdProc	tix.h	/^    int (*cmdProc) _ANSI_ARGS_((ClientData clientData, Tcl_Interp *interp,$/;"	m	struct:__anon58
coff_obj_data	bfd.h	/^      struct coff_tdata *coff_obj_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::coff_tdata
color	g++/stl_tree.h	/^	color_type 					 color; $/;"	m	struct:__rb_tree_node_base
color	g++/stl_tree.h	/^  static color_type& color(base_ptr x) { return (color_type&)(link_type(x)->color); }$/;"	f	class:rb_tree
color	g++/stl_tree.h	/^  static color_type& color(link_type x) { return (color_type&)(x->color); }$/;"	f	class:rb_tree
color_type	g++/stl_tree.h	/^	typedef __rb_tree_color_type color_type;$/;"	t	struct:__rb_tree_node_base
color_type	g++/stl_tree.h	/^  typedef __rb_tree_color_type color_type;$/;"	t	class:rb_tree
comp	g++/stl_map.h	/^    Compare comp;$/;"	m	class:map::value_compare
comp	g++/stl_multimap.h	/^    Compare comp;$/;"	m	class:multimap::value_compare
comp	g++/stl_queue.h	/^	Compare comp;$/;"	m	class:priority_queue
compare	g++/ropeimpl.h	/^rope<charT,Alloc>::compare (const RopeBase *left, const RopeBase *right)$/;"	f	class:rope
compare	g++/std/bastring.cc	/^compare (const basic_string& str, size_type pos, size_type n) const$/;"	f	class:basic_string
compare	g++/std/bastring.cc	/^compare (const charT* s, size_type pos, size_type n) const$/;"	f	class:basic_string
compare	g++/std/bastring.h	/^	int compare (const charT* s, size_type pos = 0) const$/;"	f	class:basic_string
compare	g++/std/straits.h	/^	static int compare(const char_type* s1, const char_type* s2, size_t n)$/;"	f	struct:string_char_traits
compare	g++/std/straits.h	/^  static int compare (const char_type* s1, const char_type* s2, size_t n)$/;"	f	struct:string_char_traits
compare	g++/stl_rope.h	/^	int compare(const rope &y) const {$/;"	f	class:rope
compatible	bfd.h	/^  const struct bfd_arch_info * (*compatible)$/;"	m	struct:bfd_arch_info	typeref:struct:bfd_arch_info::compatible
compl	include/iso646.h	8;"	d
complain_on_overflow	bfd.h	/^  enum complain_overflow complain_on_overflow;$/;"	m	struct:reloc_howto_struct	typeref:enum:reloc_howto_struct::complain_overflow
complain_overflow	bfd.h	/^enum complain_overflow$/;"	g
complain_overflow_bitfield	bfd.h	/^  complain_overflow_bitfield,$/;"	e	enum:complain_overflow
complain_overflow_dont	bfd.h	/^  complain_overflow_dont,$/;"	e	enum:complain_overflow
complain_overflow_signed	bfd.h	/^  complain_overflow_signed,$/;"	e	enum:complain_overflow
complain_overflow_unsigned	bfd.h	/^  complain_overflow_unsigned$/;"	e	enum:complain_overflow
complex	g++/std/complext.h	/^  complex (_FLT r = 0, _FLT i = 0): re (r), im (i) { }$/;"	f	class:complex
complex	g++/std/complext.h	/^class complex$/;"	c
complex	g++/std/dcomplex.h	/^  complex (const complex<float>& r): re (r.real ()), im (r.imag ()) { }$/;"	f	class:complex
complex	g++/std/dcomplex.h	/^  complex (double r = 0, double i = 0): re (r), im (i) { }$/;"	f	class:complex
complex	g++/std/dcomplex.h	/^class complex<double>$/;"	c
complex	g++/std/dcomplex.h	/^inline complex<float>::complex (const complex<double>& r)$/;"	f	class:complex
complex	g++/std/fcomplex.h	/^  complex (float r = 0, float i = 0): re (r), im (i) { }$/;"	f	class:complex
complex	g++/std/fcomplex.h	/^class complex<float>$/;"	c
complex	g++/std/ldcomplex.h	/^  complex (const complex<double>& r): re (r.real ()), im (r.imag ()) { }$/;"	f	class:complex
complex	g++/std/ldcomplex.h	/^  complex (const complex<float>& r): re (r.real ()), im (r.imag ()) { }$/;"	f	class:complex
complex	g++/std/ldcomplex.h	/^  complex (long double r = 0, long double i = 0): re (r), im (i) { }$/;"	f	class:complex
complex	g++/std/ldcomplex.h	/^class complex<long double>$/;"	c
complex	g++/std/ldcomplex.h	/^inline complex<double>::complex (const complex<long double>& r)$/;"	f	class:complex
complex	g++/std/ldcomplex.h	/^inline complex<float>::complex (const complex<long double>& r)$/;"	f	class:complex
compose1	g++/stl_function.h	/^inline unary_compose<Operation1, Operation2> compose1(const Operation1& op1, $/;"	f
compose2	g++/stl_function.h	/^compose2(const Operation1& op1, const Operation2& op2, const Operation3& op3) {$/;"	f
concat	g++/ropeimpl.h	/^rope<charT,Alloc>::concat(RopeBase * left, RopeBase * right)$/;"	f	class:rope
concat	g++/stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon80
concat	g++/stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon9
concat_and_set_balanced	g++/stl_rope.h	/^	static RopeBase * concat_and_set_balanced(RopeBase *left,$/;"	f	class:rope
concat_char_iter	g++/ropeimpl.h	/^rope<charT,Alloc>::RopeBase * rope<charT,Alloc>::concat_char_iter$/;"	f	class:rope
concat_fn	g++/stl_rope.h	/^	struct concat_fn$/;"	s	class:rope
configProc	tk.h	/^    Tk_ItemConfigureProc *configProc;	\/* Procedure to call to change$/;"	m	struct:Tk_ItemType
configSpecs	tk.h	/^    Tk_ConfigSpec *configSpecs;		\/* Pointer to array of configuration$/;"	m	struct:Tk_ItemType
conj	g++/std/complext.h	/^conj (const complex<_FLT>& x) $/;"	f
const	ansidecl.h	134;"	d
const	g++/libio.h	75;"	d
const_address	g++/defalloc.h	/^    const_pointer const_address(const_reference x) $/;"	f	class:allocator
const_begin	g++/stl_rope.h	/^	const_iterator const_begin() const {$/;"	f	class:rope
const_end	g++/stl_rope.h	/^	const_iterator const_end() const {$/;"	f	class:rope
const_iterator	g++/std/bastring.h	/^	typedef const_pointer 							const_iterator;$/;"	t	class:basic_string
const_iterator	g++/stl_bvector.h	/^  typedef __bit_const_iterator          const_iterator;$/;"	t	class:vector
const_iterator	g++/stl_bvector.h	/^  typedef __bit_const_iterator const_iterator;$/;"	t	struct:__bit_const_iterator
const_iterator	g++/stl_deque.h	/^	typedef __deque_iterator<T, const T&, const T&, BufSiz>  const_iterator;$/;"	t	class:std::deque
const_iterator	g++/stl_deque.h	/^	typedef __deque_iterator<T, const T&, const T*, BufSiz> 	const_iterator;$/;"	t	struct:std::__deque_iterator
const_iterator	g++/stl_hash_map.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_map
const_iterator	g++/stl_hash_map.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_multimap
const_iterator	g++/stl_hash_set.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_multiset
const_iterator	g++/stl_hash_set.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_set
const_iterator	g++/stl_hashtable.h	/^          const_iterator;$/;"	t	struct:__hashtable_const_iterator
const_iterator	g++/stl_hashtable.h	/^          const_iterator;$/;"	t	struct:__hashtable_iterator
const_iterator	g++/stl_hashtable.h	/^  const_iterator;$/;"	t	class:hashtable
const_iterator	g++/stl_list.h	/^	typedef __list_iterator<T, const T&, const T*> 	const_iterator;$/;"	t	class:std::list
const_iterator	g++/stl_list.h	/^	typedef __list_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:std::__list_iterator
const_iterator	g++/stl_map.h	/^  typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:map
const_iterator	g++/stl_multimap.h	/^  typedef typename rep_type::const_iterator const_iterator; $/;"	t	class:multimap
const_iterator	g++/stl_multiset.h	/^  typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:multiset
const_iterator	g++/stl_rope.h	/^	typedef __rope_const_iterator<charT,Alloc> const_iterator;$/;"	t	class:rope
const_iterator	g++/stl_set.h	/^  typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:set
const_iterator	g++/stl_slist.h	/^	typedef __slist_iterator<T, const T&, const T*> const_iterator;$/;"	t	class:std::slist
const_iterator	g++/stl_slist.h	/^	typedef __slist_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:std::__slist_iterator
const_iterator	g++/stl_tree.h	/^	typedef __rb_tree_iterator<Value, const Value&, const Value*> 	const_iterator;$/;"	t	struct:__rb_tree_iterator
const_iterator	g++/stl_tree.h	/^          const_iterator;$/;"	t	class:rb_tree
const_iterator	g++/stl_vector.h	/^	typedef const value_type* 					const_iterator;$/;"	t	class:vector
const_mem_fun1_ref_t	g++/stl_function.h	/^  explicit const_mem_fun1_ref_t(void (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_ref_t
const_mem_fun1_ref_t	g++/stl_function.h	/^class const_mem_fun1_ref_t : public binary_function<T, A, S> {$/;"	c
const_mem_fun1_ref_t	g++/stl_function.h	/^class const_mem_fun1_ref_t<void, T, A> : public binary_function<T, A, void> {$/;"	c
const_mem_fun1_t	g++/stl_function.h	/^  explicit const_mem_fun1_t(void (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_t
const_mem_fun1_t	g++/stl_function.h	/^class const_mem_fun1_t : public binary_function<const T*, A, S> {$/;"	c
const_mem_fun1_t	g++/stl_function.h	/^class const_mem_fun1_t<void, T, A> : public binary_function<const T*, A, void> {$/;"	c
const_mem_fun_ref_t	g++/stl_function.h	/^  explicit const_mem_fun_ref_t(void (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_ref_t
const_mem_fun_ref_t	g++/stl_function.h	/^class const_mem_fun_ref_t : public unary_function<T, S> {$/;"	c
const_mem_fun_ref_t	g++/stl_function.h	/^class const_mem_fun_ref_t<void, T> : public unary_function<T, void> {$/;"	c
const_mem_fun_t	g++/stl_function.h	/^  explicit const_mem_fun_t(void (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_t
const_mem_fun_t	g++/stl_function.h	/^class const_mem_fun_t : public unary_function<const T*, S> {$/;"	c
const_mem_fun_t	g++/stl_function.h	/^class const_mem_fun_t<void, T> : public unary_function<const T*, void> {$/;"	c
const_pointer	g++/defalloc.h	/^    typedef const T* const_pointer;$/;"	t	class:allocator
const_pointer	g++/std/bastring.h	/^	typedef const charT* 							const_pointer;$/;"	t	class:basic_string
const_pointer	g++/stl_bvector.h	/^  typedef const bool* const_pointer;$/;"	t	class:vector
const_pointer	g++/stl_deque.h	/^	typedef const value_type* 								const_pointer;$/;"	t	class:std::deque
const_pointer	g++/stl_hash_map.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_map
const_pointer	g++/stl_hash_map.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_multimap
const_pointer	g++/stl_hash_set.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_multiset
const_pointer	g++/stl_hash_set.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_set
const_pointer	g++/stl_hashtable.h	/^  typedef const value_type* const_pointer;$/;"	t	class:hashtable
const_pointer	g++/stl_list.h	/^	typedef const value_type* 						const_pointer;$/;"	t	class:std::list
const_pointer	g++/stl_map.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:map
const_pointer	g++/stl_multimap.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:multimap
const_pointer	g++/stl_multiset.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:multiset
const_pointer	g++/stl_rope.h	/^	typedef const charT* const_pointer;$/;"	t	class:rope
const_pointer	g++/stl_set.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:set
const_pointer	g++/stl_slist.h	/^	typedef const value_type* 						const_pointer;$/;"	t	class:std::slist
const_pointer	g++/stl_tree.h	/^  typedef const value_type* const_pointer;$/;"	t	class:rb_tree
const_pointer	g++/stl_vector.h	/^	typedef const value_type* 					const_pointer;$/;"	t	class:vector
const_rbegin	g++/stl_rope.h	/^	const_reverse_iterator const_rbegin() const {$/;"	f	class:rope
const_reference	g++/defalloc.h	/^    typedef const T& const_reference;$/;"	t	class:allocator
const_reference	g++/std/bastring.h	/^	typedef const charT& 							const_reference;$/;"	t	class:basic_string
const_reference	g++/stl_bvector.h	/^  typedef bool                 const_reference;$/;"	t	struct:__bit_const_iterator
const_reference	g++/stl_bvector.h	/^  typedef bool const_reference;$/;"	t	class:vector
const_reference	g++/stl_deque.h	/^	typedef const value_type& 								const_reference;$/;"	t	class:std::deque
const_reference	g++/stl_hash_map.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_map
const_reference	g++/stl_hash_map.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_multimap
const_reference	g++/stl_hash_set.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_multiset
const_reference	g++/stl_hash_set.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_set
const_reference	g++/stl_hashtable.h	/^  typedef const value_type& const_reference;$/;"	t	class:hashtable
const_reference	g++/stl_list.h	/^	typedef const value_type& 						const_reference;$/;"	t	class:std::list
const_reference	g++/stl_map.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:map
const_reference	g++/stl_multimap.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:multimap
const_reference	g++/stl_multiset.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:multiset
const_reference	g++/stl_queue.h	/^	typedef typename Sequence::const_reference const_reference;$/;"	t	class:priority_queue
const_reference	g++/stl_queue.h	/^	typedef typename Sequence::const_reference const_reference;$/;"	t	class:queue
const_reference	g++/stl_rope.h	/^	typedef charT const_reference;$/;"	t	class:rope
const_reference	g++/stl_set.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:set
const_reference	g++/stl_slist.h	/^	typedef const value_type& 						const_reference;$/;"	t	class:std::slist
const_reference	g++/stl_stack.h	/^  typedef typename Sequence::const_reference const_reference;$/;"	t	class:stack
const_reference	g++/stl_tree.h	/^  typedef const value_type& const_reference;$/;"	t	class:rb_tree
const_reference	g++/stl_vector.h	/^	typedef const value_type& 					const_reference;$/;"	t	class:vector
const_rend	g++/stl_rope.h	/^	const_reverse_iterator const_rend() const {$/;"	f	class:rope
const_reverse_iterator	g++/std/bastring.h	/^	typedef ::reverse_iterator<const_iterator> 		const_reverse_iterator;$/;"	t	class:basic_string
const_reverse_iterator	g++/stl_bvector.h	/^                           difference_type> const_reverse_iterator;$/;"	t	class:vector
const_reverse_iterator	g++/stl_bvector.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:vector
const_reverse_iterator	g++/stl_deque.h	/^	typedef reverse_iterator<const_iterator> 				const_reverse_iterator;$/;"	t	class:std::deque
const_reverse_iterator	g++/stl_list.h	/^	typedef reverse_iterator<const_iterator> 		const_reverse_iterator;$/;"	t	class:std::list
const_reverse_iterator	g++/stl_map.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:map
const_reverse_iterator	g++/stl_multimap.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:multimap
const_reverse_iterator	g++/stl_multiset.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:multiset
const_reverse_iterator	g++/stl_rope.h	/^				 difference_type>  const_reverse_iterator;$/;"	t	class:rope
const_reverse_iterator	g++/stl_rope.h	/^        typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:rope
const_reverse_iterator	g++/stl_set.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:set
const_reverse_iterator	g++/stl_tree.h	/^          const_reverse_iterator;$/;"	t	class:rb_tree
const_reverse_iterator	g++/stl_tree.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:rb_tree
const_reverse_iterator	g++/stl_vector.h	/^	typedef reverse_iterator<const_iterator> 	const_reverse_iterator;$/;"	t	class:vector
constant0	g++/stl_function.h	/^inline constant_void_fun<Result> constant0(const Result& val)$/;"	f
constant1	g++/stl_function.h	/^inline constant_unary_fun<Result,Result> constant1(const Result& val)$/;"	f
constant2	g++/stl_function.h	/^inline constant_binary_fun<Result,Result,Result> constant2(const Result& val)$/;"	f
constant_binary_fun	g++/stl_function.h	/^  constant_binary_fun(const Result& v) : val(v) {}$/;"	f	struct:constant_binary_fun
constant_binary_fun	g++/stl_function.h	/^struct constant_binary_fun : public binary_function<Arg1, Arg2, Result> {$/;"	s
constant_unary_fun	g++/stl_function.h	/^  constant_unary_fun(const Result& v) : val(v) {}$/;"	f	struct:constant_unary_fun
constant_unary_fun	g++/stl_function.h	/^struct constant_unary_fun : public unary_function<Argument, Result> {$/;"	s
constant_void_fun	g++/stl_function.h	/^  constant_void_fun(const result_type& v) : val(v) {}$/;"	f	struct:constant_void_fun
constant_void_fun	g++/stl_function.h	/^struct constant_void_fun$/;"	s
construct	g++/stl_construct.h	/^construct(T1* p, const T2& value) $/;"	f	namespace:std
constructor	bfdlink.h	/^  boolean (*constructor) PARAMS ((struct bfd_link_info *,$/;"	m	struct:bfd_link_callbacks
constructor_chain	bfd.h	/^   struct relent_chain *constructor_chain;$/;"	m	struct:sec	typeref:struct:sec::relent_chain
container	g++/stl_iterator.h	/^  Container* container;$/;"	m	class:back_insert_iterator
container	g++/stl_iterator.h	/^  Container* container;$/;"	m	class:front_insert_iterator
container	g++/stl_iterator.h	/^  Container* container;$/;"	m	class:insert_iterator
container	g++/stl_rope.h	/^    rope<charT,Alloc>& container() { return *root_rope; }$/;"	f	class:__rope_iterator
contents	bfd.h	/^   unsigned char *contents;$/;"	m	struct:sec
contents	bfdlink.h	/^	  bfd_byte *contents;$/;"	m	struct:bfd_link_order::__anon64::__anon67
control_character_bit	readline/chardefs.h	23;"	d
control_character_threshold	readline/chardefs.h	21;"	d
cookie	g++/libio.h	/^  void *cookie;$/;"	m	struct:_IO_cookie_file
coordProc	tk.h	/^    Tk_ItemCoordProc *coordProc;	\/* Procedure to call to get and set$/;"	m	struct:Tk_ItemType
copy	g++/std/bastring.cc	/^copy (charT* s, size_type n, size_type pos) const$/;"	f	class:basic_string
copy	g++/std/bastring.cc	/^copy(size_t pos, const charT *s, size_t n)$/;"	f	class:basic_string::Rep
copy	g++/std/straits.h	/^	static char_type* copy(char_type* s1, const char_type* s2, size_t n)$/;"	f	struct:string_char_traits
copy	g++/std/straits.h	/^  static char_type* copy (char_type* s1, const char_type* s2, size_t n)$/;"	f	struct:string_char_traits
copy	g++/stl_algobase.h	/^copy(InputIterator first, InputIterator last, OutputIterator result)$/;"	f
copy	g++/stl_algobase.h	/^copy(const char* first, const char* last, char* result) $/;"	f
copy	g++/stl_algobase.h	/^copy(const wchar_t* first, const wchar_t* last, wchar_t* result) $/;"	f
copy	g++/stl_rope.h	/^	      size_type copy(charT *buffer, size_type n, size_type pos = 0)$/;"	f	class:rope
copy	g++/stl_rope.h	/^	size_type copy(size_type pos, size_type n, charT *buffer) const {$/;"	f	class:rope
copy	g++/stl_rope.h	/^	void copy(charT * buffer) const {$/;"	f	class:rope
copy_backward	g++/stl_algobase.h	/^copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last, BidirectionalIterator2 result) $/;"	f
copy_from	g++/stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::copy_from(const hashtable& ht)$/;"	f	class:hashtable
copy_max	g++/stl_rope.h	/^	enum { copy_max = 23 };$/;"	e	enum:rope::__anon13
copy_max	g++/stl_rope.h	/^	enum { copy_max = 23 };$/;"	e	enum:rope::__anon84
copy_n	g++/stl_algobase.h	/^copy_n(InputIterator first, Size count, OutputIterator result) $/;"	f
cos	g++/std/complext.cc	/^cos (const complex<FLOAT>& x)$/;"	f
cosh	g++/std/complext.cc	/^cosh (const complex<FLOAT>& x)$/;"	f
count	g++/ropeimpl.h	/^	size_t count;  \/\/ Number of nonmatching characters$/;"	m	class:__rope_find_char_char_consumer
count	g++/stl_algo.h	/^count(InputIterator first, InputIterator last, const T& value) {$/;"	f
count	g++/stl_algo.h	/^void count(InputIterator first, InputIterator last, const T& value, Size& n) $/;"	f
count	g++/stl_hash_map.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_map
count	g++/stl_hash_map.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_multimap
count	g++/stl_hash_set.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_multiset
count	g++/stl_hash_set.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_set
count	g++/stl_hashtable.h	/^  size_type count(const key_type& key) const$/;"	f	class:hashtable
count	g++/stl_map.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:map
count	g++/stl_multimap.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:multimap
count	g++/stl_multiset.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:multiset
count	g++/stl_set.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:set
count	g++/stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::count(const Key& k) const {$/;"	f	class:rb_tree
count_if	g++/stl_algo.h	/^count_if(InputIterator first, InputIterator last, Predicate pred) $/;"	f
count_if	g++/stl_algo.h	/^void count_if(InputIterator first, InputIterator last, Predicate pred, Size& n) $/;"	f
create	g++/std/bastring.cc	/^create(size_t extra)$/;"	f	class:basic_string::Rep
createProc	tcl.h	/^    Tcl_HashEntry *(*createProc) _ANSI_ARGS_((struct Tcl_HashTable *tablePtr,$/;"	m	struct:Tcl_HashTable
createProc	tk.h	/^    Tk_ImageCreateProc *createProc;$/;"	m	struct:Tk_ImageType
createProc	tk.h	/^    Tk_ItemCreateProc *createProc;	\/* Procedure to create a new item of$/;"	m	struct:Tk_ItemType
create_map_and_nodes	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::create_map_and_nodes(size_type num_elements) $/;"	f	class:std::deque
create_node	g++/stl_list.h	/^	link_type create_node(const T& x) {$/;"	f	class:std::list
create_node	g++/stl_slist.h	/^	static list_node* create_node(const value_type& x) {$/;"	f	class:std::slist
create_node	g++/stl_tree.h	/^  link_type create_node(const value_type& x) {$/;"	f	class:rb_tree
create_object_symbols_section	bfdlink.h	/^  asection *create_object_symbols_section;$/;"	m	struct:bfd_link_info
creator	bfdlink.h	/^  const bfd_target *creator;$/;"	m	struct:bfd_link_hash_table
crope	g++/stl_rope.h	/^typedef rope<char, __ALLOC> crope;$/;"	t
cstrptr	g++/stl_rope.h	/^	typedef __GC_CONST charT * cstrptr;$/;"	t	class:rope
cur	g++/stl_deque.h	/^	T* cur;   			\/\/$/;"	m	struct:std::__deque_iterator
cur	g++/stl_hashtable.h	/^  const node* cur;$/;"	m	struct:__hashtable_const_iterator
cur	g++/stl_hashtable.h	/^  node* cur;$/;"	m	struct:__hashtable_iterator
cur	g++/streambuf.h	/^    enum seek_dir { beg, cur, end};$/;"	e	enum:ios::seek_dir
cur_ptr	g++/streambuf.h	/^    char* cur_ptr() { return is_reading() ?  gptr() : pptr(); }$/;"	f	class:filebuf
curr	tix.h	/^    char * curr;$/;"	m	struct:Tix_ListIterator
current	g++/editbuf.h	/^    buf_char* current() { return is_reading() ? gptr() : pptr(); }$/;"	f	struct:edit_streambuf
current	g++/stl_iterator.h	/^  BidirectionalIterator current;$/;"	m	class:reverse_bidirectional_iterator
current	g++/stl_iterator.h	/^  Iterator current;$/;"	m	class:reverse_iterator
current	g++/stl_iterator.h	/^  RandomAccessIterator current;$/;"	m	class:reverse_iterator
current	g++/stl_rope.h	/^    charT current;$/;"	m	class:__rope_charT_ptr_proxy
current	g++/stl_rope.h	/^    charT current;$/;"	m	class:__rope_charT_ref_proxy
current_pos	g++/stl_rope.h	/^    size_t current_pos;$/;"	m	class:__rope_iterator_base
current_valid	g++/stl_rope.h	/^    bool current_valid;$/;"	m	class:__rope_charT_ptr_proxy
current_valid	g++/stl_rope.h	/^    bool current_valid;$/;"	m	class:__rope_charT_ref_proxy
cursorOn	tk.h	/^    int cursorOn;		\/* Non-zero means that an insertion cursor$/;"	m	struct:Tk_CanvasTextInfo
customPtr	tk.h	/^    Tk_CustomOption *customPtr;	\/* If type is TK_CONFIG_CUSTOM then this is$/;"	m	struct:Tk_ConfigSpec
dCharsProc	tk.h	/^    Tk_ItemDCharsProc *dCharsProc;	\/* Procedure to delete characters$/;"	m	struct:Tk_ItemType
dat	g++/std/bastring.h	/^	charT *dat;$/;"	m	class:basic_string
data	Dbg.h	/^  ClientData data;$/;"	m	struct:__anon70
data	Dbg.h	/^  ClientData data;$/;"	m	struct:__anon71
data	bfd.h	/^  PTR data;$/;"	m	struct:_bfd_window
data	bfdlink.h	/^	} data;$/;"	m	union:bfd_link_order::__anon64	typeref:struct:bfd_link_order::__anon64::__anon67
data	g++/editbuf.h	/^    buf_char *data; \/* == emacs buffer_text.p1+1 *\/$/;"	m	struct:edit_buffer
data	g++/std/bastring.h	/^		charT* data() $/;"	f	struct:basic_string::Rep
data	g++/std/bastring.h	/^	const charT* data() const { return rep()->data(); }$/;"	f	class:basic_string
data	g++/stl_list.h	/^	T data;$/;"	m	struct:std::__list_node
data	g++/stl_rope.h	/^    __GC_CONST charT* data;     \/* Not necessarily 0 terminated. *\/$/;"	m	struct:__rope_RopeLeaf
data	g++/stl_slist.h	/^	T data;$/;"	m	struct:std::__slist_node
data_allocator	g++/stl_bvector.h	/^  typedef simple_alloc<unsigned int, Alloc> data_allocator;$/;"	t	class:vector
data_allocator	g++/stl_deque.h	/^	typedef simple_alloc<value_type, Alloc> 				data_allocator;$/;"	t	class:std::deque
data_allocator	g++/stl_vector.h	/^	typedef simple_alloc<value_type, Alloc> 	data_allocator;$/;"	t	class:vector
data_type	g++/stl_hash_map.h	/^  typedef T data_type;$/;"	t	class:hash_map
data_type	g++/stl_hash_map.h	/^  typedef T data_type;$/;"	t	class:hash_multimap
data_type	g++/stl_map.h	/^  typedef T data_type;$/;"	t	class:map
data_type	g++/stl_multimap.h	/^  typedef T data_type;$/;"	t	class:multimap
dbClass	tk.h	/^    char *dbClass;		\/* Class for option in database. *\/$/;"	m	struct:Tk_ConfigSpec
dbName	tk.h	/^    char *dbName;		\/* Name for option in option database. *\/$/;"	m	struct:Tk_ConfigSpec
deallocate	g++/defalloc.h	/^    void deallocate(pointer p) $/;"	f	class:allocator
deallocate	g++/defalloc.h	/^inline void deallocate(T* buffer) $/;"	f
deallocate	g++/stl_alloc.h	/^	static void deallocate(void *p, size_t \/* n *\/)$/;"	f	class:__malloc_alloc_template
deallocate	g++/stl_alloc.h	/^	static void deallocate(void *p, size_t n)$/;"	f	class:debug_alloc
deallocate	g++/stl_alloc.h	/^	static void deallocate(void* p, size_t n)$/;"	f	class:__default_alloc_template
deallocate	g++/stl_alloc.h	/^    static void deallocate(T *p)$/;"	f	class:simple_alloc
deallocate	g++/stl_alloc.h	/^    static void deallocate(T *p, size_t n)$/;"	f	class:simple_alloc
deallocate	g++/stl_bvector.h	/^  void deallocate() {$/;"	f	class:vector
deallocate	g++/stl_vector.h	/^	void deallocate() $/;"	f	class:vector
deallocate_node	g++/stl_deque.h	/^	void deallocate_node(pointer n) {data_allocator::deallocate(n, buffer_size());}$/;"	f	class:std::deque
debug	FlexLexer.h	/^	int debug() const		{ return yy_flex_debug; }$/;"	f	class:FlexLexer
debug_alloc	g++/stl_alloc.h	/^class debug_alloc $/;"	c
dec	g++/iostream.h	/^inline ios& dec(ios& i)$/;"	f
dec	g++/streambuf.h	/^	   dec=_IO_DEC, oct=_IO_OCT, hex=_IO_HEX,$/;"	e	enum:ios::__anon1
dec	g++/streambuf.h	/^	   dec=_IO_DEC, oct=_IO_OCT, hex=_IO_HEX,$/;"	e	enum:ios::__anon72
decr	g++/ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::decr(size_t n) {$/;"	f	class:__rope_iterator_base
decr_refcount	g++/stl_rope.h	/^	    size_t decr_refcount ()$/;"	f	struct:__rope_RopeBase
decr_refcount	g++/stl_rope.h	/^            size_t decr_refcount ()$/;"	f	struct:__rope_RopeBase
decrement	g++/stl_tree.h	/^	void decrement(){$/;"	f	struct:__rb_tree_base_iterator
def	bfdlink.h	/^	} def;$/;"	m	union:bfd_link_hash_entry::__anon59	typeref:struct:bfd_link_hash_entry::__anon59::__anon61
defValue	tk.h	/^    char *defValue;		\/* Default value for option if not$/;"	m	struct:Tk_ConfigSpec
deleteData	tcl.h	/^    ClientData deleteData;	 \/* Value to pass to deleteProc (usually$/;"	m	struct:Tcl_CmdInfo
deleteProc	tcl.h	/^    Tcl_CmdDeleteProc *deleteProc;$/;"	m	struct:Tcl_CmdInfo
deleteProc	tcl.h	/^    Tcl_NamespaceDeleteProc* deleteProc;$/;"	m	struct:Tcl_Namespace
deleteProc	tk.h	/^    Tk_ImageDeleteProc *deleteProc;$/;"	m	struct:Tk_ImageType
deleteProc	tk.h	/^    Tk_ItemDeleteProc *deleteProc;	\/* Procedure to delete existing item of$/;"	m	struct:Tk_ItemType
delete_buf	g++/parsestream.h	/^    int delete_buf; \/\/ Delete sbuf when destroying this.$/;"	m	class:general_parsebuf
delete_c_str	g++/stl_rope.h	/^	void delete_c_str () {$/;"	f	class:rope
delete_node	g++/stl_hashtable.h	/^  void delete_node(node* n)$/;"	f	class:hashtable
delete_when_done	g++/stl_rope.h	/^      bool delete_when_done;	\/\/ Char_producer is owned by the$/;"	m	struct:__rope_RopeFunction
deleted	tix.h	/^    unsigned int deleted : 1;	\/* True if a delete operation has been$/;"	m	struct:Tix_ListIterator
deps	bfdlink.h	/^  struct bfd_elf_version_deps *deps;$/;"	m	struct:bfd_elf_version_tree	typeref:struct:bfd_elf_version_tree::bfd_elf_version_deps
depth	g++/stl_rope.h	/^    unsigned char depth;$/;"	m	struct:__rope_RopeBase
depth	tk.h	/^    int depth;$/;"	m	struct:Tk_FakeWin
deque	g++/stl_deque.h	/^	deque(): start(), finish(), map(0), map_size(0)$/;"	f	class:std::deque
deque	g++/stl_deque.h	/^	deque(InputIterator first, InputIterator last) : start(), finish(), map(0), map_size(0)$/;"	f	class:std::deque
deque	g++/stl_deque.h	/^	deque(const deque& x): start(), finish(), map(0), map_size(0)$/;"	f	class:std::deque
deque	g++/stl_deque.h	/^	deque(int n, const value_type& value) : start(), finish(), map(0), map_size(0)$/;"	f	class:std::deque
deque	g++/stl_deque.h	/^	deque(long n, const value_type& value) : start(), finish(), map(0), map_size(0)$/;"	f	class:std::deque
deque	g++/stl_deque.h	/^	deque(size_type n, const value_type& value) : start(), finish(), map(0), map_size(0)$/;"	f	class:std::deque
deque	g++/stl_deque.h	/^	explicit deque(size_type n) : start(), finish(), map(0), map_size(0)$/;"	f	class:std::deque
deque	g++/stl_deque.h	/^class deque $/;"	c	namespace:std
descent	tk.h	/^    int descent;		\/* The largest amount in pixels that any$/;"	m	struct:Tk_FontMetrics
destr_concat_char_iter	g++/ropeimpl.h	/^::destr_concat_char_iter$/;"	f	class:rope
destr_concat_char_iter	g++/stl_rope.h	/^	static RopeBase * destr_concat_char_iter(RopeBase * r,$/;"	f	class:rope
destr_leaf_concat_char_iter	g++/ropeimpl.h	/^rope<charT,Alloc>::destr_leaf_concat_char_iter$/;"	f	class:rope
destroy	g++/stl_construct.h	/^destroy(ForwardIterator first, ForwardIterator last) $/;"	f	namespace:std
destroy	g++/stl_construct.h	/^destroy(T* pointer) $/;"	f	namespace:std
destroy	g++/stl_construct.h	/^inline void destroy(char*, char*) {}$/;"	f	namespace:std
destroy	g++/stl_construct.h	/^inline void destroy(wchar_t*, wchar_t*) {}$/;"	f	namespace:std
destroy_map_and_nodes	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::destroy_map_and_nodes() {$/;"	f	class:std::deque
destroy_node	g++/stl_list.h	/^	void destroy_node(link_type p) {$/;"	f	class:std::list
destroy_node	g++/stl_slist.h	/^	static void destroy_node(list_node* node) {$/;"	f	class:std::slist
destroy_node	g++/stl_tree.h	/^  void destroy_node(link_type p) {$/;"	f	class:rb_tree
destroy_nodes_at_back	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::destroy_nodes_at_back(iterator after_finish) $/;"	f	class:std::deque
destroy_nodes_at_front	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::destroy_nodes_at_front(iterator before_start) $/;"	f	class:std::deque
difference_type	g++/defalloc.h	/^    typedef ptrdiff_t difference_type;$/;"	t	class:allocator
difference_type	g++/std/bastring.h	/^	typedef ptrdiff_t 								difference_type;$/;"	t	class:basic_string
difference_type	g++/stl_bvector.h	/^  typedef ptrdiff_t difference_type; $/;"	t	class:vector
difference_type	g++/stl_deque.h	/^	typedef ptrdiff_t 											difference_type;$/;"	t	struct:std::__deque_iterator
difference_type	g++/stl_deque.h	/^	typedef ptrdiff_t 										difference_type;$/;"	t	class:std::deque
difference_type	g++/stl_hash_map.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_map
difference_type	g++/stl_hash_map.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_multimap
difference_type	g++/stl_hash_set.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_multiset
difference_type	g++/stl_hash_set.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_set
difference_type	g++/stl_hashtable.h	/^  typedef ptrdiff_t         difference_type;$/;"	t	class:hashtable
difference_type	g++/stl_hashtable.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__hashtable_const_iterator
difference_type	g++/stl_hashtable.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__hashtable_iterator
difference_type	g++/stl_iterator.h	/^          difference_type;$/;"	t	class:reverse_iterator
difference_type	g++/stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	class:reverse_bidirectional_iterator
difference_type	g++/stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	class:reverse_iterator
difference_type	g++/stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	struct:bidirectional_iterator
difference_type	g++/stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	struct:random_access_iterator
difference_type	g++/stl_iterator.h	/^  typedef Distance             difference_type;$/;"	t	struct:forward_iterator
difference_type	g++/stl_iterator.h	/^  typedef Distance           difference_type;$/;"	t	class:istream_iterator
difference_type	g++/stl_iterator.h	/^  typedef Distance           difference_type;$/;"	t	struct:input_iterator
difference_type	g++/stl_iterator.h	/^  typedef Distance  difference_type;$/;"	t	struct:iterator
difference_type	g++/stl_iterator.h	/^  typedef ptrdiff_t                  difference_type;$/;"	t	struct:iterator_traits
difference_type	g++/stl_iterator.h	/^  typedef typename Iterator::difference_type   difference_type;$/;"	t	struct:iterator_traits
difference_type	g++/stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:back_insert_iterator
difference_type	g++/stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:front_insert_iterator
difference_type	g++/stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:insert_iterator
difference_type	g++/stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:ostream_iterator
difference_type	g++/stl_iterator.h	/^  typedef void                difference_type;$/;"	t	struct:output_iterator
difference_type	g++/stl_list.h	/^	typedef ptrdiff_t 								difference_type;$/;"	t	class:std::list
difference_type	g++/stl_list.h	/^	typedef ptrdiff_t difference_type;$/;"	t	struct:std::__list_iterator
difference_type	g++/stl_map.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:map
difference_type	g++/stl_multimap.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:multimap
difference_type	g++/stl_multiset.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:multiset
difference_type	g++/stl_raw_storage_iter.h	/^  typedef void                difference_type;$/;"	t	class:raw_storage_iterator
difference_type	g++/stl_rope.h	/^	typedef ptrdiff_t difference_type;$/;"	t	class:rope
difference_type	g++/stl_set.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:set
difference_type	g++/stl_slist.h	/^	typedef ptrdiff_t 								difference_type;$/;"	t	class:std::slist
difference_type	g++/stl_slist.h	/^	typedef ptrdiff_t 				difference_type;$/;"	t	struct:std::__slist_iterator_base
difference_type	g++/stl_tree.h	/^	typedef ptrdiff_t 					difference_type;$/;"	t	struct:__rb_tree_base_iterator
difference_type	g++/stl_tree.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:rb_tree
difference_type	g++/stl_vector.h	/^	typedef ptrdiff_t 		  					difference_type;$/;"	t	class:vector
direction	bfd.h	/^                        both_direction = 3} direction;$/;"	m	struct:_bfd	typeref:enum:_bfd::bfd_direction
discard	bfdlink.h	/^  enum bfd_link_discard discard;$/;"	m	struct:bfd_link_info	typeref:enum:bfd_link_info::bfd_link_discard
discard_all	bfdlink.h	/^  discard_all		\/* Discard all locals.  *\/$/;"	e	enum:bfd_link_discard
discard_l	bfdlink.h	/^  discard_l,		\/* Discard local temporary symbols.  *\/$/;"	e	enum:bfd_link_discard
discard_none	bfdlink.h	/^  discard_none,		\/* Don't discard any locals.  *\/$/;"	e	enum:bfd_link_discard
display	tk.h	/^    Display *display;	    \/* Display the event was read from *\/$/;"	m	struct:__anon34
display	tk.h	/^    Display *display;	    \/* Display the event was read from *\/$/;"	m	struct:__anon35
display	tk.h	/^    Display *display;$/;"	m	struct:Tk_FakeWin
displayProc	tk.h	/^    Tk_ImageDisplayProc *displayProc;$/;"	m	struct:Tk_ImageType
displayProc	tk.h	/^    Tk_ItemDisplayProc *displayProc;	\/* Procedure to display items of$/;"	m	struct:Tk_ItemType
distance	g++/stl_iterator.h	/^distance(InputIterator first, InputIterator last) {$/;"	f
distance	g++/stl_iterator.h	/^distance(InputIterator first, InputIterator last, Distance& n) $/;"	f
distance_type	g++/stl_deque.h	/^inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) $/;"	f	namespace:std
distance_type	g++/stl_hashtable.h	/^distance_type(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
distance_type	g++/stl_hashtable.h	/^distance_type(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
distance_type	g++/stl_iterator.h	/^distance_type(const Iterator&) {$/;"	f
distance_type	g++/stl_iterator.h	/^distance_type(const bidirectional_iterator<T, Distance>&) {$/;"	f
distance_type	g++/stl_iterator.h	/^distance_type(const random_access_iterator<T, Distance>&) {$/;"	f
distance_type	g++/stl_iterator.h	/^distance_type(const reverse_bidirectional_iterator<BidirectionalIterator, T,$/;"	f
distance_type	g++/stl_iterator.h	/^inline Distance* distance_type(const forward_iterator<T, Distance>&) {$/;"	f
distance_type	g++/stl_iterator.h	/^inline Distance* distance_type(const input_iterator<T, Distance>&) {$/;"	f
distance_type	g++/stl_iterator.h	/^inline Distance* distance_type(const istream_iterator<T, Distance>&) {$/;"	f
distance_type	g++/stl_iterator.h	/^inline Distance* distance_type(const reverse_iterator<RandomAccessIterator, T,$/;"	f
distance_type	g++/stl_iterator.h	/^inline ptrdiff_t* distance_type(const T*) { return (ptrdiff_t*)(0); }$/;"	f
distance_type	g++/stl_list.h	/^distance_type(const __list_iterator<T, Ref, Ptr>&) {$/;"	f	namespace:std
distance_type	g++/stl_slist.h	/^distance_type(const __slist_iterator_base&){$/;"	f	namespace:std
distance_type	g++/stl_tree.h	/^distance_type(const __rb_tree_base_iterator&) {$/;"	f
divides	g++/stl_function.h	/^struct divides : public binary_function<T, T, T> {$/;"	s
do_delete	g++/parsestream.h	/^    int do_delete;$/;"	m	class:string_parsebuf
dont_close	g++/streambuf.h	/^	   , dont_close=_IO_DONT_CLOSE \/\/ Don't delete streambuf on stream destruction$/;"	e	enum:ios::__anon1
dont_close	g++/streambuf.h	/^	   , dont_close=_IO_DONT_CLOSE \/\/ Don't delete streambuf on stream destruction$/;"	e	enum:ios::__anon72
doubleValue	tcl.h	/^	double doubleValue;	\/*   - a double-precision floating value *\/$/;"	m	union:Tcl_Obj::__anon54
doubleValue	tcl.h	/^    double doubleValue;		\/* Double-precision floating value. *\/$/;"	m	struct:Tcl_Value
downShift	tcl.h	/^    int downShift;			\/* Shift count used in hashing$/;"	m	struct:Tcl_HashTable
dst	tk.h	/^    char *dst;		\/* Address of value to be modified;  usage$/;"	m	struct:__anon30
dst_mask	bfd.h	/^  bfd_vma dst_mask;$/;"	m	struct:reloc_howto_struct
dummy1	tcl.h	/^    int dummy1;$/;"	m	struct:Tcl_CallFrame
dummy1	tk.h	/^    char *dummy1;$/;"	m	struct:Tk_FakeWin
dummy10	tcl.h	/^    char* dummy10;$/;"	m	struct:Tcl_CallFrame
dummy10	tk.h	/^    ClientData *dummy10;$/;"	m	struct:Tk_FakeWin
dummy11	tk.h	/^    int dummy11;$/;"	m	struct:Tk_FakeWin
dummy12	tk.h	/^    int dummy12;$/;"	m	struct:Tk_FakeWin
dummy13	tk.h	/^    char *dummy13;$/;"	m	struct:Tk_FakeWin
dummy14	tk.h	/^    char *dummy14;$/;"	m	struct:Tk_FakeWin
dummy15	tk.h	/^    ClientData dummy15;$/;"	m	struct:Tk_FakeWin
dummy16	tk.h	/^    char *dummy16;$/;"	m	struct:Tk_FakeWin
dummy17	tk.h	/^    char *dummy17;$/;"	m	struct:Tk_FakeWin
dummy18	tk.h	/^    ClientData dummy18;$/;"	m	struct:Tk_FakeWin
dummy19	tk.h	/^    char *dummy19;$/;"	m	struct:Tk_FakeWin
dummy2	tcl.h	/^    int dummy2;$/;"	m	struct:Tcl_CallFrame
dummy2	tk.h	/^    char *dummy2;$/;"	m	struct:Tk_FakeWin
dummy3	tcl.h	/^    char *dummy3;$/;"	m	struct:Tcl_CallFrame
dummy3	tk.h	/^    char *dummy3;$/;"	m	struct:Tk_FakeWin
dummy4	tcl.h	/^    char *dummy4;$/;"	m	struct:Tcl_CallFrame
dummy4	tk.h	/^    char *dummy4;$/;"	m	struct:Tk_FakeWin
dummy5	tcl.h	/^    char *dummy5;$/;"	m	struct:Tcl_CallFrame
dummy5	tk.h	/^    char *dummy5;$/;"	m	struct:Tk_FakeWin
dummy6	tcl.h	/^    int dummy6;$/;"	m	struct:Tcl_CallFrame
dummy6	tk.h	/^    unsigned int dummy6;$/;"	m	struct:Tk_FakeWin
dummy7	tcl.h	/^    char *dummy7;$/;"	m	struct:Tcl_CallFrame
dummy7	tk.h	/^    unsigned long dummy7;$/;"	m	struct:Tk_FakeWin
dummy8	tcl.h	/^    char *dummy8;$/;"	m	struct:Tcl_CallFrame
dummy8	tk.h	/^    char *dummy8;$/;"	m	struct:Tk_FakeWin
dummy9	tcl.h	/^    int dummy9;$/;"	m	struct:Tcl_CallFrame
dummy9	tk.h	/^    XIC dummy9;$/;"	m	struct:Tk_FakeWin
dump	g++/ropeimpl.h	/^rope<charT,Alloc>::dump(RopeBase * r, int indent)$/;"	f	class:rope
dump	g++/stl_rope.h	/^	void dump() {$/;"	f	class:rope
dupIntRepProc	tcl.h	/^    Tcl_DupInternalRepProc *dupIntRepProc;$/;"	m	struct:Tcl_ObjType
eBptr	g++/streambuf.h	/^    char *eBptr() { return in_backup() ? _IO_read_end : _IO_save_end; }$/;"	f	struct:streambuf
eGptr	g++/streambuf.h	/^    char *eGptr() { return in_backup() ? _IO_save_end : _IO_read_end; }$/;"	f	struct:streambuf
eNptr	g++/streambuf.h	/^    char *eNptr() { return _IO_save_end; }$/;"	f	struct:streambuf
eback	g++/streambuf.h	/^    char* eback() const$/;"	f	struct:streambuf
ebuf	g++/streambuf.h	/^    char* ebuf() const { return _IO_buf_end; }$/;"	f	struct:streambuf
ecoff_obj_data	bfd.h	/^      struct ecoff_tdata *ecoff_obj_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::ecoff_tdata
edit_buffer	g++/editbuf.h	/^struct edit_buffer {$/;"	s
edit_mark	g++/editbuf.h	/^    edit_mark() { }$/;"	f	struct:edit_mark
edit_mark	g++/editbuf.h	/^struct edit_mark {$/;"	s
edit_streambuf	g++/editbuf.h	/^struct edit_streambuf : public streambuf {$/;"	s
edit_string	g++/editbuf.h	/^    edit_string(struct edit_buffer *b,$/;"	f	struct:edit_string
edit_string	g++/editbuf.h	/^struct edit_string {$/;"	s
egptr	g++/streambuf.h	/^    char* egptr() const$/;"	f	struct:streambuf
elems_in_bucket	g++/stl_hash_map.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_map
elems_in_bucket	g++/stl_hash_map.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_multimap
elems_in_bucket	g++/stl_hash_set.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_multiset
elems_in_bucket	g++/stl_hash_set.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_set
elems_in_bucket	g++/stl_hashtable.h	/^  size_type elems_in_bucket(size_type bucket) const$/;"	f	class:hashtable
elf_obj_data	bfd.h	/^      struct elf_obj_tdata *elf_obj_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::elf_obj_tdata
empty	g++/std/bastring.h	/^	bool empty() const{ return size() == 0; }$/;"	f	class:basic_string
empty	g++/stl_bvector.h	/^  bool empty() const { return begin() == end(); }$/;"	f	class:vector
empty	g++/stl_deque.h	/^	bool empty() const { return finish == start; }$/;"	f	class:std::deque
empty	g++/stl_hash_map.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_map
empty	g++/stl_hash_map.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_multimap
empty	g++/stl_hash_set.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_multiset
empty	g++/stl_hash_set.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_set
empty	g++/stl_hashtable.h	/^  bool empty() const { return size() == 0; }$/;"	f	class:hashtable
empty	g++/stl_list.h	/^	bool empty() const { return node->next == node; }$/;"	f	class:std::list
empty	g++/stl_map.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:map
empty	g++/stl_multimap.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:multimap
empty	g++/stl_multiset.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:multiset
empty	g++/stl_queue.h	/^	bool empty() const { return c.empty(); }$/;"	f	class:priority_queue
empty	g++/stl_queue.h	/^	bool empty() const { return c.empty(); }$/;"	f	class:queue
empty	g++/stl_rope.h	/^	bool empty() const { return 0 == tree_ptr; }$/;"	f	class:rope
empty	g++/stl_set.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:set
empty	g++/stl_slist.h	/^	bool empty() const { return head.next == 0; }$/;"	f	class:std::slist
empty	g++/stl_stack.h	/^  bool empty() const { return c.empty(); }$/;"	f	class:stack
empty	g++/stl_tree.h	/^  bool empty() const { return node_count == 0; }$/;"	f	class:rb_tree
empty	g++/stl_vector.h	/^	bool empty() const { return begin() == end(); }$/;"	f	class:vector
empty_c_str	g++/ropeimpl.h	/^template<class charT, class Alloc> charT rope<charT,Alloc>::empty_c_str[1];$/;"	m	class:rope
empty_c_str	g++/stl_rope.h	/^	static charT empty_c_str[1];$/;"	m	class:rope
empty_initialize	g++/stl_list.h	/^	void empty_initialize() { 							$/;"	f	class:std::list
end	g++/editbuf.h	/^    struct edit_mark *start, *end;$/;"	m	struct:edit_string	typeref:struct:edit_string::
end	g++/std/bastring.h	/^	const_iterator end () const { return iend (); }$/;"	f	class:basic_string
end	g++/std/bastring.h	/^	iterator end () { selfish (); return &(*this)[length ()]; }$/;"	f	class:basic_string
end	g++/stl_bvector.h	/^  const_iterator end() const { return finish; }$/;"	f	class:vector
end	g++/stl_bvector.h	/^  iterator end() { return finish; }$/;"	f	class:vector
end	g++/stl_deque.h	/^	const_iterator end() const { return finish; }$/;"	f	class:std::deque
end	g++/stl_deque.h	/^	iterator end() { return finish; }$/;"	f	class:std::deque
end	g++/stl_hash_map.h	/^  const_iterator end() const { return rep.end(); }$/;"	f	class:hash_map
end	g++/stl_hash_map.h	/^  const_iterator end() const { return rep.end(); }$/;"	f	class:hash_multimap
end	g++/stl_hash_map.h	/^  iterator end() { return rep.end(); }$/;"	f	class:hash_map
end	g++/stl_hash_map.h	/^  iterator end() { return rep.end(); }$/;"	f	class:hash_multimap
end	g++/stl_hash_set.h	/^  iterator end() const { return rep.end(); }$/;"	f	class:hash_multiset
end	g++/stl_hash_set.h	/^  iterator end() const { return rep.end(); }$/;"	f	class:hash_set
end	g++/stl_hashtable.h	/^  const_iterator end() const { return const_iterator(0, this); }$/;"	f	class:hashtable
end	g++/stl_hashtable.h	/^  iterator end() { return iterator(0, this); }$/;"	f	class:hashtable
end	g++/stl_list.h	/^	const_iterator end() const { return node; }$/;"	f	class:std::list
end	g++/stl_list.h	/^	iterator end() { return node; }$/;"	f	class:std::list
end	g++/stl_map.h	/^  const_iterator end() const { return t.end(); }$/;"	f	class:map
end	g++/stl_map.h	/^  iterator end() { return t.end(); }$/;"	f	class:map
end	g++/stl_multimap.h	/^  const_iterator end() const { return t.end(); }$/;"	f	class:multimap
end	g++/stl_multimap.h	/^  iterator end() { return t.end(); }$/;"	f	class:multimap
end	g++/stl_multiset.h	/^  iterator end() const { return t.end(); }$/;"	f	class:multiset
end	g++/stl_rope.h	/^	    const_iterator end() { return const_end(); }$/;"	f	class:rope
end	g++/stl_rope.h	/^	    iterator end() { return mutable_end(); }$/;"	f	class:rope
end	g++/stl_rope.h	/^	const_iterator end() const {$/;"	f	class:rope
end	g++/stl_set.h	/^  iterator end() const { return t.end(); }$/;"	f	class:set
end	g++/stl_slist.h	/^	const_iterator end() const { return const_iterator(0); }$/;"	f	class:std::slist
end	g++/stl_slist.h	/^	iterator end() { return iterator(0); }$/;"	f	class:std::slist
end	g++/stl_tempbuf.h	/^  T* end() { return buffer + len; }$/;"	f	class:temporary_buffer
end	g++/stl_tree.h	/^  const_iterator end() const { return header; }$/;"	f	class:rb_tree
end	g++/stl_tree.h	/^  iterator end() { return header; }$/;"	f	class:rb_tree
end	g++/stl_vector.h	/^	const_iterator end() const { return finish; }$/;"	f	class:vector
end	g++/stl_vector.h	/^	iterator end() { return finish; }$/;"	f	class:vector
end	g++/streambuf.h	/^    enum seek_dir { beg, cur, end};$/;"	e	enum:ios::seek_dir
end	readline/readline.h	/^  int start, end;		\/* Where the change took place. *\/$/;"	m	struct:undo_list
end_free	g++/stl_alloc.h	/^	static char* end_free;	   \/\/ chunk_alloc() $/;"	m	class:__default_alloc_template
end_free	g++/stl_alloc.h	/^char* __default_alloc_template<threads, inst>::end_free = 0;$/;"	m	class:__default_alloc_template
end_mark	g++/editbuf.h	/^    struct edit_mark end_mark;$/;"	m	struct:edit_buffer	typeref:struct:edit_buffer::edit_mark
end_marker	g++/editbuf.h	/^    inline struct edit_mark *end_marker() { return &end_mark; }$/;"	f	struct:edit_buffer
end_marker	g++/stl_iterator.h	/^  bool end_marker;$/;"	m	class:istream_iterator
end_of_storage	g++/stl_bvector.h	/^  unsigned int* end_of_storage;$/;"	m	class:vector
end_of_storage	g++/stl_vector.h	/^	iterator 									end_of_storage;$/;"	m	class:vector
endp	tclRegexp.h	/^	char *endp[NSUBEXP];$/;"	m	struct:regexp
eof	g++/streambuf.h	/^    int eof() const { return _state & ios::eofbit; }$/;"	f	class:ios
eofbit	g++/streambuf.h	/^	eofbit = _IOS_EOF,$/;"	e	enum:ios::io_state
eos	g++/std/bastring.h	/^	static charT eos() { return traits::eos(); }$/;"	f	class:basic_string
eos	g++/std/straits.h	/^	static char_type eos() { return char_type(); } \/\/ the null character$/;"	f	struct:string_char_traits
eos	g++/std/straits.h	/^  static char_type eos () { return 0; }$/;"	f	struct:string_char_traits
epptr	g++/streambuf.h	/^    char* epptr() const { return _IO_write_end; }$/;"	f	struct:streambuf
eq	g++/std/straits.h	/^	static bool eq(const char_type& c1, const char_type& c2) { return (c1 == c2); }$/;"	f	struct:string_char_traits
eq	g++/std/straits.h	/^  static bool eq (const char_type & c1, const char_type& c2)$/;"	f	struct:string_char_traits
equal	g++/stl_algobase.h	/^equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2) $/;"	f
equal	g++/stl_algobase.h	/^equal(InputIterator1 first1, InputIterator1 last1,InputIterator2 first2, BinaryPredicate binary_pred) $/;"	f
equal_range	g++/stl_algo.h	/^equal_range(ForwardIterator first, ForwardIterator last, const T& value) {$/;"	f
equal_range	g++/stl_algo.h	/^equal_range(ForwardIterator first, ForwardIterator last, const T& value,$/;"	f
equal_range	g++/stl_hash_map.h	/^  pair<const_iterator, const_iterator> equal_range(const key_type& key) const$/;"	f	class:hash_map
equal_range	g++/stl_hash_map.h	/^  pair<const_iterator, const_iterator> equal_range(const key_type& key) const$/;"	f	class:hash_multimap
equal_range	g++/stl_hash_map.h	/^  pair<iterator, iterator> equal_range(const key_type& key)$/;"	f	class:hash_map
equal_range	g++/stl_hash_map.h	/^  pair<iterator, iterator> equal_range(const key_type& key)$/;"	f	class:hash_multimap
equal_range	g++/stl_hash_set.h	/^  pair<iterator, iterator> equal_range(const key_type& key) const$/;"	f	class:hash_multiset
equal_range	g++/stl_hash_set.h	/^  pair<iterator, iterator> equal_range(const key_type& key) const$/;"	f	class:hash_set
equal_range	g++/stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::equal_range(const key_type& key) const$/;"	f	class:hashtable
equal_range	g++/stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::equal_range(const key_type& key)$/;"	f	class:hashtable
equal_range	g++/stl_map.h	/^  pair<const_iterator,const_iterator> equal_range(const key_type& x) const {$/;"	f	class:map
equal_range	g++/stl_map.h	/^  pair<iterator,iterator> equal_range(const key_type& x) {$/;"	f	class:map
equal_range	g++/stl_multimap.h	/^   pair<iterator,iterator> equal_range(const key_type& x) {$/;"	f	class:multimap
equal_range	g++/stl_multimap.h	/^  pair<const_iterator,const_iterator> equal_range(const key_type& x) const {$/;"	f	class:multimap
equal_range	g++/stl_multiset.h	/^  pair<iterator,iterator> equal_range(const key_type& x) const {$/;"	f	class:multiset
equal_range	g++/stl_set.h	/^  pair<iterator,iterator> equal_range(const key_type& x) const {$/;"	f	class:set
equal_range	g++/stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::equal_range(const Key& k) {$/;"	f	class:rb_tree
equal_range	g++/stl_tree.h	/^rb_tree<Key, Value, KoV, Compare, Alloc>::equal_range(const Key& k) const {$/;"	f	class:rb_tree
equal_to	g++/stl_function.h	/^struct equal_to : public binary_function<T, T, bool> {$/;"	s
equals	g++/stl_hashtable.h	/^  key_equal equals;$/;"	m	class:hashtable
erase	g++/std/bastring.h	/^	basic_string& erase(size_type pos = 0, size_type n = npos)$/;"	f	class:basic_string
erase	g++/std/bastring.h	/^	iterator erase(iterator f, iterator l)$/;"	f	class:basic_string
erase	g++/std/bastring.h	/^	iterator erase(iterator p)$/;"	f	class:basic_string
erase	g++/stl_bvector.h	/^  iterator erase(iterator first, iterator last) {$/;"	f	class:vector
erase	g++/stl_bvector.h	/^  iterator erase(iterator position) {$/;"	f	class:vector
erase	g++/stl_deque.h	/^	iterator erase(iterator pos) $/;"	f	class:std::deque
erase	g++/stl_deque.h	/^deque<T, Alloc, BufSize>::erase(iterator first, iterator last)  \/\/$/;"	f	class:std::deque
erase	g++/stl_hash_map.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_map
erase	g++/stl_hash_map.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_multimap
erase	g++/stl_hash_map.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_map
erase	g++/stl_hash_map.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_multimap
erase	g++/stl_hash_map.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_map
erase	g++/stl_hash_map.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_multimap
erase	g++/stl_hash_set.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_multiset
erase	g++/stl_hash_set.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_set
erase	g++/stl_hash_set.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_multiset
erase	g++/stl_hash_set.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_set
erase	g++/stl_hash_set.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_multiset
erase	g++/stl_hash_set.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_set
erase	g++/stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase(const const_iterator& it)$/;"	f	class:hashtable
erase	g++/stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase(const key_type& key)$/;"	f	class:hashtable
erase	g++/stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase(const_iterator first,$/;"	f	class:hashtable
erase	g++/stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::erase(const iterator& it)$/;"	f	class:hashtable
erase	g++/stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::erase(iterator first, iterator last)$/;"	f	class:hashtable
erase	g++/stl_list.h	/^	iterator erase(iterator position) {$/;"	f	class:std::list
erase	g++/stl_list.h	/^list<T,Alloc>::iterator list<T, Alloc>::erase(iterator first, iterator last) {$/;"	f	class:std::list
erase	g++/stl_map.h	/^  size_type erase(const key_type& x) { return t.erase(x); }$/;"	f	class:map
erase	g++/stl_map.h	/^  void erase(iterator first, iterator last) { t.erase(first, last); }$/;"	f	class:map
erase	g++/stl_map.h	/^  void erase(iterator position) { t.erase(position); }$/;"	f	class:map
erase	g++/stl_multimap.h	/^  size_type erase(const key_type& x) { return t.erase(x); }$/;"	f	class:multimap
erase	g++/stl_multimap.h	/^  void erase(iterator first, iterator last) { t.erase(first, last); }$/;"	f	class:multimap
erase	g++/stl_multimap.h	/^  void erase(iterator position) { t.erase(position); }$/;"	f	class:multimap
erase	g++/stl_multiset.h	/^  size_type erase(const key_type& x) { $/;"	f	class:multiset
erase	g++/stl_multiset.h	/^  void erase(iterator first, iterator last) { $/;"	f	class:multiset
erase	g++/stl_multiset.h	/^  void erase(iterator position) { $/;"	f	class:multiset
erase	g++/stl_rope.h	/^	iterator erase(const iterator &p, const iterator &q) {$/;"	f	class:rope
erase	g++/stl_rope.h	/^	void erase(size_t p) {$/;"	f	class:rope
erase	g++/stl_rope.h	/^	void erase(size_t p, size_t n) {$/;"	f	class:rope
erase	g++/stl_rope.h	/^        iterator erase(const iterator &p) {$/;"	f	class:rope
erase	g++/stl_set.h	/^  size_type erase(const key_type& x) { $/;"	f	class:set
erase	g++/stl_set.h	/^  void erase(iterator first, iterator last) { $/;"	f	class:set
erase	g++/stl_set.h	/^  void erase(iterator position) { $/;"	f	class:set
erase	g++/stl_slist.h	/^	iterator erase(iterator first, iterator last) {$/;"	f	class:std::slist
erase	g++/stl_slist.h	/^	iterator erase(iterator pos) {$/;"	f	class:std::slist
erase	g++/stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key& x) {$/;"	f	class:rb_tree
erase	g++/stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator position) {$/;"	f	class:rb_tree
erase	g++/stl_tree.h	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key* first, $/;"	f	class:rb_tree
erase	g++/stl_tree.h	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator first, $/;"	f	class:rb_tree
erase	g++/stl_vector.h	/^	iterator erase(iterator first, iterator last) $/;"	f	class:vector
erase	g++/stl_vector.h	/^	iterator erase(iterator position) $/;"	f	class:vector
erase_after	g++/stl_slist.h	/^	iterator erase_after(iterator before_first, iterator last) {$/;"	f	class:std::slist
erase_after	g++/stl_slist.h	/^	iterator erase_after(iterator pos) {$/;"	f	class:std::slist
erase_after	g++/stl_slist.h	/^	list_node_base* erase_after(list_node_base* before_first, list_node_base* last_node) {$/;"	f	class:std::slist
erase_after	g++/stl_slist.h	/^	list_node_base* erase_after(list_node_base* pos) {$/;"	f	class:std::slist
erase_bucket	g++/stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase_bucket(const size_type n, node* last)$/;"	f	class:hashtable
erase_bucket	g++/stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::erase_bucket(const size_type n, $/;"	f	class:hashtable
errorLine	tcl.h	/^    int errorLine;              \/* When TCL_ERROR is returned, this gives$/;"	m	struct:Tcl_Interp
event	tk.h	/^    Window event;	    \/* Window on which event was requested. *\/$/;"	m	struct:__anon34
exceptions	g++/streambuf.h	/^    iostate exceptions() const { return _exceptions; }$/;"	f	class:ios
exceptions	g++/streambuf.h	/^    void exceptions(iostate enable) {$/;"	f	class:ios
excess_slop	g++/std/bastring.cc	/^excess_slop (size_t s, size_t r)$/;"	f	class:basic_string::Rep
exp	g++/std/complext.cc	/^exp (const complex<FLOAT>& x)$/;"	f
exp_app_exit	expect_tcl.h	/^EXTERN void	(*exp_app_exit)_ANSI_ARGS_((Tcl_Interp *));$/;"	v
exp_autoallocpty	expect.h	/^EXTERN int exp_autoallocpty;		\/* if TRUE, we do allocation *\/$/;"	v
exp_bogus	expect.h	/^	exp_bogus		\/* aid in reporting compatibility problems *\/$/;"	e	enum:exp_type
exp_buffer	expect.h	/^EXTERN char *exp_buffer;		\/* buffer of matchable chars *\/$/;"	v
exp_buffer_command_input	expect_tcl.h	/^EXTERN int exp_buffer_command_input;$/;"	v
exp_buffer_end	expect.h	/^EXTERN char *exp_buffer_end;		\/* one beyond end of matchable chars *\/$/;"	v
exp_case	expect.h	/^struct exp_case {		\/* case for expect command *\/$/;"	s
exp_child_exec_prelude	expect.h	/^EXTERN void (*exp_child_exec_prelude) _ANSI_ARGS_((void));$/;"	v
exp_close_in_child	expect_comm.h	/^EXTERN void (*exp_close_in_child)();	\/* procedure to close files in child *\/$/;"	v
exp_cmdfile	expect_tcl.h	/^EXTERN FILE *exp_cmdfile;$/;"	v
exp_cmdfilename	expect_tcl.h	/^EXTERN char *exp_cmdfilename;$/;"	v
exp_cmdlinecmds	expect_tcl.h	/^EXTERN int exp_cmdlinecmds;$/;"	v
exp_compiled	expect.h	/^	exp_compiled,		\/* regexp-style, compiled *\/$/;"	e	enum:exp_type
exp_console	expect.h	/^EXTERN int exp_console;			\/* redirect console *\/$/;"	v
exp_debugfile	expect.h	/^EXTERN FILE *exp_debugfile;$/;"	v
exp_disconnected	expect_comm.h	/^EXTERN int exp_disconnected;		\/* proc. disc'd from controlling tty *\/$/;"	v
exp_end	expect.h	/^	exp_end = 0,		\/* placeholder - no more cases *\/$/;"	e	enum:exp_type
exp_exact	expect.h	/^	exp_exact,		\/* exact string *\/$/;"	e	enum:exp_type
exp_full_buffer	expect.h	/^EXTERN int exp_full_buffer;		\/* if true, return on full buffer *\/$/;"	v
exp_getpid	expect_tcl.h	/^EXTERN int exp_getpid;	\/* pid of Expect itself *\/$/;"	v
exp_glob	expect.h	/^	exp_glob,		\/* glob-style *\/$/;"	e	enum:exp_type
exp_interactive	expect_tcl.h	/^EXTERN int exp_interactive;$/;"	v
exp_interp	expect_tcl.h	/^EXTERN Tcl_Interp *exp_interp;$/;"	v
exp_is_debugging	expect_comm.h	/^EXTERN int exp_is_debugging;$/;"	v
exp_logfile	expect.h	/^EXTERN FILE *exp_logfile;$/;"	v
exp_logfile_all	expect.h	/^EXTERN int exp_logfile_all;$/;"	v
exp_loguser	expect_comm.h	/^EXTERN int exp_loguser;$/;"	v
exp_match	expect.h	/^EXTERN char *exp_match;			\/* start of matched string *\/$/;"	v
exp_match_end	expect.h	/^EXTERN char *exp_match_end;		\/* one beyond end of matched string *\/$/;"	v
exp_match_max	expect.h	/^EXTERN int exp_match_max;		\/* bytes *\/$/;"	v
exp_null	expect.h	/^	exp_null,		\/* matches binary 0 *\/$/;"	e	enum:exp_type
exp_pid	expect.h	/^EXTERN int exp_pid;			\/* process-id of spawned process *\/$/;"	v
exp_pty	expect.h	/^EXTERN int exp_pty[2];			\/* master is [0], slave is [1] *\/$/;"	v
exp_pty_error	expect_comm.h	/^EXTERN char *exp_pty_error;		\/* place to pass a string generated *\/$/;"	v
exp_pty_slave_name	expect.h	/^EXTERN char *exp_pty_slave_name;	\/* name of pty slave device if we *\/$/;"	v
exp_pty_timeout	expect.h	/^EXTERN int exp_pty_timeout;		\/* see Cray hooks in source *\/$/;"	v
exp_readenv	expect.h	/^EXTERN jmp_buf exp_readenv;		\/* for interruptable read() *\/$/;"	v
exp_reading	expect.h	/^EXTERN int exp_reading;			\/* whether we can longjmp or not *\/$/;"	v
exp_regexp	expect.h	/^	exp_regexp,		\/* regexp-style, uncompiled *\/$/;"	e	enum:exp_type
exp_remove_nulls	expect.h	/^EXTERN int exp_remove_nulls;		\/* if true, remove nulls *\/$/;"	v
exp_stty_init	expect.h	/^EXTERN char *exp_stty_init;		\/* initial stty args *\/$/;"	v
exp_tcl_debugger_available	expect_tcl.h	/^EXTERN int exp_tcl_debugger_available;$/;"	v
exp_timeout	expect.h	/^EXTERN int exp_timeout;			\/* seconds *\/$/;"	v
exp_ttycopy	expect.h	/^EXTERN int exp_ttycopy;			\/* copy tty parms from \/dev\/tty *\/$/;"	v
exp_ttyinit	expect.h	/^EXTERN int exp_ttyinit;			\/* set tty parms to sane state *\/$/;"	v
exp_type	expect.h	/^enum exp_type {$/;"	g
explicit	g++/stl_config.h	191;"	d
extra	g++/stl_alloc.h	/^enum {extra = 8};       \/\/ Size of space used to store size.  Note$/;"	e	enum:debug_alloc::__anon4
extra	g++/stl_alloc.h	/^enum {extra = 8};       \/\/ Size of space used to store size.  Note$/;"	e	enum:debug_alloc::__anon75
f	g++/iomanip.h	/^    iapp(istream& (*f)(istream&,TP)) : _f(f) {}$/;"	f	class:iapp
f	g++/iomanip.h	/^    oapp(ostream& (*f)(ostream&,TP)) : _f(f) {}$/;"	f	class:oapp
f	g++/iomanip.h	/^    sapp(ios& (*f)(ios&, TP)) : _f(f) {}$/;"	f	class:sapp
f	g++/stl_function.h	/^  S (T::*f)() const;$/;"	m	class:const_mem_fun_ref_t
f	g++/stl_function.h	/^  S (T::*f)() const;$/;"	m	class:const_mem_fun_t
f	g++/stl_function.h	/^  S (T::*f)();$/;"	m	class:mem_fun_ref_t
f	g++/stl_function.h	/^  S (T::*f)();$/;"	m	class:mem_fun_t
f	g++/stl_function.h	/^  S (T::*f)(A) const;$/;"	m	class:const_mem_fun1_ref_t
f	g++/stl_function.h	/^  S (T::*f)(A) const;$/;"	m	class:const_mem_fun1_t
f	g++/stl_function.h	/^  S (T::*f)(A);$/;"	m	class:mem_fun1_ref_t
f	g++/stl_function.h	/^  S (T::*f)(A);$/;"	m	class:mem_fun1_t
f	g++/stl_function.h	/^  void (T::*f)() const;$/;"	m	class:const_mem_fun_ref_t
f	g++/stl_function.h	/^  void (T::*f)() const;$/;"	m	class:const_mem_fun_t
f	g++/stl_function.h	/^  void (T::*f)();$/;"	m	class:mem_fun_ref_t
f	g++/stl_function.h	/^  void (T::*f)();$/;"	m	class:mem_fun_t
f	g++/stl_function.h	/^  void (T::*f)(A) const;$/;"	m	class:const_mem_fun1_ref_t
f	g++/stl_function.h	/^  void (T::*f)(A) const;$/;"	m	class:const_mem_fun1_t
f	g++/stl_function.h	/^  void (T::*f)(A);$/;"	m	class:mem_fun1_ref_t
f	g++/stl_function.h	/^  void (T::*f)(A);$/;"	m	class:mem_fun1_t
fail	g++/streambuf.h	/^    int fail() const { return _state & (ios::badbit|ios::failbit); }$/;"	f	class:ios
failbit	g++/streambuf.h	/^	failbit = _IOS_FAIL,$/;"	e	enum:ios::io_state
failure	g++/streambuf.h	/^	failure(ios* stream) { _stream = stream; }$/;"	f	class:ios::failure
failure	g++/streambuf.h	/^	failure(string cause, ios* stream) { _stream = stream; }$/;"	f	class:ios::failure
failure	g++/streambuf.h	/^    class failure : public xmsg {$/;"	c	class:ios
false	bfd.h	/^typedef enum bfd_boolean {false, true} boolean;$/;"	e	enum:bfd_boolean
false	g++/stl_config.h	182;"	d
false	include/stdbool.h	/^    false = 0,$/;"	e	enum:__anon14
false	include/stdbool.h	/^    false = 0,$/;"	e	enum:__anon39
false	include/stdbool.h	14;"	d
fclose	g++/iostdio.h	63;"	d
fd	g++/streambuf.h	/^    int fd() const { return is_open() ? _fileno : EOF; }$/;"	f	class:filebuf
fdopen	g++/iostdio.h	106;"	d
feof	g++/iostdio.h	64;"	d
ferror	g++/iostdio.h	65;"	d
fetch	g++/ropeimpl.h	/^rope<charT,Alloc>::fetch(RopeBase *r, size_type i)$/;"	f	class:rope
fetch_ptr	g++/ropeimpl.h	/^rope<charT,Alloc>::fetch_ptr(RopeBase *r, size_type i)$/;"	f	class:rope
fflush	g++/iostdio.h	66;"	d
fgetc	g++/iostdio.h	67;"	d
fgetpos	g++/iostdio.h	68;"	d
fgets	g++/iostdio.h	69;"	d
field1	g++/libio.h	/^    struct _IO_lock_t { void *ptr; short int field1; short int field2; };$/;"	m	struct:_IO_lock_t
field2	g++/libio.h	/^    struct _IO_lock_t { void *ptr; short int field1; short int field2; };$/;"	m	struct:_IO_lock_t
file	g++/libio.h	/^  struct _IO_FILE file;$/;"	m	struct:_IO_cookie_file	typeref:struct:_IO_cookie_file::_IO_FILE
file	g++/libioP.h	/^  _IO_FILE file;$/;"	m	struct:_IO_FILE_plus
fileMatchProc	tk.h	/^    Tk_ImageFileMatchProc *fileMatchProc;$/;"	m	struct:Tk_PhotoImageFormat
fileReadProc	tk.h	/^    Tk_ImageFileReadProc *fileReadProc;$/;"	m	struct:Tk_PhotoImageFormat
fileWriteProc	tk.h	/^    Tk_ImageFileWriteProc *fileWriteProc;$/;"	m	struct:Tk_PhotoImageFormat
file_offset	bfd.h	/^  file_ptr file_offset;		\/* look here to find the file *\/$/;"	m	struct:carsym
file_ptr	bfd.h	/^typedef long int file_ptr;$/;"	t
file_ptr	g++/streambuf.h	/^    char* file_ptr() { return eGptr(); }$/;"	f	class:filebuf
filebuf	g++/streambuf.h	/^class filebuf : public streambuf {$/;"	c
filedesc	g++/fstream.h	/^    int filedesc() { return rdbuf()->fd(); }$/;"	f	class:fstreambase
filename	bfd.h	/^    CONST char *filename;                $/;"	m	struct:_bfd
fileno	g++/iostdio.h	107;"	d
filepos	bfd.h	/^   file_ptr filepos;$/;"	m	struct:sec
files	g++/editbuf.h	/^    struct edit_streambuf *files;$/;"	m	struct:edit_buffer	typeref:struct:edit_buffer::edit_streambuf
fill	bfdlink.h	/^	} fill;$/;"	m	union:bfd_link_order::__anon64	typeref:struct:bfd_link_order::__anon64::__anon66
fill	g++/stl_algobase.h	/^void fill(ForwardIterator first, ForwardIterator last, const T& value) $/;"	f
fill	g++/streambuf.h	/^    _IO_wchar_t fill() const { return _fill; }$/;"	f	class:ios
fill	g++/streambuf.h	/^    _IO_wchar_t fill(_IO_wchar_t newf)$/;"	f	class:ios
fill_initialize	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::fill_initialize(size_type n, const value_type& value) $/;"	f	class:std::deque
fill_initialize	g++/stl_list.h	/^	void fill_initialize(size_type n, const T& value){$/;"	f	class:std::list
fill_initialize	g++/stl_slist.h	/^	void fill_initialize(size_type n, const value_type& x) {$/;"	f	class:std::slist
fill_initialize	g++/stl_vector.h	/^	void fill_initialize(size_type n, const T& value) $/;"	f	class:vector
fill_n	g++/stl_algobase.h	/^fill_n(OutputIterator first, Size n, const T& value) $/;"	f
find	g++/ropeimpl.h	/^rope<charT,Alloc>::find(charT pattern, size_t start) const$/;"	f	class:rope
find	g++/std/bastring.cc	/^find (const charT* s, size_type pos, size_type n) const$/;"	f	class:basic_string
find	g++/std/bastring.cc	/^find(charT c, size_type pos) const$/;"	f	class:basic_string
find	g++/std/bastring.h	/^	size_type find(const basic_string& str, size_type pos = 0) const$/;"	f	class:basic_string
find	g++/std/bastring.h	/^	size_type find(const charT* s, size_type pos = 0) const$/;"	f	class:basic_string
find	g++/stl_algo.h	/^InputIterator find(InputIterator first, InputIterator last, const T& value) {$/;"	f
find	g++/stl_hash_map.h	/^  const_iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_map
find	g++/stl_hash_map.h	/^  const_iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_multimap
find	g++/stl_hash_map.h	/^  iterator find(const key_type& key) { return rep.find(key); }$/;"	f	class:hash_map
find	g++/stl_hash_map.h	/^  iterator find(const key_type& key) { return rep.find(key); }$/;"	f	class:hash_multimap
find	g++/stl_hash_set.h	/^  iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_multiset
find	g++/stl_hash_set.h	/^  iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_set
find	g++/stl_hashtable.h	/^  const_iterator find(const key_type& key) const$/;"	f	class:hashtable
find	g++/stl_hashtable.h	/^  iterator find(const key_type& key) $/;"	f	class:hashtable
find	g++/stl_map.h	/^  const_iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:map
find	g++/stl_map.h	/^  iterator find(const key_type& x) { return t.find(x); }$/;"	f	class:map
find	g++/stl_multimap.h	/^  const_iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:multimap
find	g++/stl_multimap.h	/^  iterator find(const key_type& x) { return t.find(x); }$/;"	f	class:multimap
find	g++/stl_multiset.h	/^  iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:multiset
find	g++/stl_rope.h	/^	size_type find(charT *s, size_type pos = 0) const {$/;"	f	class:rope
find	g++/stl_set.h	/^  iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:set
find	g++/stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key& k) const {$/;"	f	class:rb_tree
find	g++/stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key& k) {$/;"	f	class:rb_tree
findProc	tcl.h	/^    Tcl_HashEntry *(*findProc) _ANSI_ARGS_((struct Tcl_HashTable *tablePtr,$/;"	m	struct:Tcl_HashTable
find_end	g++/stl_algo.h	/^find_end(ForwardIterator1 first1, ForwardIterator1 last1, $/;"	f
find_first_not_of	g++/std/bastring.cc	/^find_first_not_of (charT c, size_type pos) const$/;"	f	class:basic_string
find_first_not_of	g++/std/bastring.cc	/^find_first_not_of (const charT* s, size_type pos, size_type n) const$/;"	f	class:basic_string
find_first_not_of	g++/std/bastring.h	/^	size_type find_first_not_of (const basic_string& str, size_type pos = 0) const$/;"	f	class:basic_string
find_first_not_of	g++/std/bastring.h	/^	size_type find_first_not_of (const charT* s, size_type pos = 0) const$/;"	f	class:basic_string
find_first_of	g++/std/bastring.cc	/^find_first_of (const charT* s, size_type pos, size_type n) const$/;"	f	class:basic_string
find_first_of	g++/std/bastring.h	/^	size_type find_first_of (charT c, size_type pos = 0) const$/;"	f	class:basic_string
find_first_of	g++/std/bastring.h	/^	size_type find_first_of (const basic_string& str, size_type pos = 0) const$/;"	f	class:basic_string
find_first_of	g++/std/bastring.h	/^	size_type find_first_of (const charT* s, size_type pos = 0) const$/;"	f	class:basic_string
find_first_of	g++/stl_algo.h	/^InputIterator find_first_of(InputIterator first1, InputIterator last1,$/;"	f
find_if	g++/stl_algo.h	/^InputIterator find_if(InputIterator first, InputIterator last,$/;"	f
find_last_not_of	g++/std/bastring.cc	/^find_last_not_of (charT c, size_type pos) const$/;"	f	class:basic_string
find_last_not_of	g++/std/bastring.cc	/^find_last_not_of (const charT* s, size_type pos, size_type n) const$/;"	f	class:basic_string
find_last_not_of	g++/std/bastring.h	/^	size_type find_last_not_of (const basic_string& str, size_type pos = npos) const$/;"	f	class:basic_string
find_last_not_of	g++/std/bastring.h	/^	size_type find_last_not_of (const charT* s, size_type pos = npos) const$/;"	f	class:basic_string
find_last_of	g++/std/bastring.cc	/^find_last_of (const charT* s, size_type pos, size_type n) const$/;"	f	class:basic_string
find_last_of	g++/std/bastring.h	/^	size_type find_last_of (charT c, size_type pos = npos) const$/;"	f	class:basic_string
find_last_of	g++/std/bastring.h	/^	size_type find_last_of (const basic_string& str, size_type pos = npos) const$/;"	f	class:basic_string
find_last_of	g++/std/bastring.h	/^	size_type find_last_of (const charT* s, size_type pos = npos) const$/;"	f	class:basic_string
find_or_insert	g++/stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::find_or_insert(const value_type& obj)$/;"	f	class:hashtable
finish	g++/stl_bvector.h	/^  iterator finish;$/;"	m	class:vector
finish	g++/stl_deque.h	/^	iterator finish;	\/\/$/;"	m	class:std::deque
finish	g++/stl_vector.h	/^	iterator 									finish;$/;"	m	class:vector
first	g++/stl_deque.h	/^	T* first;			\/\/$/;"	m	struct:std::__deque_iterator
first	g++/stl_pair.h	/^  T1 first;$/;"	m	struct:pair
first_argument_type	g++/stl_function.h	/^    typedef Arg1 first_argument_type;$/;"	t	struct:binary_function
first_type	g++/stl_pair.h	/^  typedef T1 first_type;$/;"	t	struct:pair
fixed	g++/streambuf.h	/^	   scientific=_IO_SCIENTIFIC, fixed=_IO_FIXED,$/;"	e	enum:ios::__anon1
fixed	g++/streambuf.h	/^	   scientific=_IO_SCIENTIFIC, fixed=_IO_FIXED,$/;"	e	enum:ios::__anon72
flags	bfd.h	/^    flagword flags;              $/;"	m	struct:_bfd
flags	bfd.h	/^    flagword flags;$/;"	m	struct:sec
flags	bfd.h	/^  flagword flags;$/;"	m	struct:symbol_cache_entry
flags	g++/streambuf.h	/^    fmtflags flags() const { return _flags; }$/;"	f	class:ios
flags	g++/streambuf.h	/^    fmtflags flags(fmtflags new_val) {$/;"	f	class:ios
flags	tk.h	/^    unsigned int flags;$/;"	m	struct:Tk_FakeWin
flagword	bfd.h	/^typedef unsigned int flagword;	\/* 32 bits of flags *\/$/;"	t
flatten	g++/ropeimpl.h	/^rope<charT,Alloc>::flatten(RopeBase * r, charT * buffer)$/;"	f	class:rope
flatten	g++/ropeimpl.h	/^rope<charT,Alloc>::flatten(RopeBase * r,$/;"	f	class:rope
flavour	bfd.h	/^  enum bfd_flavour flavour;$/;"	m	struct:bfd_target	typeref:enum:bfd_target::bfd_flavour
flip	g++/stl_bvector.h	/^  void flip() { *p ^= mask; }$/;"	f	struct:__bit_reference
floatfield	g++/streambuf.h	/^	floatfield = scientific+fixed,$/;"	e	enum:ios::__anon2
floatfield	g++/streambuf.h	/^	floatfield = scientific+fixed,$/;"	e	enum:ios::__anon73
flush	g++/stl_rope.h	/^	void flush() {$/;"	f	class:sequence_buffer
flush_to_buffer	g++/editbuf.h	/^inline void edit_streambuf::flush_to_buffer()$/;"	f	class:edit_streambuf
fmtflags	g++/streambuf.h	/^    typedef __fmtflags fmtflags;$/;"	t	class:ios
fn	g++/stl_rope.h	/^    char_producer<charT>* fn;$/;"	m	struct:__rope_RopeFunction
fn_finalization_proc	g++/ropeimpl.h	/^void __rope_RopeBase<charT,Alloc>::fn_finalization_proc(void * tree, void *)$/;"	f	class:__rope_RopeBase
focusItemPtr	tk.h	/^    Tk_Item *focusItemPtr;	\/* Item that currently has the input focus,$/;"	m	struct:Tk_CanvasTextInfo
fopen	g++/iostdio.h	70;"	d
for_each	g++/stl_algo.h	/^Function for_each(InputIterator first, InputIterator last, Function f) {$/;"	f
format	bfd.h	/^    bfd_format format;$/;"	m	struct:_bfd
forward_iterator	g++/stl_iterator.h	/^struct forward_iterator {$/;"	s
forward_iterator_tag	g++/stl_iterator.h	/^struct forward_iterator_tag :             \/\/read and write, can ++ or --$/;"	s
fpr	include/va-ppc.h	/^  char fpr;			\/* index into the array of 8 FPRs stored in the$/;"	m	struct:__va_list_tag
fprintf	g++/iostdio.h	71;"	d
fprintf_vma	bfd.h	148;"	d
fprintf_vma	bfd.h	152;"	d
fprintf_vma	bfd.h	176;"	d
fputc	g++/iostdio.h	72;"	d
fputs	g++/iostdio.h	73;"	d
fread	g++/iostdio.h	74;"	d
freeIntRepProc	tcl.h	/^    Tcl_FreeInternalRepProc *freeIntRepProc;$/;"	m	struct:Tcl_ObjType
freeProc	tcl.h	/^    void (*freeProc) _ANSI_ARGS_((char *blockPtr));$/;"	m	struct:Tcl_Interp
freeProc	tk.h	/^    Tk_ImageFreeProc *freeProc;	\/* Procedure to call whenever Tk_FreeImage$/;"	m	struct:Tk_ImageType
free_c_string	g++/ropeimpl.h	/^inline void __rope_RopeBase<charT,Alloc>::free_c_string()$/;"	f	class:__rope_RopeBase
free_if_unref	g++/stl_rope.h	/^	  static void free_if_unref(__rope_RopeBase* t) {}$/;"	f	struct:__rope_RopeBase
free_if_unref	g++/stl_rope.h	/^	  static void free_if_unref(__rope_RopeBase* t)$/;"	f	struct:__rope_RopeBase
free_list	g++/stl_alloc.h	/^    static obj* volatile free_list[__NFREELISTS]; $/;"	m	class:__default_alloc_template
free_list	g++/stl_alloc.h	/^__default_alloc_template<threads, inst> ::free_list[$/;"	m	class:__default_alloc_template
free_list_link	g++/stl_alloc.h	/^        union obj * free_list_link;$/;"	m	union:__default_alloc_template::obj	typeref:union:__default_alloc_template::obj::obj
free_string	g++/ropeimpl.h	/^inline void __rope_RopeBase<charT,Alloc>::free_string(charT* s, size_t n)$/;"	f	class:__rope_RopeBase
free_tree	g++/ropeimpl.h	/^void __rope_RopeBase<charT,Alloc>::free_tree()$/;"	f	class:__rope_RopeBase
freeze	g++/strstream.h	/^    void freeze(int n = 1) { ((strstreambuf*)_strbuf)->freeze(n); }$/;"	f	class:ostrstream
freeze	g++/strstream.h	/^    void freeze(int n = 1) { ((strstreambuf*)_strbuf)->freeze(n); }$/;"	f	class:strstream
freeze	g++/strstream.h	/^    void freeze(int n=1)$/;"	f	class:strstreambuf
freopen	g++/iostdio.h	75;"	d
frob_size	g++/std/bastring.cc	/^frob_size(size_t s)$/;"	f	class:basic_string::Rep
front	g++/stl_bvector.h	/^  const_reference front() const { return *begin(); }$/;"	f	class:vector
front	g++/stl_bvector.h	/^  reference front() { return *begin(); }$/;"	f	class:vector
front	g++/stl_deque.h	/^	const_reference front() const { return *start; }$/;"	f	class:std::deque
front	g++/stl_deque.h	/^	reference front() { return *start; }$/;"	f	class:std::deque
front	g++/stl_list.h	/^	const_reference front() const { $/;"	f	class:std::list
front	g++/stl_list.h	/^	reference front() { $/;"	f	class:std::list
front	g++/stl_queue.h	/^	const_reference front() const { return c.front(); }$/;"	f	class:queue
front	g++/stl_queue.h	/^	reference front() { return c.front(); }$/;"	f	class:queue
front	g++/stl_rope.h	/^	charT front() const$/;"	f	class:rope
front	g++/stl_slist.h	/^	const_reference front() const { return ((list_node*) head.next)->data; }$/;"	f	class:std::slist
front	g++/stl_slist.h	/^	reference front() { return ((list_node*) head.next)->data; }$/;"	f	class:std::slist
front	g++/stl_vector.h	/^	const_reference front() const { return *begin(); }$/;"	f	class:vector
front	g++/stl_vector.h	/^	reference front() { return *begin(); }$/;"	f	class:vector
front_insert_iterator	g++/stl_iterator.h	/^  explicit front_insert_iterator(Container& x) : container(&x) {}$/;"	f	class:front_insert_iterator
front_insert_iterator	g++/stl_iterator.h	/^class front_insert_iterator {$/;"	c
front_inserter	g++/stl_iterator.h	/^inline front_insert_iterator<Container> front_inserter(Container& x) {$/;"	f
frozen	g++/strstream.h	/^    int frozen() { return ((strstreambuf*)_strbuf)->frozen(); }$/;"	f	class:ostrstream
frozen	g++/strstream.h	/^    int frozen() { return ((strstreambuf*)_strbuf)->frozen(); }$/;"	f	class:strstream
frozen	g++/strstream.h	/^    int frozen() { return _flags & _IO_USER_BUF ? 1 : 0; }$/;"	f	class:strstreambuf
fscanf	g++/iostdio.h	76;"	d
fseek	g++/iostdio.h	77;"	d
fsetpos	g++/iostdio.h	78;"	d
fstream	g++/fstream.h	/^    fstream() : fstreambase() { }$/;"	f	class:fstream
fstream	g++/fstream.h	/^    fstream(const char *name, int mode, int prot=0664)$/;"	f	class:fstream
fstream	g++/fstream.h	/^    fstream(int fd) : fstreambase(fd) { }$/;"	f	class:fstream
fstream	g++/fstream.h	/^    fstream(int fd, char *p, int l) : fstreambase(fd, p, l) { } \/*Deprecated*\/$/;"	f	class:fstream
fstream	g++/fstream.h	/^class fstream : public fstreambase, public iostream {$/;"	c
fstreambase	g++/fstream.h	/^class fstreambase : virtual public ios {$/;"	c
ftell	g++/iostdio.h	79;"	d
fullName	tcl.h	/^    char *fullName;             \/* The namespace's fully qualified name.$/;"	m	struct:Tcl_Namespace
func	Dbg.h	/^  Dbg_InterProc *func;$/;"	m	struct:__anon70
func	Dbg.h	/^  Dbg_OutputProc *func;$/;"	m	struct:__anon71
func_parsebuf	g++/parsestream.h	/^class func_parsebuf : public parsebuf {$/;"	c
function	g++/stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon80
function	g++/stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon9
function	readline/keymaps.h	/^  Function *function;$/;"	m	struct:_keymap_entry
function	readline/readline.h	/^  Function *function;$/;"	m	struct:__anon28
function	readline/readline.h	/^  Function *function;$/;"	m	struct:__anon29
fwrite	g++/iostdio.h	80;"	d
gap_end	g++/editbuf.h	/^    inline buf_char *gap_end() { return data + gap_end_pos(); }$/;"	f	struct:edit_buffer
gap_end_pos	g++/editbuf.h	/^    inline buf_offset gap_end_pos() { return __gap_end_pos; }$/;"	f	struct:edit_buffer
gap_size	g++/editbuf.h	/^    inline int gap_size() { return gap_end() - gap_start(); }$/;"	f	struct:edit_buffer
gap_start	g++/editbuf.h	/^    inline buf_char *gap_start()$/;"	f	struct:edit_buffer
gbump	g++/streambuf.h	/^    void gbump(int n)$/;"	f	struct:streambuf
gc_mark	bfd.h	/^       unsigned int gc_mark : 1;$/;"	m	struct:sec
gcount	g++/iostream.h	/^    _IO_size_t gcount() { return _gcount; }$/;"	f	class:istream
general_parsebuf	g++/parsestream.h	/^class general_parsebuf : public parsebuf {$/;"	c
generate	g++/stl_algo.h	/^void generate(ForwardIterator first, ForwardIterator last, Generator gen) {$/;"	f
generate_n	g++/stl_algo.h	/^OutputIterator generate_n(OutputIterator first, Size n, Generator gen) {$/;"	f
get	g++/iostream.h	/^    int get() { if (!ipfx1()) return EOF;$/;"	f	class:istream
get	g++/iostream.h	/^    istream& get(signed char& c)  { return get((char&)c); }$/;"	f	class:istream
get	g++/iostream.h	/^    istream& get(signed char* ptr, int len, char delim = '\\n')$/;"	f	class:istream
get	g++/iostream.h	/^    istream& get(unsigned char& c) { return get((char&)c); }$/;"	f	class:istream
get	g++/iostream.h	/^    istream& get(unsigned char* ptr, int len, char delim = '\\n')$/;"	f	class:istream
getHandleProc	tcl.h	/^    Tcl_DriverGetHandleProc *getHandleProc;$/;"	m	struct:Tcl_ChannelType
getOptionProc	tcl.h	/^    Tcl_DriverGetOptionProc *getOptionProc;$/;"	m	struct:Tcl_ChannelType
getProc	tk.h	/^    Tk_ImageGetProc *getProc;	\/* Procedure to call the first time$/;"	m	struct:Tk_ImageType
get_key	g++/stl_hashtable.h	/^  ExtractKey get_key;$/;"	m	class:hashtable
get_node	g++/stl_list.h	/^	link_type get_node() { $/;"	f	class:std::list
get_node	g++/stl_tree.h	/^  link_type get_node() { return rb_tree_node_allocator::allocate(); }$/;"	f	class:rb_tree
get_stream	g++/indstream.h	/^    streambuf *get_stream()$/;"	f	class:indirectbuf
get_temporary_buffer	g++/stl_tempbuf.h	/^pair<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t len, T*) {$/;"	f
getc	g++/iostdio.h	59;"	d
getline	g++/iostream.h	/^    istream& getline(signed char* ptr, int len, char delim = '\\n')$/;"	f	class:istream
getline	g++/iostream.h	/^    istream& getline(unsigned char* ptr, int len, char delim = '\\n')$/;"	f	class:istream
getline	g++/std/bastring.cc	/^getline(istream &is, basic_string<charT, traits, Allocator>& s, charT delim)$/;"	f
gets	g++/iostdio.h	81;"	d
globals	bfdlink.h	/^  struct bfd_elf_version_expr *globals;$/;"	m	struct:bfd_elf_version_tree	typeref:struct:bfd_elf_version_tree::bfd_elf_version_expr
good	g++/streambuf.h	/^    int good() const { return _state == 0; }$/;"	f	class:ios
goodbit	g++/streambuf.h	/^	goodbit = _IOS_GOOD,$/;"	e	enum:ios::io_state
gotFocus	tk.h	/^    int gotFocus;		\/* Non-zero means that the canvas widget has$/;"	m	struct:Tk_CanvasTextInfo
gpr	include/va-ppc.h	/^  char gpr;			\/* index into the array of 8 GPRs stored in the$/;"	m	struct:__va_list_tag
gptr	g++/streambuf.h	/^    char* gptr() const$/;"	f	struct:streambuf
grab	g++/std/bastring.h	/^		charT* grab() $/;"	f	struct:basic_string::Rep
greater	g++/stl_function.h	/^struct greater : public binary_function<T, T, bool> {$/;"	s
greater_equal	g++/stl_function.h	/^struct greater_equal : public binary_function<T, T, bool> {$/;"	s
has_armap	bfd.h	/^    boolean has_armap;           $/;"	m	struct:_bfd
has_trivial_assignment_operator	g++/type_traits.h	/^	typedef __false_type    has_trivial_assignment_operator;$/;"	t	struct:__type_traits
has_trivial_assignment_operator	g++/type_traits.h	/^	typedef __true_type    has_trivial_assignment_operator;$/;"	t	struct:__type_traits
has_trivial_assignment_operator	g++/type_traits.h	/^   typedef __true_type    has_trivial_assignment_operator;$/;"	t	struct:__type_traits
has_trivial_copy_constructor	g++/type_traits.h	/^	typedef __false_type    has_trivial_copy_constructor;$/;"	t	struct:__type_traits
has_trivial_copy_constructor	g++/type_traits.h	/^	typedef __true_type    has_trivial_copy_constructor;$/;"	t	struct:__type_traits
has_trivial_copy_constructor	g++/type_traits.h	/^   typedef __true_type    has_trivial_copy_constructor;$/;"	t	struct:__type_traits
has_trivial_default_constructor	g++/type_traits.h	/^	typedef __false_type    has_trivial_default_constructor;$/;"	t	struct:__type_traits
has_trivial_default_constructor	g++/type_traits.h	/^	typedef __true_type    has_trivial_default_constructor;$/;"	t	struct:__type_traits
has_trivial_default_constructor	g++/type_traits.h	/^   typedef __true_type    has_trivial_default_constructor;$/;"	t	struct:__type_traits
has_trivial_destructor	g++/type_traits.h	/^	typedef __false_type    has_trivial_destructor;$/;"	t	struct:__type_traits
has_trivial_destructor	g++/type_traits.h	/^	typedef __true_type    has_trivial_destructor;$/;"	t	struct:__type_traits
has_trivial_destructor	g++/type_traits.h	/^   typedef __true_type    has_trivial_destructor;$/;"	t	struct:__type_traits
hash	bfd.h	/^  unsigned long hash;$/;"	m	struct:bfd_hash_entry
hash	bfdlink.h	/^  struct bfd_link_hash_table *hash;$/;"	m	struct:bfd_link_info	typeref:struct:bfd_link_info::bfd_link_hash_table
hash	g++/stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<char*>$/;"	s
hash	g++/stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<char> {$/;"	s
hash	g++/stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<const char*>$/;"	s
hash	g++/stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<int> {$/;"	s
hash	g++/stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<long> {$/;"	s
hash	g++/stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<short> {$/;"	s
hash	g++/stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<signed char> {$/;"	s
hash	g++/stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned char> {$/;"	s
hash	g++/stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned int> {$/;"	s
hash	g++/stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned long> {$/;"	s
hash	g++/stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned short> {$/;"	s
hash	g++/stl_hash_fun.h	/^template <class Key> struct hash { };$/;"	s
hash	g++/stl_hashtable.h	/^  hasher hash;$/;"	m	class:hashtable
hash	g++/stl_rope.h	/^__STL_TEMPLATE_NULL struct hash<crope>$/;"	s
hash	g++/stl_rope.h	/^__STL_TEMPLATE_NULL struct hash<wrope>$/;"	s
hash_funct	g++/stl_hash_map.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_map
hash_funct	g++/stl_hash_map.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_multimap
hash_funct	g++/stl_hash_set.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_multiset
hash_funct	g++/stl_hash_set.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_set
hash_funct	g++/stl_hashtable.h	/^  hasher hash_funct() const { return hash; }$/;"	f	class:hashtable
hash_map	g++/stl_hash_map.h	/^  explicit hash_map(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_map
hash_map	g++/stl_hash_map.h	/^  hash_map() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_map
hash_map	g++/stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l)$/;"	f	class:hash_map
hash_map	g++/stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_map
hash_map	g++/stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_map
hash_map	g++/stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l)$/;"	f	class:hash_map
hash_map	g++/stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_map
hash_map	g++/stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_map
hash_map	g++/stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l)$/;"	f	class:hash_map
hash_map	g++/stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_map
hash_map	g++/stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_map
hash_map	g++/stl_hash_map.h	/^  hash_map(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_map
hash_map	g++/stl_hash_map.h	/^  hash_map(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_map
hash_map	g++/stl_hash_map.h	/^class hash_map$/;"	c
hash_multimap	g++/stl_hash_map.h	/^  explicit hash_multimap(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_multimap
hash_multimap	g++/stl_hash_map.h	/^  hash_multimap() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_multimap
hash_multimap	g++/stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l)$/;"	f	class:hash_multimap
hash_multimap	g++/stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_multimap
hash_multimap	g++/stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_multimap
hash_multimap	g++/stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l)$/;"	f	class:hash_multimap
hash_multimap	g++/stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_multimap
hash_multimap	g++/stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_multimap
hash_multimap	g++/stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l)$/;"	f	class:hash_multimap
hash_multimap	g++/stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_multimap
hash_multimap	g++/stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_multimap
hash_multimap	g++/stl_hash_map.h	/^  hash_multimap(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_multimap
hash_multimap	g++/stl_hash_map.h	/^  hash_multimap(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_multimap
hash_multimap	g++/stl_hash_map.h	/^class hash_multimap$/;"	c
hash_multiset	g++/stl_hash_set.h	/^  explicit hash_multiset(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_multiset
hash_multiset	g++/stl_hash_set.h	/^  hash_multiset() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_multiset
hash_multiset	g++/stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l)$/;"	f	class:hash_multiset
hash_multiset	g++/stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_multiset
hash_multiset	g++/stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_multiset
hash_multiset	g++/stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l)$/;"	f	class:hash_multiset
hash_multiset	g++/stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_multiset
hash_multiset	g++/stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_multiset
hash_multiset	g++/stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l)$/;"	f	class:hash_multiset
hash_multiset	g++/stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_multiset
hash_multiset	g++/stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_multiset
hash_multiset	g++/stl_hash_set.h	/^  hash_multiset(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_multiset
hash_multiset	g++/stl_hash_set.h	/^  hash_multiset(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_multiset
hash_multiset	g++/stl_hash_set.h	/^class hash_multiset$/;"	c
hash_set	g++/stl_hash_set.h	/^  explicit hash_set(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_set
hash_set	g++/stl_hash_set.h	/^  hash_set() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_set
hash_set	g++/stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l)$/;"	f	class:hash_set
hash_set	g++/stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_set
hash_set	g++/stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_set
hash_set	g++/stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l)$/;"	f	class:hash_set
hash_set	g++/stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_set
hash_set	g++/stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_set
hash_set	g++/stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l)$/;"	f	class:hash_set
hash_set	g++/stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_set
hash_set	g++/stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_set
hash_set	g++/stl_hash_set.h	/^  hash_set(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_set
hash_set	g++/stl_hash_set.h	/^  hash_set(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_set
hash_set	g++/stl_hash_set.h	/^class hash_set$/;"	c
hasher	g++/stl_hash_map.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_map
hasher	g++/stl_hash_map.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_multimap
hasher	g++/stl_hash_set.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_multiset
hasher	g++/stl_hash_set.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_set
hasher	g++/stl_hashtable.h	/^  typedef HashFcn hasher;$/;"	t	class:hashtable
hashtable	g++/stl_hashtable.h	/^          hashtable;$/;"	t	struct:__hashtable_const_iterator
hashtable	g++/stl_hashtable.h	/^          hashtable;$/;"	t	struct:__hashtable_iterator
hashtable	g++/stl_hashtable.h	/^  hashtable(const hashtable& ht)$/;"	f	class:hashtable
hashtable	g++/stl_hashtable.h	/^  hashtable(size_type n,$/;"	f	class:hashtable
hashtable	g++/stl_hashtable.h	/^class hashtable {$/;"	c
have_backup	g++/streambuf.h	/^    int have_backup() { return _IO_save_base != NULL; }$/;"	f	struct:streambuf
have_markers	g++/streambuf.h	/^    int have_markers() { return _markers != NULL; }$/;"	f	struct:streambuf
head	g++/stl_slist.h	/^	list_node_base head;$/;"	m	class:std::slist
head	tix.h	/^    char * head;		\/* (general pointer) head of the list *\/$/;"	m	struct:Tix_LinkList
header	g++/stl_tree.h	/^  link_type header;  $/;"	m	class:rb_tree
header_byteorder	bfd.h	/^  enum bfd_endian header_byteorder;$/;"	m	struct:bfd_target	typeref:enum:bfd_target::bfd_endian
heap_size	g++/stl_alloc.h	/^	static size_t heap_size;$/;"	m	class:__default_alloc_template
heap_size	g++/stl_alloc.h	/^size_t __default_alloc_template<threads, inst>::heap_size = 0;$/;"	m	class:__default_alloc_template
height	tk.h	/^    int		height;		\/* Height of block, in pixels. *\/$/;"	m	struct:Tk_PhotoImageBlock
help	tk.h	/^    char *help;		\/* Documentation message describing this option. *\/$/;"	m	struct:__anon30
hex	g++/iostream.h	/^inline ios& hex(ios& i)$/;"	f
hex	g++/streambuf.h	/^	   dec=_IO_DEC, oct=_IO_OCT, hex=_IO_HEX,$/;"	e	enum:ios::__anon1
hex	g++/streambuf.h	/^	   dec=_IO_DEC, oct=_IO_OCT, hex=_IO_HEX,$/;"	e	enum:ios::__anon72
howto	bfd.h	/^  reloc_howto_type *howto;$/;"	m	struct:reloc_cache_entry
hppabsd_core_data	bfd.h	/^      struct hppabsd_core_struct *hppabsd_core_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::hppabsd_core_struct
hpux_core_data	bfd.h	/^      struct hpux_core_struct *hpux_core_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::hpux_core_struct
ht	g++/stl_hash_map.h	/^                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;$/;"	t	class:hash_map
ht	g++/stl_hash_map.h	/^                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;$/;"	t	class:hash_multimap
ht	g++/stl_hash_set.h	/^                    EqualKey, Alloc> ht;$/;"	t	class:hash_multiset
ht	g++/stl_hash_set.h	/^                    EqualKey, Alloc> ht;$/;"	t	class:hash_set
ht	g++/stl_hashtable.h	/^  const hashtable* ht;$/;"	m	struct:__hashtable_const_iterator
ht	g++/stl_hashtable.h	/^  hashtable* ht;$/;"	m	struct:__hashtable_iterator
i	bfd.h	/^      bfd_vma i;$/;"	m	union:symbol_cache_entry::__anon37
i	bfd.h	/^  struct _bfd_window_internal *i;$/;"	m	struct:_bfd_window	typeref:struct:_bfd_window::_bfd_window_internal
i	bfdlink.h	/^	} i;$/;"	m	union:bfd_link_hash_entry::__anon59	typeref:struct:bfd_link_hash_entry::__anon59::__anon62
iapp	g++/iomanip.h	/^template<class TP> class iapp {$/;"	c
ibegin	g++/std/bastring.h	/^	iterator ibegin () const { return &(*rep ())[0]; }$/;"	f	class:basic_string
icursorProc	tk.h	/^    Tk_ItemCursorProc *icursorProc;	\/* Procedure to set insert cursor pos.$/;"	m	struct:Tk_ItemType
id	tk.h	/^    int id;				\/* Unique identifier for this item$/;"	m	struct:Tk_Item
identity	g++/stl_function.h	/^struct identity : public unary_function<T, T> {$/;"	s
identity_element	g++/stl_function.h	/^template <class T> inline T identity_element(multiplies<T>) { return T(1); }$/;"	f
identity_element	g++/stl_function.h	/^template <class T> inline T identity_element(plus<T>) { return T(0); }$/;"	f
identity_element	g++/stl_rope.h	/^        friend rope identity_element(concat_fn) { return rope<charT,Alloc>(); }$/;"	f	class:rope
ieee_ar_data	bfd.h	/^      struct ieee_ar_data_struct *ieee_ar_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::ieee_ar_data_struct
ieee_data	bfd.h	/^      struct ieee_data_struct *ieee_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::ieee_data_struct
iend	g++/std/bastring.h	/^	iterator iend () const { return &(*rep ())[length ()]; }$/;"	f	class:basic_string
ifd	bfd.h	/^    int ifd;$/;"	m	struct:_bfd
ifstream	g++/fstream.h	/^    ifstream() : fstreambase() { }$/;"	f	class:ifstream
ifstream	g++/fstream.h	/^    ifstream(const char *name, int mode=ios::in, int prot=0664)$/;"	f	class:ifstream
ifstream	g++/fstream.h	/^    ifstream(int fd) : fstreambase(fd) { }$/;"	f	class:ifstream
ifstream	g++/fstream.h	/^    ifstream(int fd, char *p, int l) : fstreambase(fd, p, l) { } \/*Deprecated*\/$/;"	f	class:ifstream
ifstream	g++/fstream.h	/^class ifstream : public fstreambase, public istream {$/;"	c
ihex_data	bfd.h	/^      struct ihex_data_struct *ihex_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::ihex_data_struct
im	g++/std/complext.h	/^  _FLT re, im;$/;"	m	class:complex
im	g++/std/dcomplex.h	/^  double re, im;$/;"	m	class:complex
im	g++/std/fcomplex.h	/^  float re, im;$/;"	m	class:complex
im	g++/std/ldcomplex.h	/^  long double re, im;$/;"	m	class:complex
imag	g++/std/complext.h	/^  _FLT imag () const { return im; }$/;"	f	class:complex
imag	g++/std/complext.h	/^imag (const complex<_FLT>& x)$/;"	f
imag	g++/std/dcomplex.h	/^  double imag () const { return im; }$/;"	f	class:complex
imag	g++/std/fcomplex.h	/^  float imag () const { return im; }$/;"	f	class:complex
imag	g++/std/ldcomplex.h	/^  long double imag () const { return im; }$/;"	f	class:complex
imanip	g++/iomanip.h	/^template <class TP> class imanip {$/;"	c
in	g++/streambuf.h	/^	in = _IO_INPUT,$/;"	e	enum:ios::open_mode
in_avail	g++/streambuf.h	/^    int in_avail() { return _IO_read_end - _IO_read_ptr; }$/;"	f	struct:streambuf
in_backup	g++/streambuf.h	/^    int in_backup() { return _flags & _IO_IN_BACKUP; }$/;"	f	struct:streambuf
includes	g++/stl_algo.h	/^bool includes(InputIterator1 first1, InputIterator1 last1,$/;"	f
incr	g++/ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::incr(size_t n) {$/;"	f	class:__rope_iterator_base
incr	g++/stl_slist.h	/^	void incr() { node = node->next; }$/;"	f	struct:std::__slist_iterator_base
incr_refcount	g++/stl_rope.h	/^	    void incr_refcount ()$/;"	f	struct:__rope_RopeBase
incr_refcount	g++/stl_rope.h	/^	void incr_refcount () {}$/;"	f	struct:__rope_RopeBase
incr_refcount	g++/stl_rope.h	/^            void incr_refcount ()$/;"	f	struct:__rope_RopeBase
increment	g++/stl_tree.h	/^	void increment(){$/;"	f	struct:__rb_tree_base_iterator
index	bfd.h	/^   int index;$/;"	m	struct:sec
index	g++/stl_rope.h	/^    size_t index() const { return current_pos; }$/;"	f	class:__rope_iterator_base
index1	g++/stl_function.h	/^  size_t index1;$/;"	m	class:subtractive_rng
index2	g++/stl_function.h	/^  size_t index2;$/;"	m	class:subtractive_rng
indexProc	tk.h	/^    Tk_ItemIndexProc *indexProc;	\/* Procedure to determine index of$/;"	m	struct:Tk_ItemType
index_in_buffer	g++/editbuf.h	/^    inline unsigned long index_in_buffer(struct edit_buffer *)$/;"	f	struct:edit_mark
indirect	bfdlink.h	/^	} indirect;$/;"	m	union:bfd_link_order::__anon64	typeref:struct:bfd_link_order::__anon64::__anon65
indirectbuf	g++/indstream.h	/^class indirectbuf : public streambuf {$/;"	c
info	tix.h	/^    char      	      * info;$/;"	m	struct:_Tix_SubCmdInfo
info	tix.h	/^    char      * info;$/;"	m	struct:_Tix_CmdInfo
init	g++/stl_tree.h	/^  void init() {$/;"	f	class:rb_tree
init	g++/streambuf.h	/^inline void ios::init(streambuf* sb, ostream* tie_to) {$/;"	f	class:ios
init_page_size	g++/defalloc.h	/^    size_type init_page_size() $/;"	f	class:allocator
init_refcount_lock	g++/stl_rope.h	/^	    void init_refcount_lock() {$/;"	f	struct:__rope_RopeBase
init_refcount_lock	g++/stl_rope.h	/^	    void init_refcount_lock() {}$/;"	f	struct:__rope_RopeBase
initial_map_size	g++/stl_deque.h	/^	static size_type initial_map_size() { return 8; }$/;"	f	class:std::deque
initialize	g++/stl_bvector.h	/^  void initialize(size_type n) {$/;"	f	class:vector
initialize	g++/stl_function.h	/^  void initialize(unsigned int seed)$/;"	f	class:subtractive_rng
initialize_buckets	g++/stl_hashtable.h	/^  void initialize_buckets(size_type n)$/;"	f	class:hashtable
initialize_buffer	g++/stl_tempbuf.h	/^  void initialize_buffer(const T& val, __false_type) {$/;"	f	class:temporary_buffer
initialize_buffer	g++/stl_tempbuf.h	/^  void initialize_buffer(const T&, __true_type) {}$/;"	f	class:temporary_buffer
initialize_range	g++/stl_bvector.h	/^  void initialize_range(ForwardIterator first, ForwardIterator last,$/;"	f	class:vector
initialize_range	g++/stl_bvector.h	/^  void initialize_range(InputIterator first, InputIterator last,$/;"	f	class:vector
inner_product	g++/stl_numeric.h	/^T inner_product(InputIterator1 first1, InputIterator1 last1,$/;"	f
inplace_merge	g++/stl_algo.h	/^inline void inplace_merge(BidirectionalIterator first,$/;"	f
input	g++/streambuf.h	/^    input = _IO_INPUT,$/;"	e	enum:open_mode
inputProc	tcl.h	/^    Tcl_DriverInputProc *inputProc;	\/* Procedure to call for input$/;"	m	struct:Tcl_ChannelType
input_bfds	bfdlink.h	/^  bfd *input_bfds;$/;"	m	struct:bfd_link_info
input_iterator	g++/stl_iterator.h	/^struct input_iterator {$/;"	s
input_iterator_tag	g++/stl_iterator.h	/^struct input_iterator_tag {};             \/\/read only,only ++$/;"	s
insert	g++/std/bastring.h	/^	basic_string& insert(size_type pos, const charT* s)$/;"	f	class:basic_string
insert	g++/std/bastring.h	/^	basic_string& insert(size_type pos, const charT* s, size_type n)$/;"	f	class:basic_string
insert	g++/std/bastring.h	/^	basic_string& insert(size_type pos, size_type n, charT c)$/;"	f	class:basic_string
insert	g++/std/bastring.h	/^	basic_string& insert(size_type pos1, const basic_string& str, size_type pos2 = 0, size_type n = npos)$/;"	f	class:basic_string
insert	g++/std/bastring.h	/^	iterator insert(iterator p, charT c)$/;"	f	class:basic_string
insert	g++/std/bastring.h	/^	iterator insert(iterator p, size_type n, charT c)$/;"	f	class:basic_string
insert	g++/std/bastring.h	/^	void insert(iterator p, const_iterator first, const_iterator last)$/;"	f	class:basic_string
insert	g++/std/bastring.h	/^    void insert(iterator p, InputIterator first, InputIterator last)$/;"	f	class:basic_string
insert	g++/stl_bvector.h	/^  iterator insert(iterator position, bool x = bool()) {$/;"	f	class:vector
insert	g++/stl_bvector.h	/^  template <class InputIterator> void insert(iterator position,$/;"	f	class:vector
insert	g++/stl_bvector.h	/^  void insert(iterator pos, int n, bool x)  { insert(pos, (size_type)n, x); }$/;"	f	class:vector
insert	g++/stl_bvector.h	/^  void insert(iterator pos, long n, bool x) { insert(pos, (size_type)n, x); }$/;"	f	class:vector
insert	g++/stl_bvector.h	/^  void insert(iterator position, const bool* first, const bool* last) {$/;"	f	class:vector
insert	g++/stl_bvector.h	/^  void insert(iterator position, const_iterator first, $/;"	f	class:vector
insert	g++/stl_bvector.h	/^  void insert(iterator position, size_type n, bool x) {$/;"	f	class:vector
insert	g++/stl_deque.h	/^	iterator insert(iterator position) { return insert(position, value_type()); }$/;"	f	class:std::deque
insert	g++/stl_deque.h	/^	iterator insert(iterator position, const value_type& x) {$/;"	f	class:std::deque
insert	g++/stl_deque.h	/^	void insert(iterator pos, InputIterator first, InputIterator last) $/;"	f	class:std::deque
insert	g++/stl_deque.h	/^	void insert(iterator pos, int n, const value_type& x) $/;"	f	class:std::deque
insert	g++/stl_deque.h	/^	void insert(iterator pos, long n, const value_type& x) $/;"	f	class:std::deque
insert	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::insert(iterator pos, size_type n, const value_type& x) $/;"	f	class:std::deque
insert	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::insert(iterator pos,$/;"	f	class:std::deque
insert	g++/stl_hash_map.h	/^  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }$/;"	f	class:hash_multimap
insert	g++/stl_hash_map.h	/^  pair<iterator, bool> insert(const value_type& obj)$/;"	f	class:hash_map
insert	g++/stl_hash_map.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }$/;"	f	class:hash_multimap
insert	g++/stl_hash_map.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }$/;"	f	class:hash_map
insert	g++/stl_hash_map.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_map
insert	g++/stl_hash_map.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_multimap
insert	g++/stl_hash_map.h	/^  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }$/;"	f	class:hash_multimap
insert	g++/stl_hash_map.h	/^  void insert(const_iterator f, const_iterator l) { rep.insert_unique(f, l); }$/;"	f	class:hash_map
insert	g++/stl_hash_set.h	/^  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }$/;"	f	class:hash_multiset
insert	g++/stl_hash_set.h	/^  pair<iterator, bool> insert(const value_type& obj)$/;"	f	class:hash_set
insert	g++/stl_hash_set.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }$/;"	f	class:hash_multiset
insert	g++/stl_hash_set.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }$/;"	f	class:hash_set
insert	g++/stl_hash_set.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_multiset
insert	g++/stl_hash_set.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_set
insert	g++/stl_hash_set.h	/^  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }$/;"	f	class:hash_multiset
insert	g++/stl_hash_set.h	/^  void insert(const_iterator f, const_iterator l) {rep.insert_unique(f, l); }$/;"	f	class:hash_set
insert	g++/stl_list.h	/^	iterator insert(iterator position) {return insert(position, T()); }$/;"	f	class:std::list
insert	g++/stl_list.h	/^	iterator insert(iterator position, const T& x) {  \/**\/$/;"	f	class:std::list
insert	g++/stl_list.h	/^	void insert(iterator pos, int n, const T& x) {insert(pos, (size_type)n, x);}$/;"	f	class:std::list
insert	g++/stl_list.h	/^	void insert(iterator pos, long n, const T& x) {insert(pos, (size_type)n, x);}$/;"	f	class:std::list
insert	g++/stl_list.h	/^void list<T, Alloc>::insert(iterator position, InputIterator first, InputIterator last) {$/;"	f	class:std::list
insert	g++/stl_list.h	/^void list<T, Alloc>::insert(iterator position, size_type n, const T& x) {$/;"	f	class:std::list
insert	g++/stl_map.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:map
insert	g++/stl_map.h	/^  pair<iterator,bool> insert(const value_type& x) { return t.insert_unique(x); }$/;"	f	class:map
insert	g++/stl_map.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:map
insert	g++/stl_map.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:map
insert	g++/stl_map.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:map
insert	g++/stl_multimap.h	/^  iterator insert(const value_type& x) { return t.insert_equal(x); }$/;"	f	class:multimap
insert	g++/stl_multimap.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:multimap
insert	g++/stl_multimap.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:multimap
insert	g++/stl_multimap.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:multimap
insert	g++/stl_multimap.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:multimap
insert	g++/stl_multiset.h	/^  iterator insert(const value_type& x) { $/;"	f	class:multiset
insert	g++/stl_multiset.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:multiset
insert	g++/stl_multiset.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:multiset
insert	g++/stl_multiset.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:multiset
insert	g++/stl_multiset.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:multiset
insert	g++/stl_rope.h	/^	iterator insert(const iterator& p ) $/;"	f	class:rope
insert	g++/stl_rope.h	/^	iterator insert(const iterator& p, charT c) $/;"	f	class:rope
insert	g++/stl_rope.h	/^	iterator insert(const iterator& p, const charT *c_string) $/;"	f	class:rope
insert	g++/stl_rope.h	/^	iterator insert(const iterator& p, const charT *i, const charT *j)$/;"	f	class:rope
insert	g++/stl_rope.h	/^	iterator insert(const iterator& p, const charT *i, size_t n)$/;"	f	class:rope
insert	g++/stl_rope.h	/^	iterator insert(const iterator& p, const rope& r)$/;"	f	class:rope
insert	g++/stl_rope.h	/^	iterator insert(const iterator& p, size_t n, charT c)$/;"	f	class:rope
insert	g++/stl_rope.h	/^	iterator insert(const iterator& p,$/;"	f	class:rope
insert	g++/stl_rope.h	/^	void insert(size_t p) {$/;"	f	class:rope
insert	g++/stl_rope.h	/^	void insert(size_t p, charT c) {$/;"	f	class:rope
insert	g++/stl_rope.h	/^	void insert(size_t p, const charT * c_string) {$/;"	f	class:rope
insert	g++/stl_rope.h	/^	void insert(size_t p, const charT * i, size_t n) {$/;"	f	class:rope
insert	g++/stl_rope.h	/^	void insert(size_t p, const charT *i, const charT *j) {$/;"	f	class:rope
insert	g++/stl_rope.h	/^	void insert(size_t p, const const_iterator& i,$/;"	f	class:rope
insert	g++/stl_rope.h	/^	void insert(size_t p, const iterator& i,$/;"	f	class:rope
insert	g++/stl_rope.h	/^	void insert(size_t p, const rope& r) {$/;"	f	class:rope
insert	g++/stl_rope.h	/^	void insert(size_t p, size_t n, charT c) {$/;"	f	class:rope
insert	g++/stl_set.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:set
insert	g++/stl_set.h	/^  pair<iterator,bool> insert(const value_type& x) { $/;"	f	class:set
insert	g++/stl_set.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:set
insert	g++/stl_set.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:set
insert	g++/stl_set.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:set
insert	g++/stl_slist.h	/^	iterator insert(iterator pos) {$/;"	f	class:std::slist
insert	g++/stl_slist.h	/^	iterator insert(iterator pos, const value_type& x) {$/;"	f	class:std::slist
insert	g++/stl_slist.h	/^	void insert(iterator pos, InIter first, InIter last) {$/;"	f	class:std::slist
insert	g++/stl_slist.h	/^	void insert(iterator pos, int n, const value_type& x) {$/;"	f	class:std::slist
insert	g++/stl_slist.h	/^	void insert(iterator pos, long n, const value_type& x) {$/;"	f	class:std::slist
insert	g++/stl_slist.h	/^	void insert(iterator pos, size_type n, const value_type& x) {$/;"	f	class:std::slist
insert	g++/stl_vector.h	/^	iterator insert(iterator position) { return insert(position, T()); }$/;"	f	class:vector
insert	g++/stl_vector.h	/^	iterator insert(iterator position, const T& x) $/;"	f	class:vector
insert	g++/stl_vector.h	/^	void insert (iterator pos, int n, const T& x) { insert(pos, (size_type) n, x);}$/;"	f	class:vector
insert	g++/stl_vector.h	/^	void insert (iterator pos, long n, const T& x) { insert(pos, (size_type) n, x);}$/;"	f	class:vector
insert	g++/stl_vector.h	/^	void insert(iterator position, InputIterator first, InputIterator last) $/;"	f	class:vector
insert	g++/stl_vector.h	/^void vector<T, Alloc>::insert(iterator position, size_type n, const T& x) $/;"	f	class:vector
insertBorder	tk.h	/^    Tk_3DBorder insertBorder;	\/* Used to draw vertical bar for insertion$/;"	m	struct:Tk_CanvasTextInfo
insertBorderWidth	tk.h	/^    int insertBorderWidth;	\/* Width of 3-D border around insert cursor.$/;"	m	struct:Tk_CanvasTextInfo
insertProc	tk.h	/^    Tk_ItemInsertProc *insertProc;	\/* Procedure to insert something into$/;"	m	struct:Tk_ItemType
insertWidth	tk.h	/^    int insertWidth;		\/* Total width of insertion cursor.  Read-only$/;"	m	struct:Tk_CanvasTextInfo
insert_after	g++/stl_slist.h	/^	iterator insert_after(iterator pos) {$/;"	f	class:std::slist
insert_after	g++/stl_slist.h	/^	iterator insert_after(iterator pos, const value_type& x) {$/;"	f	class:std::slist
insert_after	g++/stl_slist.h	/^	void insert_after(iterator pos, InIter first, InIter last) {$/;"	f	class:std::slist
insert_after	g++/stl_slist.h	/^	void insert_after(iterator pos, int n, const value_type& x) {$/;"	f	class:std::slist
insert_after	g++/stl_slist.h	/^	void insert_after(iterator pos, long n, const value_type& x) {$/;"	f	class:std::slist
insert_after	g++/stl_slist.h	/^	void insert_after(iterator pos, size_type n, const value_type& x) {$/;"	f	class:std::slist
insert_aux	g++/stl_bvector.h	/^  void insert_aux(iterator position, bool x) {$/;"	f	class:vector
insert_aux	g++/stl_deque.h	/^deque<T, Alloc, BufSize>::insert_aux(iterator pos, const value_type& x) $/;"	f	class:std::deque
insert_aux	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::insert_aux(iterator pos, const_iterator first, const_iterator last, size_type n)$/;"	f	class:std::deque
insert_aux	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::insert_aux(iterator pos, size_type n, const value_type& x) $/;"	f	class:std::deque
insert_aux	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::insert_aux(iterator pos,$/;"	f	class:std::deque
insert_aux	g++/stl_vector.h	/^void vector<T, Alloc>::insert_aux(iterator position, const T& x) $/;"	f	class:vector
insert_before	g++/editbuf.h	/^    inline int insert_before() { return _pos & 1; }$/;"	f	struct:edit_mark
insert_equal	g++/stl_hashtable.h	/^  iterator insert_equal(const value_type& obj)$/;"	f	class:hashtable
insert_equal	g++/stl_hashtable.h	/^  void insert_equal(ForwardIterator f, ForwardIterator l,$/;"	f	class:hashtable
insert_equal	g++/stl_hashtable.h	/^  void insert_equal(InputIterator f, InputIterator l)$/;"	f	class:hashtable
insert_equal	g++/stl_hashtable.h	/^  void insert_equal(InputIterator f, InputIterator l,$/;"	f	class:hashtable
insert_equal	g++/stl_hashtable.h	/^  void insert_equal(const value_type* f, const value_type* l)$/;"	f	class:hashtable
insert_equal	g++/stl_hashtable.h	/^  void insert_equal(const_iterator f, const_iterator l)$/;"	f	class:hashtable
insert_equal	g++/stl_tree.h	/^rb_tree<K, V, KoV, Cmp, Al>::insert_equal(const V* first, const V* last) {$/;"	f	class:rb_tree
insert_equal	g++/stl_tree.h	/^rb_tree<K, V, KoV, Cmp, Al>::insert_equal(const_iterator first,$/;"	f	class:rb_tree
insert_equal	g++/stl_tree.h	/^rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::insert_equal(iterator position,$/;"	f	class:rb_tree
insert_equal	g++/stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_equal(const Value& v)$/;"	f	class:rb_tree
insert_equal	g++/stl_tree.h	/^void rb_tree<K, V, KoV, Cmp, Al>::insert_equal(II first, II last) {$/;"	f	class:rb_tree
insert_equal_noresize	g++/stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::insert_equal_noresize(const value_type& obj)$/;"	f	class:hashtable
insert_iterator	g++/stl_iterator.h	/^  insert_iterator(Container& x, typename Container::iterator i) $/;"	f	class:insert_iterator
insert_iterator	g++/stl_iterator.h	/^class insert_iterator {$/;"	c
insert_noresize	g++/stl_hash_map.h	/^  iterator insert_noresize(const value_type& obj)$/;"	f	class:hash_multimap
insert_noresize	g++/stl_hash_map.h	/^  pair<iterator, bool> insert_noresize(const value_type& obj)$/;"	f	class:hash_map
insert_noresize	g++/stl_hash_set.h	/^  iterator insert_noresize(const value_type& obj)$/;"	f	class:hash_multiset
insert_noresize	g++/stl_hash_set.h	/^  pair<iterator, bool> insert_noresize(const value_type& obj)$/;"	f	class:hash_set
insert_ostream	g++/ropeimpl.h	/^	typedef ostream insert_ostream;$/;"	t	class:__rope_insert_char_consumer
insert_range	g++/stl_bvector.h	/^  void insert_range(iterator pos,$/;"	f	class:vector
insert_range	g++/stl_bvector.h	/^  void insert_range(iterator position,$/;"	f	class:vector
insert_unique	g++/stl_hashtable.h	/^  pair<iterator, bool> insert_unique(const value_type& obj)$/;"	f	class:hashtable
insert_unique	g++/stl_hashtable.h	/^  void insert_unique(ForwardIterator f, ForwardIterator l,$/;"	f	class:hashtable
insert_unique	g++/stl_hashtable.h	/^  void insert_unique(InputIterator f, InputIterator l)$/;"	f	class:hashtable
insert_unique	g++/stl_hashtable.h	/^  void insert_unique(InputIterator f, InputIterator l,$/;"	f	class:hashtable
insert_unique	g++/stl_hashtable.h	/^  void insert_unique(const value_type* f, const value_type* l)$/;"	f	class:hashtable
insert_unique	g++/stl_hashtable.h	/^  void insert_unique(const_iterator f, const_iterator l)$/;"	f	class:hashtable
insert_unique	g++/stl_tree.h	/^rb_tree<K, V, KoV, Cmp, A>::insert_unique(const V* first, const V* last) {$/;"	f	class:rb_tree
insert_unique	g++/stl_tree.h	/^rb_tree<K, V, KoV, Cmp, A>::insert_unique(const_iterator first,$/;"	f	class:rb_tree
insert_unique	g++/stl_tree.h	/^rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::insert_unique(iterator position,$/;"	f	class:rb_tree
insert_unique	g++/stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_unique(const Value& v)$/;"	f	class:rb_tree
insert_unique	g++/stl_tree.h	/^void rb_tree<K, V, KoV, Cmp, Al>::insert_unique(II first, II last) {$/;"	f	class:rb_tree
insert_unique_noresize	g++/stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::insert_unique_noresize(const value_type& obj)$/;"	f	class:hashtable
inserter	g++/stl_iterator.h	/^inline insert_iterator<Container> inserter(Container& x, Iterator i) {$/;"	f
inserting	g++/editbuf.h	/^    int inserting() { return _inserting; }$/;"	f	struct:edit_streambuf
inserting	g++/editbuf.h	/^    void inserting(int i) { _inserting = i; }$/;"	f	struct:edit_streambuf
intValue	tcl.h	/^    long intValue;		\/* Integer value. *\/$/;"	m	struct:Tcl_Value
internal	g++/streambuf.h	/^	   left=_IO_LEFT, right=_IO_RIGHT, internal=_IO_INTERNAL,$/;"	e	enum:ios::__anon1
internal	g++/streambuf.h	/^	   left=_IO_LEFT, right=_IO_RIGHT, internal=_IO_INTERNAL,$/;"	e	enum:ios::__anon72
internalBorderWidth	tk.h	/^    int internalBorderWidth;$/;"	m	struct:Tk_FakeWin
internalRep	tcl.h	/^    } internalRep;$/;"	m	struct:Tcl_Obj	typeref:union:Tcl_Obj::__anon54
io_functions	g++/libio.h	/^  _IO_cookie_io_functions_t io_functions;$/;"	m	struct:_IO_cookie_file
io_state	g++/streambuf.h	/^    enum io_state {$/;"	g	class:ios
ios	g++/streambuf.h	/^class ios : public _ios_fields {$/;"	c
ios	g++/streambuf.h	/^inline ios::ios(streambuf* sb, ostream* tie_to) { init(sb, tie_to); }$/;"	f	class:ios
iostate	g++/streambuf.h	/^    typedef int iostate;$/;"	t	class:ios
iostream	bfd.h	/^    PTR iostream;$/;"	m	struct:_bfd
iostream	g++/iostream.h	/^    iostream() { }$/;"	f	class:iostream
iostream	g++/iostream.h	/^class iostream : public istream, public ostream$/;"	c
iota	g++/stl_numeric.h	/^void iota(ForwardIterator first, ForwardIterator last, T value) {$/;"	f
ipfstream	g++/pfstream.h	/^class ipfstream : public ifstream {$/;"	c
ipfx	g++/iostream.h	/^    int ipfx(int need = 0) {$/;"	f	class:istream
ipfx0	g++/iostream.h	/^    int ipfx0() { \/\/ Optimized version of ipfx(0).$/;"	f	class:istream
ipfx1	g++/iostream.h	/^    int ipfx1() { \/\/ Optimized version of ipfx(1).$/;"	f	class:istream
is0	g++/stl_rope.h	/^	static bool is0(charT c) { return c == __eos((charT *)0); }$/;"	f	class:rope
isNativeObjectProc	tcl.h	/^    int isNativeObjectProc;	 \/* 1 if objProc was registered by a call to$/;"	m	struct:Tcl_CmdInfo
is_POD_type	g++/type_traits.h	/^	typedef __false_type    is_POD_type;$/;"	t	struct:__type_traits
is_POD_type	g++/type_traits.h	/^	typedef __true_type    is_POD_type;$/;"	t	struct:__type_traits
is_POD_type	g++/type_traits.h	/^   typedef __true_type    is_POD_type;$/;"	t	struct:__type_traits
is_almost_balanced	g++/stl_rope.h	/^	static bool is_almost_balanced(RopeBase *r)$/;"	f	class:rope
is_balanced	g++/stl_rope.h	/^	static bool is_balanced(RopeBase *r)$/;"	f	class:rope
is_balanced	g++/stl_rope.h	/^    bool is_balanced:8;$/;"	m	struct:__rope_RopeBase
is_del	g++/std/straits.h	/^	static bool is_del(char_type a) { return 0; }$/;"	f	struct:string_char_traits
is_del	g++/std/straits.h	/^  static bool is_del(char_type a) { return isspace(a); }$/;"	f	struct:string_char_traits
is_heap	g++/stl_algo.h	/^inline bool is_heap(RandomAccessIterator first, RandomAccessIterator last)$/;"	f
is_heap	g++/stl_algo.h	/^inline bool is_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
is_open	g++/fstream.h	/^    int is_open() const { return rdbuf()->is_open(); }$/;"	f	class:fstreambase
is_open	g++/streambuf.h	/^    int is_open() const { return _fileno >= 0; }$/;"	f	class:filebuf
is_reading	g++/editbuf.h	/^    int is_reading() { return gptr() != NULL; }$/;"	f	struct:edit_streambuf
is_reading	g++/streambuf.h	/^    int is_reading() { return eback() != egptr(); }$/;"	f	class:filebuf
is_roughly_balanced	g++/stl_rope.h	/^	static bool is_roughly_balanced(RopeBase *r)$/;"	f	class:rope
is_sorted	g++/stl_algo.h	/^bool is_sorted(ForwardIterator first, ForwardIterator last)$/;"	f
is_sorted	g++/stl_algo.h	/^bool is_sorted(ForwardIterator first, ForwardIterator last,$/;"	f
isfx	g++/iostream.h	/^    void isfx() { _IO_funlockfile(_strbuf); }$/;"	f	class:istream
istdiostream	g++/stdiostream.h	/^  istdiostream (FILE* __f) : istream(), _file(__f) { init(&_file); }$/;"	f	class:istdiostream
istdiostream	g++/stdiostream.h	/^class istdiostream : public istream$/;"	c
istream	g++/iostream.h	/^    istream(): _gcount (0) { }$/;"	f	class:istream
istream	g++/iostream.h	/^class istream : virtual public ios$/;"	c
istream_iterator	g++/stl_iterator.h	/^  istream_iterator() : stream(&cin), end_marker(false) {}$/;"	f	class:istream_iterator
istream_iterator	g++/stl_iterator.h	/^  istream_iterator(istream& s) : stream(&s) { read(); }$/;"	f	class:istream_iterator
istream_iterator	g++/stl_iterator.h	/^class istream_iterator {$/;"	c
istreambuf	g++/iostream.h	/^    streambuf* istreambuf() const { return _strbuf; }$/;"	f	class:istream
istrstream	g++/strstream.h	/^class istrstream : public strstreambase, public istream {$/;"	c
itemSize	tk.h	/^    int itemSize;			\/* Total amount of space needed for$/;"	m	struct:Tk_ItemType
iter	g++/stl_iterator.h	/^  typename Container::iterator iter;$/;"	m	class:insert_iterator
iter	g++/stl_raw_storage_iter.h	/^  ForwardIterator iter;$/;"	m	class:raw_storage_iterator
iter_swap	g++/stl_algobase.h	/^iter_swap(ForwardIterator1 a, ForwardIterator2 b) {$/;"	f
iterator	g++/std/bastring.h	/^	typedef pointer 								iterator;$/;"	t	class:basic_string
iterator	g++/stl_bvector.h	/^  typedef __bit_iterator                iterator;$/;"	t	class:vector
iterator	g++/stl_bvector.h	/^  typedef __bit_iterator iterator;$/;"	t	struct:__bit_iterator
iterator	g++/stl_deque.h	/^	typedef __deque_iterator<T, T&, T*, BufSiz>             	iterator;$/;"	t	struct:std::__deque_iterator
iterator	g++/stl_deque.h	/^	typedef __deque_iterator<T, T&, T*, BufSiz>              iterator;$/;"	t	class:std::deque
iterator	g++/stl_hash_map.h	/^  typedef typename ht::iterator iterator;$/;"	t	class:hash_map
iterator	g++/stl_hash_map.h	/^  typedef typename ht::iterator iterator;$/;"	t	class:hash_multimap
iterator	g++/stl_hash_set.h	/^  typedef typename ht::const_iterator iterator;$/;"	t	class:hash_multiset
iterator	g++/stl_hash_set.h	/^  typedef typename ht::const_iterator iterator;$/;"	t	class:hash_set
iterator	g++/stl_hashtable.h	/^          iterator;$/;"	t	struct:__hashtable_const_iterator
iterator	g++/stl_hashtable.h	/^          iterator;$/;"	t	struct:__hashtable_iterator
iterator	g++/stl_hashtable.h	/^  iterator;$/;"	t	class:hashtable
iterator	g++/stl_iterator.h	/^struct iterator {$/;"	s
iterator	g++/stl_list.h	/^	typedef __list_iterator<T, T&, T*>             	iterator;$/;"	t	class:std::list
iterator	g++/stl_list.h	/^	typedef __list_iterator<T, T&, T*>             iterator;$/;"	t	struct:std::__list_iterator
iterator	g++/stl_map.h	/^  typedef typename rep_type::iterator iterator;$/;"	t	class:map
iterator	g++/stl_multimap.h	/^  typedef typename rep_type::iterator iterator;$/;"	t	class:multimap
iterator	g++/stl_multiset.h	/^  typedef typename rep_type::const_iterator iterator;$/;"	t	class:multiset
iterator	g++/stl_rope.h	/^	typedef __rope_iterator<charT,Alloc> iterator;$/;"	t	class:rope
iterator	g++/stl_set.h	/^  typedef typename rep_type::const_iterator iterator;$/;"	t	class:set
iterator	g++/stl_slist.h	/^	typedef __slist_iterator<T, T&, T*>             iterator;$/;"	t	class:std::slist
iterator	g++/stl_slist.h	/^	typedef __slist_iterator<T, T&, T*>             iterator;$/;"	t	struct:std::__slist_iterator
iterator	g++/stl_tree.h	/^	typedef __rb_tree_iterator<Value, Value&, Value*>             	iterator;$/;"	t	struct:__rb_tree_iterator
iterator	g++/stl_tree.h	/^  typedef __rb_tree_iterator<value_type, reference, pointer> iterator;$/;"	t	class:rb_tree
iterator	g++/stl_vector.h	/^	typedef value_type*       					iterator;$/;"	t	class:vector
iterator_base	g++/stl_slist.h	/^	typedef __slist_iterator_base 					iterator_base;$/;"	t	class:std::slist
iterator_buf_len	g++/stl_rope.h	/^    enum { iterator_buf_len = 15 };$/;"	e	enum:__rope_iterator_base::__anon12
iterator_buf_len	g++/stl_rope.h	/^    enum { iterator_buf_len = 15 };$/;"	e	enum:__rope_iterator_base::__anon83
iterator_category	g++/stl_deque.h	/^	typedef random_access_iterator_tag 							iterator_category;$/;"	t	struct:std::__deque_iterator
iterator_category	g++/stl_deque.h	/^iterator_category(const __deque_iterator<T, Ref, Ptr, BufSiz>&) $/;"	f	namespace:std
iterator_category	g++/stl_hashtable.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:__hashtable_const_iterator
iterator_category	g++/stl_hashtable.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:__hashtable_iterator
iterator_category	g++/stl_hashtable.h	/^iterator_category(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
iterator_category	g++/stl_hashtable.h	/^iterator_category(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
iterator_category	g++/stl_iterator.h	/^          iterator_category;$/;"	t	class:reverse_iterator
iterator_category	g++/stl_iterator.h	/^  typedef Category  iterator_category;$/;"	t	struct:iterator
iterator_category	g++/stl_iterator.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	class:reverse_bidirectional_iterator
iterator_category	g++/stl_iterator.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	struct:bidirectional_iterator
iterator_category	g++/stl_iterator.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:forward_iterator
iterator_category	g++/stl_iterator.h	/^  typedef input_iterator_tag iterator_category;$/;"	t	class:istream_iterator
iterator_category	g++/stl_iterator.h	/^  typedef input_iterator_tag iterator_category;$/;"	t	struct:input_iterator
iterator_category	g++/stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:back_insert_iterator
iterator_category	g++/stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:front_insert_iterator
iterator_category	g++/stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:insert_iterator
iterator_category	g++/stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:ostream_iterator
iterator_category	g++/stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	struct:output_iterator
iterator_category	g++/stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category;   $/;"	t	struct:iterator_traits
iterator_category	g++/stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category; \/\/random_access_iterator$/;"	t	struct:iterator_traits
iterator_category	g++/stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	class:reverse_iterator
iterator_category	g++/stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	struct:random_access_iterator
iterator_category	g++/stl_iterator.h	/^  typedef typename Iterator::iterator_category iterator_category;$/;"	t	struct:iterator_traits
iterator_category	g++/stl_iterator.h	/^inline output_iterator_tag iterator_category(const output_iterator&) {$/;"	f
iterator_category	g++/stl_iterator.h	/^inline random_access_iterator_tag iterator_category(const T*) {$/;"	f
iterator_category	g++/stl_iterator.h	/^iterator_category(const Iterator&) {$/;"	f
iterator_category	g++/stl_iterator.h	/^iterator_category(const back_insert_iterator<Container>&)$/;"	f
iterator_category	g++/stl_iterator.h	/^iterator_category(const bidirectional_iterator<T, Distance>&) {$/;"	f
iterator_category	g++/stl_iterator.h	/^iterator_category(const forward_iterator<T, Distance>&) {$/;"	f
iterator_category	g++/stl_iterator.h	/^iterator_category(const front_insert_iterator<Container>&)$/;"	f
iterator_category	g++/stl_iterator.h	/^iterator_category(const input_iterator<T, Distance>&) {$/;"	f
iterator_category	g++/stl_iterator.h	/^iterator_category(const insert_iterator<Container>&)$/;"	f
iterator_category	g++/stl_iterator.h	/^iterator_category(const istream_iterator<T, Distance>&) {$/;"	f
iterator_category	g++/stl_iterator.h	/^iterator_category(const ostream_iterator<T>&) {$/;"	f
iterator_category	g++/stl_iterator.h	/^iterator_category(const random_access_iterator<T, Distance>&) {$/;"	f
iterator_category	g++/stl_iterator.h	/^iterator_category(const reverse_bidirectional_iterator<BidirectionalIterator,$/;"	f
iterator_category	g++/stl_iterator.h	/^iterator_category(const reverse_iterator<RandomAccessIterator, T,$/;"	f
iterator_category	g++/stl_list.h	/^	typedef bidirectional_iterator_tag iterator_category;$/;"	t	struct:std::__list_iterator
iterator_category	g++/stl_list.h	/^iterator_category(const __list_iterator<T, Ref, Ptr>&) {$/;"	f	namespace:std
iterator_category	g++/stl_raw_storage_iter.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:raw_storage_iterator
iterator_category	g++/stl_raw_storage_iter.h	/^iterator_category(const raw_storage_iterator<ForwardIterator, T>&)$/;"	f
iterator_category	g++/stl_slist.h	/^	typedef forward_iterator_tag 	iterator_category;$/;"	t	struct:std::__slist_iterator_base
iterator_category	g++/stl_slist.h	/^iterator_category(const __slist_iterator_base&){$/;"	f	namespace:std
iterator_category	g++/stl_tree.h	/^	typedef bidirectional_iterator_tag 	iterator_category;$/;"	t	struct:__rb_tree_base_iterator
iterator_category	g++/stl_tree.h	/^iterator_category(const __rb_tree_base_iterator&) {$/;"	f
iterator_traits	g++/stl_iterator.h	/^struct iterator_traits {$/;"	s
iterator_traits	g++/stl_iterator.h	/^struct iterator_traits<T*> {$/;"	s
iterator_traits	g++/stl_iterator.h	/^struct iterator_traits<const T*> {$/;"	s
iterator_type	g++/stl_iterator.h	/^  typedef Iterator iterator_type;$/;"	t	class:reverse_iterator
keep_hash	bfdlink.h	/^  struct bfd_hash_table *keep_hash;$/;"	m	struct:bfd_link_info	typeref:struct:bfd_link_info::bfd_hash_table
keep_memory	bfdlink.h	/^  boolean keep_memory;$/;"	m	struct:bfd_link_info
key	g++/stl_tree.h	/^  static const Key& key(base_ptr x) { return KeyOfValue()(value(link_type(x)));} $/;"	f	class:rb_tree
key	g++/stl_tree.h	/^  static const Key& key(link_type x) { return KeyOfValue()(value(x)); }$/;"	f	class:rb_tree
key	tcl.h	/^    } key;				\/* MUST BE LAST FIELD IN RECORD!! *\/$/;"	m	struct:Tcl_HashEntry	typeref:union:Tcl_HashEntry::__anon56
key	tk.h	/^    char *key;		\/* The key string that flags the option in the$/;"	m	struct:__anon30
keyType	tcl.h	/^    int keyType;			\/* Type of keys used in this table. $/;"	m	struct:Tcl_HashTable
key_comp	g++/stl_map.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:map
key_comp	g++/stl_multimap.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:multimap
key_comp	g++/stl_multiset.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:multiset
key_comp	g++/stl_set.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:set
key_comp	g++/stl_tree.h	/^  Compare key_comp() const { return key_compare; }$/;"	f	class:rb_tree
key_compare	g++/stl_map.h	/^  typedef Compare key_compare;$/;"	t	class:map
key_compare	g++/stl_multimap.h	/^  typedef Compare key_compare;$/;"	t	class:multimap
key_compare	g++/stl_multiset.h	/^  typedef Compare key_compare;$/;"	t	class:multiset
key_compare	g++/stl_set.h	/^  typedef Compare key_compare;$/;"	t	class:set
key_compare	g++/stl_tree.h	/^  Compare key_compare;$/;"	m	class:rb_tree
key_eq	g++/stl_hash_map.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_map
key_eq	g++/stl_hash_map.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_multimap
key_eq	g++/stl_hash_set.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_multiset
key_eq	g++/stl_hash_set.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_set
key_eq	g++/stl_hashtable.h	/^  key_equal key_eq() const { return equals; }$/;"	f	class:hashtable
key_equal	g++/stl_hash_map.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_map
key_equal	g++/stl_hash_map.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_multimap
key_equal	g++/stl_hash_set.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_multiset
key_equal	g++/stl_hash_set.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_set
key_equal	g++/stl_hashtable.h	/^  typedef EqualKey key_equal;$/;"	t	class:hashtable
key_type	g++/stl_hash_map.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_map
key_type	g++/stl_hash_map.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_multimap
key_type	g++/stl_hash_set.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_multiset
key_type	g++/stl_hash_set.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_set
key_type	g++/stl_hashtable.h	/^  typedef Key key_type;$/;"	t	class:hashtable
key_type	g++/stl_map.h	/^  typedef Key key_type;$/;"	t	class:map
key_type	g++/stl_multimap.h	/^  typedef Key key_type;$/;"	t	class:multimap
key_type	g++/stl_multiset.h	/^  typedef Key key_type;$/;"	t	class:multiset
key_type	g++/stl_set.h	/^  typedef Key key_type;$/;"	t	class:set
key_type	g++/stl_tree.h	/^  typedef Key key_type;$/;"	t	class:rb_tree
largest_char	readline/chardefs.h	25;"	d
last	g++/stl_deque.h	/^	T* last;			\/\/$/;"	m	struct:std::__deque_iterator
last	tix.h	/^    char * last;$/;"	m	struct:Tix_ListIterator
leaf	g++/stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon80
leaf	g++/stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon9
leaf_concat_char_iter	g++/ropeimpl.h	/^rope<charT,Alloc>::leaf_concat_char_iter$/;"	f	class:rope
leaf_index	g++/stl_rope.h	/^    int leaf_index;     \/\/ Last valid pos in path_end;$/;"	m	class:__rope_iterator_base
leaf_pos	g++/stl_rope.h	/^    size_t leaf_pos;    \/\/ Starting position for current leaf$/;"	m	class:__rope_iterator_base
left	g++/parsestream.h	/^    char *left() const { return base(); }$/;"	f	class:string_parsebuf
left	g++/stl_rope.h	/^    __rope_RopeBase<charT,Alloc>* left;$/;"	m	struct:__rope_RopeConcatenation
left	g++/stl_tree.h	/^	base_ptr 					 left;$/;"	m	struct:__rb_tree_node_base
left	g++/stl_tree.h	/^  static link_type& left(base_ptr x) { return (link_type&)(x->left); }$/;"	f	class:rb_tree
left	g++/stl_tree.h	/^  static link_type& left(link_type x) { return (link_type&)(x->left); }$/;"	f	class:rb_tree
left	g++/streambuf.h	/^	   left=_IO_LEFT, right=_IO_RIGHT, internal=_IO_INTERNAL,$/;"	e	enum:ios::__anon1
left	g++/streambuf.h	/^	   left=_IO_LEFT, right=_IO_RIGHT, internal=_IO_INTERNAL,$/;"	e	enum:ios::__anon72
leftmost	g++/stl_tree.h	/^  link_type& leftmost() const { return (link_type&) header->left; }$/;"	f	class:rb_tree
len	g++/std/bastring.h	/^		size_t len, res, ref; \/\/ len res$/;"	m	struct:basic_string::Rep
len	g++/stl_tempbuf.h	/^  ptrdiff_t len;$/;"	m	class:temporary_buffer
length	g++/std/bastring.h	/^	size_type length() const{ return rep()->len; }$/;"	f	class:basic_string
length	g++/std/straits.h	/^	static size_t length(const char_type* s)$/;"	f	struct:string_char_traits
length	g++/std/straits.h	/^  static size_t length (const char_type* s)$/;"	f	struct:string_char_traits
length	g++/stl_rope.h	/^	size_type length() const {$/;"	f	class:rope
length	tcl.h	/^    int length;			\/* Number of non-NULL characters in the$/;"	m	struct:Tcl_DString
length	tcl.h	/^    int length;			\/* The number of bytes at *bytes, not$/;"	m	struct:Tcl_Obj
less	g++/stl_function.h	/^struct less : public binary_function<T, T, bool> {$/;"	s
less_equal	g++/stl_function.h	/^struct less_equal : public binary_function<T, T, bool> {$/;"	s
lexicographical_compare	g++/stl_algobase.h	/^inline bool lexicographical_compare(const char* first1, const char* last1,const char* first2, const char* last2)$/;"	f
lexicographical_compare	g++/stl_algobase.h	/^lexicographical_compare(InputIterator1 first1, InputIterator1 last1,$/;"	f
lexicographical_compare	g++/stl_algobase.h	/^lexicographical_compare(InputIterator1 first1, InputIterator1 last1,InputIterator2 first2, InputIterator2 last2) $/;"	f
lexicographical_compare	g++/stl_algobase.h	/^lexicographical_compare(const unsigned char* first1,const unsigned char* last1, const unsigned char* first2,$/;"	f
lexicographical_compare_3way	g++/stl_algobase.h	/^inline int lexicographical_compare_3way(const char* first1, const char* last1,$/;"	f
lexicographical_compare_3way	g++/stl_algobase.h	/^lexicographical_compare_3way(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2)$/;"	f
lexicographical_compare_3way	g++/stl_algobase.h	/^lexicographical_compare_3way(const unsigned char* first1,$/;"	f
line_filepos	bfd.h	/^   file_ptr line_filepos;$/;"	m	struct:sec
line_length	g++/parsestream.h	/^    int line_length() { return _line_length; }$/;"	f	class:parsebuf
line_number	bfd.h	/^  unsigned int line_number;	\/* Linenumber from start of function*\/  $/;"	m	struct:lineno_cache_entry
line_number	g++/parsestream.h	/^    int line_number() { return __line_number; }$/;"	f	class:parsebuf
linebuffered	g++/streambuf.h	/^    int linebuffered() { return _flags & _IO_LINE_BUF ? 1 : 0; }$/;"	f	struct:streambuf
linebuffered	g++/streambuf.h	/^    void linebuffered(int i)$/;"	f	struct:streambuf
lineno	FlexLexer.h	/^	int lineno() const		{ return yylineno; }$/;"	f	class:FlexLexer
lineno	bfd.h	/^   alent *lineno;$/;"	m	struct:sec
lineno_cache_entry	bfd.h	/^typedef struct lineno_cache_entry {$/;"	s
lineno_count	bfd.h	/^   unsigned int lineno_count;$/;"	m	struct:sec
linespace	tk.h	/^    int linespace;		\/* The sum of the ascent and descent.  How$/;"	m	struct:Tk_FontMetrics
link	bfdlink.h	/^	  struct bfd_link_hash_entry *link;	\/* Real symbol.  *\/$/;"	m	struct:bfd_link_hash_entry::__anon59::__anon62	typeref:struct:bfd_link_hash_entry::__anon59::__anon62::bfd_link_hash_entry
link_next	bfd.h	/^    struct _bfd *link_next;$/;"	m	struct:_bfd	typeref:struct:_bfd::_bfd
link_order_head	bfd.h	/^   struct bfd_link_order *link_order_head;$/;"	m	struct:sec	typeref:struct:sec::bfd_link_order
link_order_tail	bfd.h	/^   struct bfd_link_order *link_order_tail;$/;"	m	struct:sec	typeref:struct:sec::bfd_link_order
link_type	g++/stl_list.h	/^	typedef __list_node<T>* link_type;$/;"	t	struct:std::__list_iterator
link_type	g++/stl_list.h	/^	typedef list_node* 								link_type;$/;"	t	class:std::list
link_type	g++/stl_tree.h	/^	typedef __rb_tree_node<Value>* 									link_type;$/;"	t	struct:__rb_tree_iterator
link_type	g++/stl_tree.h	/^	typedef __rb_tree_node<Value>* link_type;$/;"	t	struct:__rb_tree_node
link_type	g++/stl_tree.h	/^  typedef rb_tree_node* link_type;$/;"	t	class:rb_tree
linker_mark	bfd.h	/^       unsigned int linker_mark : 1;$/;"	m	struct:sec
list	g++/stl_list.h	/^	explicit list(size_type n){ fill_initialize(n, T()); }$/;"	f	class:std::list
list	g++/stl_list.h	/^	list() { 									\/\/$/;"	f	class:std::list
list	g++/stl_list.h	/^	list(InputIterator first, InputIterator last){$/;"	f	class:std::list
list	g++/stl_list.h	/^	list(const list<T, Alloc>& x) {$/;"	f	class:std::list
list	g++/stl_list.h	/^	list(int n, const T& value) {fill_initialize(n, value); }$/;"	f	class:std::list
list	g++/stl_list.h	/^	list(long n, const T& value) {fill_initialize(n, value); }$/;"	f	class:std::list
list	g++/stl_list.h	/^	list(size_type n, const T& value) {fill_initialize(n, value);}$/;"	f	class:std::list
list	g++/stl_list.h	/^class list $/;"	c	namespace:std
list_node	g++/stl_list.h	/^	typedef __list_node<T> 							list_node;$/;"	t	class:std::list
list_node	g++/stl_slist.h	/^	typedef __slist_node<T> 						list_node;$/;"	t	class:std::slist
list_node	g++/stl_slist.h	/^	typedef __slist_node<T> 						list_node;$/;"	t	struct:std::__slist_iterator
list_node_allocator	g++/stl_list.h	/^	typedef simple_alloc<list_node, Alloc> 			list_node_allocator;$/;"	t	class:std::list
list_node_allocator	g++/stl_slist.h	/^	typedef simple_alloc<list_node, Alloc> 			list_node_allocator;$/;"	t	class:std::slist
list_node_base	g++/stl_slist.h	/^	typedef __slist_node_base 						list_node_base;$/;"	t	class:std::slist
lma	bfd.h	/^   bfd_vma lma;$/;"	m	struct:sec
locals	bfdlink.h	/^  struct bfd_elf_version_expr *locals;$/;"	m	struct:bfd_elf_version_tree	typeref:struct:bfd_elf_version_tree::bfd_elf_version_expr
log	g++/std/complext.cc	/^log (const complex<FLOAT>& x)$/;"	f
logical_and	g++/stl_function.h	/^struct logical_and : public binary_function<T, T, bool> {$/;"	s
logical_not	g++/stl_function.h	/^struct logical_not : public unary_function<T, bool> {$/;"	s
logical_or	g++/stl_function.h	/^struct logical_or : public binary_function<T, T, bool> {$/;"	s
longValue	tcl.h	/^	long longValue;		\/*   - an long integer value *\/$/;"	m	union:Tcl_Obj::__anon54
lookup_stream	g++/indstream.h	/^    virtual streambuf *lookup_stream(int\/*mode*\/) { return NULL; } \/\/ ERROR!$/;"	f	class:indirectbuf
lostSlaveProc	tk.h	/^    Tk_GeomLostSlaveProc *lostSlaveProc;$/;"	m	struct:Tk_GeomMgr
lower_bound	g++/stl_algo.h	/^inline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,$/;"	f
lower_bound	g++/stl_map.h	/^  const_iterator lower_bound(const key_type& x) const {$/;"	f	class:map
lower_bound	g++/stl_map.h	/^  iterator lower_bound(const key_type& x) {return t.lower_bound(x); }$/;"	f	class:map
lower_bound	g++/stl_multimap.h	/^  const_iterator lower_bound(const key_type& x) const {$/;"	f	class:multimap
lower_bound	g++/stl_multimap.h	/^  iterator lower_bound(const key_type& x) {return t.lower_bound(x); }$/;"	f	class:multimap
lower_bound	g++/stl_multiset.h	/^  iterator lower_bound(const key_type& x) const {$/;"	f	class:multiset
lower_bound	g++/stl_set.h	/^  iterator lower_bound(const key_type& x) const {$/;"	f	class:set
lower_bound	g++/stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key& k) const {$/;"	f	class:rb_tree
lower_bound	g++/stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key& k) {$/;"	f	class:rb_tree
lowercase_p	readline/chardefs.h	34;"	d
lru_next	bfd.h	/^    struct _bfd *lru_prev, *lru_next;$/;"	m	struct:_bfd	typeref:struct:_bfd::
lru_prev	bfd.h	/^    struct _bfd *lru_prev, *lru_next;$/;"	m	struct:_bfd	typeref:struct:_bfd::_bfd
lt	g++/std/straits.h	/^	static bool lt(const char_type& c1, const char_type& c2) { return (c1 < c2); }$/;"	f	struct:string_char_traits
lt	g++/std/straits.h	/^  static bool lt (const char_type& c1, const char_type& c2)$/;"	f	struct:string_char_traits
lynx_core_data	bfd.h	/^      struct lynx_core_struct *lynx_core_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::lynx_core_struct
mach	bfd.h	/^  unsigned long mach;$/;"	m	struct:bfd_arch_info
make_heap	g++/stl_heap.h	/^inline void make_heap(RandomAccessIterator first, RandomAccessIterator last) $/;"	f
make_heap	g++/stl_heap.h	/^inline void make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp) $/;"	f
make_pair	g++/stl_pair.h	/^inline pair<T1, T2> make_pair(const T1& x, const T2& y) {$/;"	f
malloc_alloc	g++/stl_alloc.h	/^typedef __malloc_alloc_template<0> malloc_alloc;$/;"	t
map	g++/stl_deque.h	/^	map_pointer map;$/;"	m	class:std::deque
map	g++/stl_map.h	/^  explicit map(const Compare& comp) : t(comp) {}$/;"	f	class:map
map	g++/stl_map.h	/^  map() : t(Compare()) {}$/;"	f	class:map
map	g++/stl_map.h	/^  map(InputIterator first, InputIterator last)$/;"	f	class:map
map	g++/stl_map.h	/^  map(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:map
map	g++/stl_map.h	/^  map(const map<Key, T, Compare, Alloc>& x) : t(x.t) {}$/;"	f	class:map
map	g++/stl_map.h	/^  map(const value_type* first, const value_type* last)$/;"	f	class:map
map	g++/stl_map.h	/^  map(const value_type* first, const value_type* last, const Compare& comp)$/;"	f	class:map
map	g++/stl_map.h	/^  map(const_iterator first, const_iterator last)$/;"	f	class:map
map	g++/stl_map.h	/^  map(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:map
map	g++/stl_map.h	/^class map {$/;"	c
map_allocator	g++/stl_deque.h	/^	typedef simple_alloc<pointer, Alloc> 					map_allocator;$/;"	t	class:std::deque
map_pointer	g++/stl_deque.h	/^	typedef T** 												map_pointer;$/;"	t	struct:std::__deque_iterator
map_pointer	g++/stl_deque.h	/^	typedef pointer* 										map_pointer;$/;"	t	class:std::deque
map_size	g++/stl_deque.h	/^	size_type map_size; \/\/$/;"	m	class:std::deque
mapped_type	g++/stl_hash_map.h	/^  typedef T mapped_type;$/;"	t	class:hash_map
mapped_type	g++/stl_hash_map.h	/^  typedef T mapped_type;$/;"	t	class:hash_multimap
mapped_type	g++/stl_map.h	/^  typedef T mapped_type;$/;"	t	class:map
mapped_type	g++/stl_multimap.h	/^  typedef T mapped_type;$/;"	t	class:multimap
mark_list	g++/editbuf.h	/^    inline struct edit_mark * mark_list() { return &start_mark; }$/;"	f	struct:edit_buffer
mark_pointer	g++/editbuf.h	/^typedef unsigned long mark_pointer;$/;"	t
mask	g++/stl_bvector.h	/^  unsigned int mask;$/;"	m	struct:__bit_reference
mask	tcl.h	/^    int mask;				\/* Mask value used in hashing$/;"	m	struct:Tcl_HashTable
match	bfdlink.h	/^  const char *match;$/;"	m	struct:bfd_elf_version_expr
max	g++/stl_algobase.h	/^max(const T& a, const T& b) {$/;"	f
max	g++/stl_algobase.h	/^max(const T& a, const T& b, Compare comp) {$/;"	f
max	g++/stl_algobase.h	55;"	d
max_bucket_count	g++/stl_hash_map.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_map
max_bucket_count	g++/stl_hash_map.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_multimap
max_bucket_count	g++/stl_hash_set.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_multiset
max_bucket_count	g++/stl_hash_set.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_set
max_bucket_count	g++/stl_hashtable.h	/^  size_type max_bucket_count() const$/;"	f	class:hashtable
max_element	g++/stl_algo.h	/^ForwardIterator max_element(ForwardIterator first, ForwardIterator last) {$/;"	f
max_element	g++/stl_algo.h	/^ForwardIterator max_element(ForwardIterator first, ForwardIterator last,$/;"	f
max_rope_depth	g++/stl_rope.h	/^    enum { max_rope_depth = 45 };$/;"	e	enum:__rope_RopeBase::__anon79
max_rope_depth	g++/stl_rope.h	/^    enum { max_rope_depth = 45 };$/;"	e	enum:__rope_RopeBase::__anon8
max_size	g++/defalloc.h	/^    size_type max_size() const $/;"	f	class:allocator
max_size	g++/std/bastring.h	/^	size_type max_size() const{ return (npos - 1)\/sizeof (charT); }		\/\/ XXX$/;"	f	class:basic_string
max_size	g++/stl_bvector.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:vector
max_size	g++/stl_deque.h	/^	size_type max_size() const { return size_type(-1); }$/;"	f	class:std::deque
max_size	g++/stl_hash_map.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_map
max_size	g++/stl_hash_map.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_multimap
max_size	g++/stl_hash_set.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_multiset
max_size	g++/stl_hash_set.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_set
max_size	g++/stl_hashtable.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:hashtable
max_size	g++/stl_list.h	/^	size_type max_size() const { $/;"	f	class:std::list
max_size	g++/stl_map.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:map
max_size	g++/stl_multimap.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:multimap
max_size	g++/stl_multiset.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:multiset
max_size	g++/stl_rope.h	/^	size_type max_size() const {$/;"	f	class:rope
max_size	g++/stl_set.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:set
max_size	g++/stl_slist.h	/^	size_type max_size() const { return size_type(-1); }$/;"	f	class:std::slist
max_size	g++/stl_tree.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:rb_tree
max_size	g++/stl_vector.h	/^	size_type max_size() const { return size_type(-1) \/ sizeof(T); }$/;"	f	class:vector
maxargc	tix.h	/^    int			maxargc;$/;"	m	struct:_Tix_SubCmdInfo
maxargc	tix.h	/^    int		maxargc;$/;"	m	struct:_Tix_CmdInfo
maximum	g++/stl_tree.h	/^	static base_ptr maximum(base_ptr x){$/;"	f	struct:__rb_tree_node_base
maximum	g++/stl_tree.h	/^  static link_type maximum(link_type x) {$/;"	f	class:rb_tree
mem_fun1_ref_t	g++/stl_function.h	/^  explicit mem_fun1_ref_t(void (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_ref_t
mem_fun1_ref_t	g++/stl_function.h	/^class mem_fun1_ref_t : public binary_function<T, A, S> {$/;"	c
mem_fun1_ref_t	g++/stl_function.h	/^class mem_fun1_ref_t<void, T, A> : public binary_function<T, A, void> {$/;"	c
mem_fun1_t	g++/stl_function.h	/^  explicit mem_fun1_t(void (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_t
mem_fun1_t	g++/stl_function.h	/^class mem_fun1_t : public binary_function<T*, A, S> {$/;"	c
mem_fun1_t	g++/stl_function.h	/^class mem_fun1_t<void, T, A> : public binary_function<T*, A, void> {$/;"	c
mem_fun_ref_t	g++/stl_function.h	/^  explicit mem_fun_ref_t(void (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_ref_t
mem_fun_ref_t	g++/stl_function.h	/^class mem_fun_ref_t : public unary_function<T, S> {$/;"	c
mem_fun_ref_t	g++/stl_function.h	/^class mem_fun_ref_t<void, T> : public unary_function<T, void> {$/;"	c
mem_fun_t	g++/stl_function.h	/^  explicit mem_fun_t(void (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_t
mem_fun_t	g++/stl_function.h	/^class mem_fun_t : public unary_function<T*, S> {$/;"	c
mem_fun_t	g++/stl_function.h	/^class mem_fun_t<void, T> : public unary_function<T*, void> {$/;"	c
memory	bfd.h	/^    PTR memory;$/;"	m	struct:_bfd
memory	bfd.h	/^  PTR memory;$/;"	m	struct:bfd_hash_table
merge	g++/stl_algo.h	/^OutputIterator merge(InputIterator1 first1, InputIterator1 last1,$/;"	f
merge	g++/stl_list.h	/^void list<T, Alloc>::merge(list<T, Alloc>& x) {$/;"	f	class:std::list
merge	g++/stl_list.h	/^void list<T, Alloc>::merge(list<T, Alloc>& x, StrictWeakOrdering comp) {$/;"	f	class:std::list
merge	g++/stl_slist.h	/^void slist<T,Alloc>::merge(slist<T,Alloc>& L)$/;"	f	class:std::slist
merge	g++/stl_slist.h	/^void slist<T,Alloc>::merge(slist<T,Alloc>& L, StrictWeakOrdering comp)$/;"	f	class:std::slist
meta_character_bit	readline/chardefs.h	24;"	d
meta_character_threshold	readline/chardefs.h	22;"	d
min	g++/stl_algobase.h	/^min(const T& a, const T& b) {$/;"	f
min	g++/stl_algobase.h	/^min(const T& a, const T& b, Compare comp) {$/;"	f
min	g++/stl_algobase.h	54;"	d
min_element	g++/stl_algo.h	/^ForwardIterator min_element(ForwardIterator first, ForwardIterator last) {$/;"	f
min_element	g++/stl_algo.h	/^ForwardIterator min_element(ForwardIterator first, ForwardIterator last,$/;"	f
min_len	g++/ropeimpl.h	/^rope<charT,Alloc>::min_len[__rope_RopeBase<charT,Alloc>::max_rope_depth + 1] = {$/;"	m	class:rope
min_len	g++/stl_rope.h	/^	static const unsigned long min_len[RopeBase::max_rope_depth + 1];$/;"	m	class:rope
minargc	tix.h	/^    int			minargc;$/;"	m	struct:_Tix_SubCmdInfo
minargc	tix.h	/^    int		minargc;$/;"	m	struct:_Tix_CmdInfo
minimum	g++/stl_tree.h	/^	static base_ptr minimum(base_ptr x){$/;"	f	struct:__rb_tree_node_base
minimum	g++/stl_tree.h	/^  static link_type minimum(link_type x) { $/;"	f	class:rb_tree
minus	g++/stl_function.h	/^struct minus : public binary_function<T, T, T> {$/;"	s
mismatch	g++/stl_algobase.h	/^mismatch(InputIterator1 first1,InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred) $/;"	f
mismatch	g++/stl_algobase.h	/^pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,InputIterator1 last1, InputIterator2 first2) $/;"	f
mmap	g++/libioP.h	493;"	d
modulus	g++/stl_function.h	/^struct modulus : public binary_function<T, T, T> {$/;"	s
move	g++/std/bastring.cc	/^move(size_t pos, const charT *s, size_t n)$/;"	f	class:basic_string::Rep
move	g++/std/straits.h	/^	static char_type* move(char_type* s1, const char_type* s2, size_t n)$/;"	f	struct:string_char_traits
move	g++/std/straits.h	/^  static char_type* move (char_type* s1, const char_type* s2, size_t n)$/;"	f	struct:string_char_traits
move_gap	g++/editbuf.h	/^    void move_gap (buf_char *pos) { move_gap(pos - data); }$/;"	f	struct:edit_buffer
moving_line_filepos	bfd.h	/^   file_ptr moving_line_filepos;$/;"	m	struct:sec
mtime	bfd.h	/^    long mtime;          $/;"	m	struct:_bfd
mtime_set	bfd.h	/^    boolean mtime_set;$/;"	m	struct:_bfd
multimap	g++/stl_multimap.h	/^  explicit multimap(const Compare& comp) : t(comp) { }$/;"	f	class:multimap
multimap	g++/stl_multimap.h	/^  multimap() : t(Compare()) { }$/;"	f	class:multimap
multimap	g++/stl_multimap.h	/^  multimap(InputIterator first, InputIterator last)$/;"	f	class:multimap
multimap	g++/stl_multimap.h	/^  multimap(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:multimap
multimap	g++/stl_multimap.h	/^  multimap(const multimap<Key, T, Compare, Alloc>& x) : t(x.t) { }$/;"	f	class:multimap
multimap	g++/stl_multimap.h	/^  multimap(const value_type* first, const value_type* last)$/;"	f	class:multimap
multimap	g++/stl_multimap.h	/^  multimap(const value_type* first, const value_type* last,$/;"	f	class:multimap
multimap	g++/stl_multimap.h	/^  multimap(const_iterator first, const_iterator last)$/;"	f	class:multimap
multimap	g++/stl_multimap.h	/^  multimap(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:multimap
multimap	g++/stl_multimap.h	/^class multimap {$/;"	c
multiple_common	bfdlink.h	/^  boolean (*multiple_common) PARAMS ((struct bfd_link_info *,$/;"	m	struct:bfd_link_callbacks
multiple_definition	bfdlink.h	/^  boolean (*multiple_definition) PARAMS ((struct bfd_link_info *,$/;"	m	struct:bfd_link_callbacks
multiplies	g++/stl_function.h	/^struct multiplies : public binary_function<T, T, T> {$/;"	s
multiset	g++/stl_multiset.h	/^  explicit multiset(const Compare& comp) : t(comp) {}$/;"	f	class:multiset
multiset	g++/stl_multiset.h	/^  multiset() : t(Compare()) {}$/;"	f	class:multiset
multiset	g++/stl_multiset.h	/^  multiset(InputIterator first, InputIterator last)$/;"	f	class:multiset
multiset	g++/stl_multiset.h	/^  multiset(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:multiset
multiset	g++/stl_multiset.h	/^  multiset(const multiset<Key, Compare, Alloc>& x) : t(x.t) {}$/;"	f	class:multiset
multiset	g++/stl_multiset.h	/^  multiset(const value_type* first, const value_type* last)$/;"	f	class:multiset
multiset	g++/stl_multiset.h	/^  multiset(const value_type* first, const value_type* last,$/;"	f	class:multiset
multiset	g++/stl_multiset.h	/^  multiset(const_iterator first, const_iterator last)$/;"	f	class:multiset
multiset	g++/stl_multiset.h	/^  multiset(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:multiset
multiset	g++/stl_multiset.h	/^class multiset {$/;"	c
munmap	g++/libioP.h	494;"	d
mutable_begin	g++/stl_rope.h	/^	iterator mutable_begin() {$/;"	f	class:rope
mutable_end	g++/stl_rope.h	/^	iterator mutable_end() {$/;"	f	class:rope
mutable_rbegin	g++/stl_rope.h	/^	reverse_iterator mutable_rbegin() {$/;"	f	class:rope
mutable_reference_at	g++/stl_rope.h	/^	reference mutable_reference_at(size_type pos) {$/;"	f	class:rope
mutable_rend	g++/stl_rope.h	/^	reverse_iterator mutable_rend() {$/;"	f	class:rope
my_archive	bfd.h	/^    struct _bfd *my_archive;      \/* The containing archive BFD.  *\/$/;"	m	struct:_bfd	typeref:struct:_bfd::_bfd
my_rope	g++/stl_rope.h	/^    typedef rope<charT,Alloc> my_rope;$/;"	t	class:__rope_charT_ref_proxy
my_rope	g++/stl_rope.h	/^    typedef rope<charT,Alloc> my_rope;$/;"	t	struct:__rope_RopeBase
name	bfd.h	/^    CONST char *name;$/;"	m	struct:sec
name	bfd.h	/^  CONST char *name;            \/* Symbol name.  *\/$/;"	m	struct:_symbol_info
name	bfd.h	/^  CONST char *name;$/;"	m	struct:symbol_cache_entry
name	bfd.h	/^  char **name;			\/* symbol name *\/ $/;"	m	struct:orl
name	bfd.h	/^  char *name;$/;"	m	struct:bfd_target
name	bfd.h	/^  char *name;$/;"	m	struct:carsym
name	bfd.h	/^  char *name;$/;"	m	struct:reloc_howto_struct
name	bfd.h	/^  const char *name;$/;"	m	struct:bfd_link_needed_list
name	bfdlink.h	/^      const char *name;$/;"	m	union:bfd_link_order_reloc::__anon69
name	bfdlink.h	/^  const char *name;$/;"	m	struct:bfd_elf_version_tree
name	readline/readline.h	/^  char *name;$/;"	m	struct:__anon28
name	readline/readline.h	/^  char *name;$/;"	m	struct:__anon29
name	tcl.h	/^    char *name;			\/* Name of the type, e.g. "int". *\/$/;"	m	struct:Tcl_ObjType
name	tcl.h	/^    char *name;                 \/* The namespace's name within its parent$/;"	m	struct:Tcl_Namespace
name	tix.h	/^    char      	      * name;$/;"	m	struct:_Tix_SubCmdInfo
name	tix.h	/^    char *name;			\/* Name of command. *\/$/;"	m	struct:__anon58
name	tk.h	/^    Tk_Uid name;	    \/* Name of virtual event. *\/$/;"	m	struct:__anon34
name	tk.h	/^    char *name;				\/* The name of this type of item, such$/;"	m	struct:Tk_ItemType
name	tk.h	/^    char *name;			\/* Name of image file format *\/$/;"	m	struct:Tk_PhotoImageFormat
name	tk.h	/^    char *name;			\/* Name of image type. *\/$/;"	m	struct:Tk_ImageType
name	tk.h	/^    char *name;			\/* Name of the geometry manager (command$/;"	m	struct:Tk_GeomMgr
nameUid	tk.h	/^    Tk_Uid nameUid;$/;"	m	struct:Tk_FakeWin
name_indx	bfdlink.h	/^  unsigned int name_indx;$/;"	m	struct:bfd_elf_version_tree
namelen	tix.h	/^    int			namelen;$/;"	m	struct:_Tix_SubCmdInfo
namespacePtr	tcl.h	/^    Tcl_Namespace *namespacePtr; \/* Points to the namespace that contains$/;"	m	struct:Tcl_CmdInfo
namidx	bfd.h	/^  int namidx;			\/* index into string table *\/$/;"	m	struct:orl
ne	g++/std/straits.h	/^	static bool ne(const char_type& c1, const char_type& c2) { return !(c1 == c2); }$/;"	f	struct:string_char_traits
ne	g++/std/straits.h	/^  static bool ne (const char_type& c1, const char_type& c2)$/;"	f	struct:string_char_traits
negate	g++/stl_function.h	/^struct negate : public unary_function<T, T> {$/;"	s
netbsd_core_data	bfd.h	/^      struct netbsd_core_struct *netbsd_core_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::netbsd_core_struct
new_elements_at_back	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::new_elements_at_back(size_type new_elements) $/;"	f	class:std::deque
new_elements_at_front	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::new_elements_at_front(size_type new_elements) $/;"	f	class:std::deque
new_node	g++/stl_hashtable.h	/^  node* new_node(const value_type& obj)$/;"	f	class:hashtable
newfunc	bfd.h	/^  struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,$/;"	m	struct:bfd_hash_table	typeref:struct:bfd_hash_table::newfunc
next	bfd.h	/^    struct _bfd *next;            \/* The next BFD in the archive.  *\/$/;"	m	struct:_bfd	typeref:struct:_bfd::_bfd
next	bfd.h	/^    struct sec *next;$/;"	m	struct:sec	typeref:struct:sec::sec
next	bfd.h	/^  const struct bfd_arch_info *next;$/;"	m	struct:bfd_arch_info	typeref:struct:bfd_arch_info::bfd_arch_info
next	bfd.h	/^  struct   relent_chain *next;$/;"	m	struct:relent_chain	typeref:struct:relent_chain::relent_chain
next	bfd.h	/^  struct bfd_hash_entry *next;$/;"	m	struct:bfd_hash_entry	typeref:struct:bfd_hash_entry::bfd_hash_entry
next	bfd.h	/^  struct bfd_link_needed_list *next;$/;"	m	struct:bfd_link_needed_list	typeref:struct:bfd_link_needed_list::bfd_link_needed_list
next	bfdlink.h	/^  struct bfd_elf_version_deps *next;$/;"	m	struct:bfd_elf_version_deps	typeref:struct:bfd_elf_version_deps::bfd_elf_version_deps
next	bfdlink.h	/^  struct bfd_elf_version_expr *next;$/;"	m	struct:bfd_elf_version_expr	typeref:struct:bfd_elf_version_expr::bfd_elf_version_expr
next	bfdlink.h	/^  struct bfd_elf_version_tree *next;$/;"	m	struct:bfd_elf_version_tree	typeref:struct:bfd_elf_version_tree::bfd_elf_version_tree
next	bfdlink.h	/^  struct bfd_link_hash_entry *next;$/;"	m	struct:bfd_link_hash_entry	typeref:struct:bfd_link_hash_entry::bfd_link_hash_entry
next	bfdlink.h	/^  struct bfd_link_order *next;$/;"	m	struct:bfd_link_order	typeref:struct:bfd_link_order::bfd_link_order
next	g++/editbuf.h	/^    edit_streambuf* next; \/\/ Chain of edit_streambuf's for a edit_buffer.$/;"	m	struct:edit_streambuf
next	g++/stl_hashtable.h	/^  __hashtable_node* next;$/;"	m	struct:__hashtable_node
next	g++/stl_list.h	/^	void_pointer next;$/;"	m	struct:std::__list_node
next	g++/stl_slist.h	/^	__slist_node_base* next;$/;"	m	struct:std::__slist_node_base
next	readline/readline.h	/^  struct undo_list *next;$/;"	m	struct:undo_list	typeref:struct:undo_list::undo_list
nextEntryPtr	tcl.h	/^    Tcl_HashEntry *nextEntryPtr;	\/* Next entry to be enumerated in the$/;"	m	struct:Tcl_HashSearch
nextIndex	tcl.h	/^    int nextIndex;			\/* Index of next bucket to be$/;"	m	struct:Tcl_HashSearch
nextOffset	tix.h	/^    int nextOffset;		\/* offset of the "next" pointer in a list$/;"	m	struct:Tix_ListInfo
nextPtr	tcl.h	/^    struct Tcl_Event *nextPtr;	\/* Next in list of pending events, or NULL. *\/$/;"	m	struct:Tcl_Event	typeref:struct:Tcl_Event::Tcl_Event
nextPtr	tcl.h	/^    struct Tcl_HashEntry *nextPtr;	\/* Pointer to next entry in this$/;"	m	struct:Tcl_HashEntry	typeref:struct:Tcl_HashEntry::Tcl_HashEntry
nextPtr	tk.h	/^    struct Tk_ImageType *nextPtr;$/;"	m	struct:Tk_ImageType	typeref:struct:Tk_ImageType::Tk_ImageType
nextPtr	tk.h	/^    struct Tk_Item *nextPtr;		\/* Next in display list of all$/;"	m	struct:Tk_Item	typeref:struct:Tk_Item::Tk_Item
nextPtr	tk.h	/^    struct Tk_ItemType *nextPtr;	\/* Used to link types together into$/;"	m	struct:Tk_ItemType	typeref:struct:Tk_ItemType::Tk_ItemType
nextPtr	tk.h	/^    struct Tk_PhotoImageFormat *nextPtr;$/;"	m	struct:Tk_PhotoImageFormat	typeref:struct:Tk_PhotoImageFormat::Tk_PhotoImageFormat
next_permutation	g++/stl_algo.h	/^bool next_permutation(BidirectionalIterator first, BidirectionalIterator last,$/;"	f
next_permutation	g++/stl_algo.h	/^bool next_permutation(BidirectionalIterator first,$/;"	f
next_size	g++/stl_hashtable.h	/^  size_type next_size(size_type n) const { return __stl_next_prime(n); }$/;"	f	class:hashtable
nilRep	g++/std/bastring.cc	/^basic_string<charT, traits, Allocator>::nilRep = { 0, 0, 1, false };$/;"	m	class:basic_string	file:
nilRep	g++/std/bastring.h	/^	static Rep nilRep;$/;"	m	class:basic_string
nlm_obj_data	bfd.h	/^      struct nlm_obj_tdata *nlm_obj_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::nlm_obj_tdata
no_direction	bfd.h	/^    enum bfd_direction {no_direction = 0,$/;"	e	enum:_bfd::bfd_direction
nocreate	g++/streambuf.h	/^	nocreate = _IO_NOCREATE,$/;"	e	enum:ios::open_mode
node	g++/stl_deque.h	/^	map_pointer node;   \/\/map$/;"	m	struct:std::__deque_iterator
node	g++/stl_hashtable.h	/^  typedef __hashtable_node<Value> node;$/;"	t	class:hashtable
node	g++/stl_hashtable.h	/^  typedef __hashtable_node<Value> node;$/;"	t	struct:__hashtable_const_iterator
node	g++/stl_hashtable.h	/^  typedef __hashtable_node<Value> node;$/;"	t	struct:__hashtable_iterator
node	g++/stl_list.h	/^	link_type node;$/;"	m	class:std::list
node	g++/stl_list.h	/^	link_type node;$/;"	m	struct:std::__list_iterator
node	g++/stl_slist.h	/^	__slist_node_base* 				node;$/;"	m	struct:std::__slist_iterator_base
node	g++/stl_tree.h	/^	base_ptr 								node;$/;"	m	struct:__rb_tree_base_iterator
node_allocator	g++/stl_hashtable.h	/^  typedef simple_alloc<node, Alloc> node_allocator;$/;"	t	class:hashtable
node_count	g++/stl_tree.h	/^  size_type node_count; \/\/ keeps track of size of tree$/;"	m	class:rb_tree
noreplace	g++/streambuf.h	/^	noreplace = _IO_NOREPLACE,$/;"	e	enum:ios::open_mode
norm	g++/std/complext.h	/^norm (const complex<_FLT>& x)$/;"	f
not	include/iso646.h	9;"	d
not1	g++/stl_function.h	/^inline unary_negate<Predicate> not1(const Predicate& pred) {$/;"	f
not2	g++/stl_function.h	/^inline binary_negate<Predicate> not2(const Predicate& pred) {$/;"	f
not_eq	include/iso646.h	10;"	d
not_equal_to	g++/stl_function.h	/^struct not_equal_to : public binary_function<T, T, bool> {$/;"	s
notice	bfdlink.h	/^  boolean (*notice) PARAMS ((struct bfd_link_info *, const char *name,$/;"	m	struct:bfd_link_callbacks
notice_all	bfdlink.h	/^  boolean notice_all;$/;"	m	struct:bfd_link_info
notice_hash	bfdlink.h	/^  struct bfd_hash_table *notice_hash;$/;"	m	struct:bfd_link_info	typeref:struct:bfd_link_info::bfd_hash_table
npos	g++/std/bastring.cc	/^basic_string <charT, traits, Allocator>::npos;$/;"	m	class:basic_string	file:
npos	g++/std/bastring.h	/^	static const size_type npos = static_cast<size_type>(-1);$/;"	m	class:basic_string
nsPtr	tcl.h	/^    Tcl_Namespace *nsPtr;$/;"	m	struct:Tcl_CallFrame
nth_element	g++/stl_algo.h	/^inline void nth_element(RandomAccessIterator first, RandomAccessIterator nth,$/;"	f
numBuckets	tcl.h	/^    int numBuckets;			\/* Total number of buckets allocated$/;"	m	struct:Tcl_HashTable
numEntries	tcl.h	/^    int numEntries;			\/* Total number of entries present$/;"	m	struct:Tcl_HashTable
numItems	tix.h	/^    int numItems;		\/* number of items in this list *\/$/;"	m	struct:Tix_LinkList
numSubCmds	tix.h	/^    int		numSubCmds;$/;"	m	struct:_Tix_CmdInfo
numTags	tk.h	/^    int numTags;			\/* Number of tag slots actually used$/;"	m	struct:Tk_Item
num_elements	g++/stl_hashtable.h	/^  size_type num_elements;$/;"	m	class:hashtable
o	g++/ropeimpl.h	/^	insert_ostream & o;$/;"	m	class:__rope_insert_char_consumer
oapp	g++/iomanip.h	/^template<class TP> class oapp {$/;"	c
oasys_ar_data	bfd.h	/^      struct _oasys_ar_data *oasys_ar_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::_oasys_ar_data
oasys_obj_data	bfd.h	/^      struct _oasys_data *oasys_obj_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::_oasys_data
obj	g++/stl_alloc.h	/^	union obj       \/\/ objobj$/;"	u	class:__default_alloc_template
objClientData	tcl.h	/^    ClientData objClientData;	 \/* ClientData for object proc. *\/$/;"	m	struct:Tcl_CmdInfo
objProc	tcl.h	/^    Tcl_ObjCmdProc *objProc;	 \/* Command's object-based procedure. *\/$/;"	m	struct:Tcl_CmdInfo
object_flags	bfd.h	/^  flagword object_flags;       $/;"	m	struct:bfd_target
oct	g++/iostream.h	/^inline ios& oct(ios& i)$/;"	f
oct	g++/streambuf.h	/^	   dec=_IO_DEC, oct=_IO_OCT, hex=_IO_HEX,$/;"	e	enum:ios::__anon1
oct	g++/streambuf.h	/^	   dec=_IO_DEC, oct=_IO_OCT, hex=_IO_HEX,$/;"	e	enum:ios::__anon72
offset	bfd.h	/^    unsigned long offset;	\/* Offset into section *\/$/;"	m	union:lineno_cache_entry::__anon36
offset	bfdlink.h	/^  bfd_vma offset;  $/;"	m	struct:bfd_link_order
offset	g++/stl_bvector.h	/^  unsigned int offset;$/;"	m	struct:__bit_const_iterator
offset	g++/stl_bvector.h	/^  unsigned int offset;$/;"	m	struct:__bit_iterator
offset	tk.h	/^    int		offset[3];	\/* Address differences between the red, green$/;"	m	struct:Tk_PhotoImageBlock
offset	tk.h	/^    int offset;			\/* Where in widget record to store value;$/;"	m	struct:Tk_ConfigSpec
offsetof	include/stddef.h	337;"	d
ofstream	g++/fstream.h	/^    ofstream() : fstreambase() { }$/;"	f	class:ofstream
ofstream	g++/fstream.h	/^    ofstream(const char *name, int mode=ios::out, int prot=0664)$/;"	f	class:ofstream
ofstream	g++/fstream.h	/^    ofstream(int fd) : fstreambase(fd) { }$/;"	f	class:ofstream
ofstream	g++/fstream.h	/^    ofstream(int fd, char *p, int l) : fstreambase(fd, p, l) { } \/*Deprecated*\/$/;"	f	class:ofstream
ofstream	g++/fstream.h	/^class ofstream : public fstreambase, public ostream {$/;"	c
omanip	g++/iomanip.h	/^template <class TP> class omanip {$/;"	c
oneWordValue	tcl.h	/^	char *oneWordValue;		\/* One-word value for key. *\/$/;"	m	union:Tcl_HashEntry::__anon56
oom_malloc	g++/stl_alloc.h	/^void* __malloc_alloc_template<inst>::oom_malloc(size_t n)$/;"	f	class:__malloc_alloc_template
oom_realloc	g++/stl_alloc.h	/^void* __malloc_alloc_template<inst>::oom_realloc(void *p, size_t n)$/;"	f	class:__malloc_alloc_template
op	g++/stl_function.h	/^  Operation op;$/;"	m	class:binder1st
op	g++/stl_function.h	/^  Operation op;$/;"	m	class:binder2nd
op1	g++/stl_function.h	/^  Operation1 op1;$/;"	m	class:binary_compose
op1	g++/stl_function.h	/^  Operation1 op1;$/;"	m	class:unary_compose
op2	g++/stl_function.h	/^  Operation2 op2;$/;"	m	class:binary_compose
op2	g++/stl_function.h	/^  Operation2 op2;$/;"	m	class:unary_compose
op3	g++/stl_function.h	/^  Operation3 op3;$/;"	m	class:binary_compose
open	g++/fstream.h	/^    void open(const char *name, int mode, int prot=0664)$/;"	f	class:fstream
open	g++/fstream.h	/^    void open(const char *name, int mode=ios::in, int prot=0664)$/;"	f	class:ifstream
open	g++/fstream.h	/^    void open(const char *name, int mode=ios::out, int prot=0664)$/;"	f	class:ofstream
open	g++/streambuf.h	70;"	d
open_mode	g++/streambuf.h	/^    enum open_mode {$/;"	g	class:ios
open_mode	g++/streambuf.h	/^enum open_mode {$/;"	g
opened_once	bfd.h	/^    boolean opened_once;$/;"	m	struct:_bfd
openmode	g++/streambuf.h	/^    typedef int openmode;$/;"	t	class:ios
openprot	g++/streambuf.h	/^    static const int openprot; \/\/ Non-ANSI AT&T-ism:  Default open protection.$/;"	m	class:filebuf
openr_next_archived_file	bfd.h	/^  bfd *    (*openr_next_archived_file) PARAMS ((bfd *arch, bfd *prev));$/;"	m	struct:bfd_target
operator !	g++/streambuf.h	/^    int operator!() const { return fail(); }$/;"	f	class:ios
operator !=	g++/std/bastring.h	/^operator!= (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)$/;"	f
operator !=	g++/std/bastring.h	/^operator!= (const basic_string <charT, traits, Allocator>& lhs,$/;"	f
operator !=	g++/std/bastring.h	/^operator!= (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)$/;"	f
operator !=	g++/std/complext.h	/^operator != (_FLT x, const complex<_FLT>& y)$/;"	f
operator !=	g++/std/complext.h	/^operator != (const complex<_FLT>& x, _FLT y)$/;"	f
operator !=	g++/std/complext.h	/^operator != (const complex<_FLT>& x, const complex<_FLT>& y)$/;"	f
operator !=	g++/std/dcomplex.h	/^  friend inline bool operator != (const complex& x, double y)$/;"	f	class:complex
operator !=	g++/std/dcomplex.h	/^  friend inline bool operator != (double x, const complex& y)$/;"	f	class:complex
operator !=	g++/std/fcomplex.h	/^  friend inline bool operator != (const complex& x, float y)$/;"	f	class:complex
operator !=	g++/std/fcomplex.h	/^  friend inline bool operator != (float x, const complex& y)$/;"	f	class:complex
operator !=	g++/std/ldcomplex.h	/^  friend inline bool operator != (const complex& x, long double y)$/;"	f	class:complex
operator !=	g++/std/ldcomplex.h	/^  friend inline bool operator != (long double x, const complex& y)$/;"	f	class:complex
operator !=	g++/stl_bvector.h	/^  bool operator!=(const const_iterator& x) const {$/;"	f	struct:__bit_const_iterator
operator !=	g++/stl_bvector.h	/^  bool operator!=(const iterator& x) const {$/;"	f	struct:__bit_iterator
operator !=	g++/stl_deque.h	/^	bool operator!=(const self& x) const { return !(*this == x); }$/;"	f	struct:std::__deque_iterator
operator !=	g++/stl_hashtable.h	/^  bool operator!=(const const_iterator& it) const { return cur != it.cur; }$/;"	f	struct:__hashtable_const_iterator
operator !=	g++/stl_hashtable.h	/^  bool operator!=(const iterator& it) const { return cur != it.cur; }$/;"	f	struct:__hashtable_iterator
operator !=	g++/stl_list.h	/^	bool operator!=(const self& x) const { $/;"	f	struct:std::__list_iterator
operator !=	g++/stl_relops.h	/^inline bool operator!=(const T& x, const T& y) {$/;"	f
operator !=	g++/stl_slist.h	/^	bool operator!=(const __slist_iterator_base& x) const {$/;"	f	struct:std::__slist_iterator_base
operator !=	g++/stl_tree.h	/^inline bool operator!=(const __rb_tree_base_iterator& x, const __rb_tree_base_iterator& y) $/;"	f
operator &	g++/ropeimpl.h	/^__rope_charT_ref_proxy<charT, Alloc>::operator& () const {$/;"	f	class:__rope_charT_ref_proxy
operator ()	g++/iomanip.h	/^    imanip<TP> operator()(TP a)$/;"	f	class:iapp
operator ()	g++/iomanip.h	/^    omanip<TP> operator()(TP a)$/;"	f	class:oapp
operator ()	g++/iomanip.h	/^    smanip<TP> operator()(TP a) $/;"	f	class:sapp
operator ()	g++/ropeimpl.h	/^	bool operator() (const charT* leaf, size_t n) {$/;"	f	class:__rope_find_char_char_consumer
operator ()	g++/ropeimpl.h	/^	bool operator() (const charT* leaf, size_t n) {$/;"	f	class:__rope_flatten_char_consumer
operator ()	g++/ropeimpl.h	/^bool __rope_insert_char_consumer<charT>::operator()$/;"	f	class:__rope_insert_char_consumer
operator ()	g++/ropeimpl.h	/^inline bool __rope_insert_char_consumer<char>::operator()$/;"	f	class:__rope_insert_char_consumer
operator ()	g++/ropeimpl.h	/^inline bool __rope_insert_char_consumer<wchar_t>::operator()$/;"	f	class:__rope_insert_char_consumer
operator ()	g++/stl_algobase.h	/^	BidirectionalIterator2 operator()(BidirectionalIterator1 first, $/;"	f	struct:__copy_backward_dispatch
operator ()	g++/stl_algobase.h	/^	OutputIterator operator()(InputIterator first, InputIterator last, OutputIterator result) $/;"	f	struct:__copy_dispatch
operator ()	g++/stl_algobase.h	/^	T* operator()(T* first, T* last, T* result) $/;"	f	struct:__copy_backward_dispatch
operator ()	g++/stl_algobase.h	/^	T* operator()(T* first, T* last, T* result) $/;"	f	struct:__copy_dispatch
operator ()	g++/stl_algobase.h	/^	T* operator()(const T* first, const T* last, T* result) $/;"	f	struct:__copy_backward_dispatch
operator ()	g++/stl_algobase.h	/^	T* operator()(const T* first, const T* last, T* result) $/;"	f	struct:__copy_dispatch
operator ()	g++/stl_function.h	/^    Result operator()(Arg1 x, Arg2 y) const { return ptr(x, y); }$/;"	f	class:pointer_to_binary_function
operator ()	g++/stl_function.h	/^    T operator()(const T& x) const { return -x; }$/;"	f	struct:negate
operator ()	g++/stl_function.h	/^    T operator()(const T& x, const T& y) const { return x % y; }$/;"	f	struct:modulus
operator ()	g++/stl_function.h	/^    T operator()(const T& x, const T& y) const { return x * y; }$/;"	f	struct:multiplies
operator ()	g++/stl_function.h	/^    T operator()(const T& x, const T& y) const { return x + y; }$/;"	f	struct:plus
operator ()	g++/stl_function.h	/^    T operator()(const T& x, const T& y) const { return x - y; }$/;"	f	struct:minus
operator ()	g++/stl_function.h	/^    T operator()(const T& x, const T& y) const { return x \/ y; }$/;"	f	struct:divides
operator ()	g++/stl_function.h	/^    bool operator()(const T& x) const { return !x; }$/;"	f	struct:logical_not
operator ()	g++/stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x != y; }$/;"	f	struct:not_equal_to
operator ()	g++/stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x && y; }$/;"	f	struct:logical_and
operator ()	g++/stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x < y; }$/;"	f	struct:less
operator ()	g++/stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x <= y; }$/;"	f	struct:less_equal
operator ()	g++/stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x == y; }$/;"	f	struct:equal_to
operator ()	g++/stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x > y; }$/;"	f	struct:greater
operator ()	g++/stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x >= y; }$/;"	f	struct:greater_equal
operator ()	g++/stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x || y; }$/;"	f	struct:logical_or
operator ()	g++/stl_function.h	/^  Arg1 operator()(const Arg1& x, const Arg2&) const { return x; }$/;"	f	struct:project1st
operator ()	g++/stl_function.h	/^  Arg2 operator()(const Arg1&, const Arg2& y) const { return y; }$/;"	f	struct:project2nd
operator ()	g++/stl_function.h	/^  Result operator()(Arg x) const { return ptr(x); }$/;"	f	class:pointer_to_unary_function
operator ()	g++/stl_function.h	/^  S operator()(T& r) const { return (r.*f)(); }$/;"	f	class:mem_fun_ref_t
operator ()	g++/stl_function.h	/^  S operator()(T& r, A x) const { return (r.*f)(x); }$/;"	f	class:mem_fun1_ref_t
operator ()	g++/stl_function.h	/^  S operator()(T* p) const { return (p->*f)(); }$/;"	f	class:mem_fun_t
operator ()	g++/stl_function.h	/^  S operator()(T* p, A x) const { return (p->*f)(x); }$/;"	f	class:mem_fun1_t
operator ()	g++/stl_function.h	/^  S operator()(const T& r) const { return (r.*f)(); }$/;"	f	class:const_mem_fun_ref_t
operator ()	g++/stl_function.h	/^  S operator()(const T& r, A x) const { return (r.*f)(x); }$/;"	f	class:const_mem_fun1_ref_t
operator ()	g++/stl_function.h	/^  S operator()(const T* p) const { return (p->*f)(); }$/;"	f	class:const_mem_fun_t
operator ()	g++/stl_function.h	/^  S operator()(const T* p, A x) const { return (p->*f)(x); }$/;"	f	class:const_mem_fun1_t
operator ()	g++/stl_function.h	/^  bool operator()(const typename Predicate::argument_type& x) const {$/;"	f	class:unary_negate
operator ()	g++/stl_function.h	/^  bool operator()(const typename Predicate::first_argument_type& x, $/;"	f	class:binary_negate
operator ()	g++/stl_function.h	/^  const Result& operator()(const Arg1&, const Arg2&) const {$/;"	f	struct:constant_binary_fun
operator ()	g++/stl_function.h	/^  const Result& operator()(const Argument&) const { return val; }$/;"	f	struct:constant_unary_fun
operator ()	g++/stl_function.h	/^  const T& operator()(const T& x) const { return x; }$/;"	f	struct:identity
operator ()	g++/stl_function.h	/^  const result_type& operator()() const { return val; }$/;"	f	struct:constant_void_fun
operator ()	g++/stl_function.h	/^  const typename Pair::first_type& operator()(const Pair& x) const$/;"	f	struct:select1st
operator ()	g++/stl_function.h	/^  const typename Pair::second_type& operator()(const Pair& x) const$/;"	f	struct:select2nd
operator ()	g++/stl_function.h	/^  operator()(const typename Operation2::argument_type& x) const {$/;"	f	class:binary_compose
operator ()	g++/stl_function.h	/^  operator()(const typename Operation2::argument_type& x) const {$/;"	f	class:unary_compose
operator ()	g++/stl_function.h	/^  operator()(const typename Operation::first_argument_type& x) const {$/;"	f	class:binder2nd
operator ()	g++/stl_function.h	/^  operator()(const typename Operation::second_argument_type& x) const {$/;"	f	class:binder1st
operator ()	g++/stl_function.h	/^  unsigned int operator()(unsigned int limit) {$/;"	f	class:subtractive_rng
operator ()	g++/stl_function.h	/^  void operator()(T& r) const { (r.*f)(); }$/;"	f	class:mem_fun_ref_t
operator ()	g++/stl_function.h	/^  void operator()(T& r, A x) const { (r.*f)(x); }$/;"	f	class:mem_fun1_ref_t
operator ()	g++/stl_function.h	/^  void operator()(T* p) const { (p->*f)(); }$/;"	f	class:mem_fun_t
operator ()	g++/stl_function.h	/^  void operator()(T* p, A x) const { (p->*f)(x); }$/;"	f	class:mem_fun1_t
operator ()	g++/stl_function.h	/^  void operator()(const T& r) const { (r.*f)(); }$/;"	f	class:const_mem_fun_ref_t
operator ()	g++/stl_function.h	/^  void operator()(const T& r, A x) const { (r.*f)(x); }$/;"	f	class:const_mem_fun1_ref_t
operator ()	g++/stl_function.h	/^  void operator()(const T* p) const { (p->*f)(); }$/;"	f	class:const_mem_fun_t
operator ()	g++/stl_function.h	/^  void operator()(const T* p, A x) const { (p->*f)(x); }$/;"	f	class:const_mem_fun1_t
operator ()	g++/stl_hash_fun.h	/^  size_t operator()(char x) const { return x; }$/;"	f	struct:hash
operator ()	g++/stl_hash_fun.h	/^  size_t operator()(const char* s) const { return __stl_hash_string(s); }$/;"	f	struct:hash
operator ()	g++/stl_hash_fun.h	/^  size_t operator()(int x) const { return x; }$/;"	f	struct:hash
operator ()	g++/stl_hash_fun.h	/^  size_t operator()(long x) const { return x; }$/;"	f	struct:hash
operator ()	g++/stl_hash_fun.h	/^  size_t operator()(short x) const { return x; }$/;"	f	struct:hash
operator ()	g++/stl_hash_fun.h	/^  size_t operator()(unsigned char x) const { return x; }$/;"	f	struct:hash
operator ()	g++/stl_hash_fun.h	/^  size_t operator()(unsigned int x) const { return x; }$/;"	f	struct:hash
operator ()	g++/stl_hash_fun.h	/^  size_t operator()(unsigned long x) const { return x; }$/;"	f	struct:hash
operator ()	g++/stl_hash_fun.h	/^  size_t operator()(unsigned short x) const { return x; }$/;"	f	struct:hash
operator ()	g++/stl_map.h	/^    bool operator()(const value_type& x, const value_type& y) const {$/;"	f	class:map::value_compare
operator ()	g++/stl_multimap.h	/^    bool operator()(const value_type& x, const value_type& y) const {$/;"	f	class:multimap::value_compare
operator ()	g++/stl_rope.h	/^		rope operator() (const rope& x, const rope& y) {$/;"	f	struct:rope::concat_fn
operator ()	g++/stl_rope.h	/^    virtual void operator()(size_t start_pos, size_t req_len,$/;"	f	struct:__rope_RopeSubstring
operator ()	g++/stl_rope.h	/^  size_t operator()(const crope& str) const$/;"	f	struct:hash
operator ()	g++/stl_rope.h	/^  size_t operator()(const wrope& str) const$/;"	f	struct:hash
operator *	g++/std/complext.h	/^operator * (_FLT x, const complex<_FLT>& y)$/;"	f
operator *	g++/std/complext.h	/^operator * (const complex<_FLT>& x, _FLT y)$/;"	f
operator *	g++/std/complext.h	/^operator * (const complex<_FLT>& x, const complex<_FLT>& y)$/;"	f
operator *	g++/std/dcomplex.h	/^  friend inline complex operator * (const complex& x, double y)$/;"	f	class:complex
operator *	g++/std/dcomplex.h	/^  friend inline complex operator * (double x, const complex& y)$/;"	f	class:complex
operator *	g++/std/fcomplex.h	/^  friend inline complex operator * (const complex& x, float y)$/;"	f	class:complex
operator *	g++/std/fcomplex.h	/^  friend inline complex operator * (float x, const complex& y)$/;"	f	class:complex
operator *	g++/std/ldcomplex.h	/^  friend inline complex operator * (const complex& x, long double y)$/;"	f	class:complex
operator *	g++/std/ldcomplex.h	/^  friend inline complex operator * (long double x, const complex& y)$/;"	f	class:complex
operator *	g++/stl_bvector.h	/^  const_reference operator*() const {$/;"	f	struct:__bit_const_iterator
operator *	g++/stl_bvector.h	/^  reference operator*() const { return reference(p, 1U << offset); }$/;"	f	struct:__bit_iterator
operator *	g++/stl_deque.h	/^	reference operator*() const { return *cur; }$/;"	f	struct:std::__deque_iterator
operator *	g++/stl_hashtable.h	/^  reference operator*() const { return cur->val; }$/;"	f	struct:__hashtable_const_iterator
operator *	g++/stl_hashtable.h	/^  reference operator*() const { return cur->val; }$/;"	f	struct:__hashtable_iterator
operator *	g++/stl_iterator.h	/^  Reference operator*() const { return *(current - 1); }$/;"	f	class:reverse_iterator
operator *	g++/stl_iterator.h	/^  Reference operator*() const {$/;"	f	class:reverse_bidirectional_iterator
operator *	g++/stl_iterator.h	/^  back_insert_iterator<Container>& operator*() { return *this; }$/;"	f	class:back_insert_iterator
operator *	g++/stl_iterator.h	/^  front_insert_iterator<Container>& operator*() { return *this; }$/;"	f	class:front_insert_iterator
operator *	g++/stl_iterator.h	/^  insert_iterator<Container>& operator*() { return *this; }$/;"	f	class:insert_iterator
operator *	g++/stl_iterator.h	/^  ostream_iterator<T>& operator*() { return *this; }$/;"	f	class:ostream_iterator
operator *	g++/stl_iterator.h	/^  reference operator*() const { return value; }$/;"	f	class:istream_iterator
operator *	g++/stl_iterator.h	/^  reference operator*() const {$/;"	f	class:reverse_iterator
operator *	g++/stl_list.h	/^	reference operator*() const { $/;"	f	struct:std::__list_iterator
operator *	g++/stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T>& operator*() { return *this; }$/;"	f	class:raw_storage_iterator
operator *	g++/stl_rope.h	/^	sequence_buffer& operator*() { return *this; }$/;"	f	class:sequence_buffer
operator *	g++/stl_rope.h	/^    __rope_RopeBase<charT,Alloc> & operator*() { return *ptr; }$/;"	f	struct:__rope_self_destruct_ptr
operator *	g++/stl_rope.h	/^    __rope_charT_ref_proxy<charT,Alloc> operator *() const {$/;"	f	class:__rope_charT_ptr_proxy
operator *	g++/stl_rope.h	/^    reference operator*() {$/;"	f	class:__rope_const_iterator
operator *	g++/stl_rope.h	/^    reference operator*() {$/;"	f	class:__rope_iterator
operator *	g++/stl_slist.h	/^	reference operator*() const { $/;"	f	struct:std::__slist_iterator
operator *	g++/stl_tree.h	/^	reference operator*() const { return link_type(node)->value_field; }$/;"	f	struct:__rb_tree_iterator
operator *=	g++/std/complext.h	/^complex<_FLT>::operator *= (const complex<_FLT>& r)$/;"	f	class:complex
operator *=	g++/std/dcomplex.h	/^  complex& operator*= (const complex& r) { return __doaml (this, r); }$/;"	f	class:complex
operator *=	g++/std/fcomplex.h	/^  complex& operator*= (const complex& r) { return __doaml (this, r); }$/;"	f	class:complex
operator *=	g++/std/ldcomplex.h	/^  complex& operator*= (const complex& r) { return __doaml (this, r); }$/;"	f	class:complex
operator +	g++/std/bastring.h	/^operator+ (charT lhs, const basic_string<charT, traits, Allocator>& rhs)$/;"	f
operator +	g++/std/bastring.h	/^operator+ (const basic_string <charT, traits, Allocator>& lhs, charT rhs)$/;"	f
operator +	g++/std/bastring.h	/^operator+ (const basic_string <charT, traits, Allocator>& lhs,$/;"	f
operator +	g++/std/bastring.h	/^operator+ (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs)$/;"	f
operator +	g++/std/bastring.h	/^operator+ (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)$/;"	f
operator +	g++/std/complext.h	/^operator + (_FLT x, const complex<_FLT>& y)$/;"	f
operator +	g++/std/complext.h	/^operator + (const complex<_FLT>& x)$/;"	f
operator +	g++/std/complext.h	/^operator + (const complex<_FLT>& x, _FLT y)$/;"	f
operator +	g++/std/complext.h	/^operator + (const complex<_FLT>& x, const complex<_FLT>& y)$/;"	f
operator +	g++/std/dcomplex.h	/^  friend inline complex operator + (const complex& x, double y)$/;"	f	class:complex
operator +	g++/std/dcomplex.h	/^  friend inline complex operator + (double x, const complex& y)$/;"	f	class:complex
operator +	g++/std/fcomplex.h	/^  friend inline complex operator + (const complex& x, float y)$/;"	f	class:complex
operator +	g++/std/fcomplex.h	/^  friend inline complex operator + (float x, const complex& y)$/;"	f	class:complex
operator +	g++/std/ldcomplex.h	/^  friend inline complex operator + (const complex& x, long double y)$/;"	f	class:complex
operator +	g++/std/ldcomplex.h	/^  friend inline complex operator + (long double x, const complex& y)$/;"	f	class:complex
operator +	g++/stl_bvector.h	/^  const_iterator operator+(difference_type i) const {$/;"	f	struct:__bit_const_iterator
operator +	g++/stl_bvector.h	/^  iterator operator+(difference_type i) const {$/;"	f	struct:__bit_iterator
operator +	g++/stl_deque.h	/^	self operator+(difference_type n) const {$/;"	f	struct:std::__deque_iterator
operator +	g++/stl_iterator.h	/^  self operator+(Distance n) const {$/;"	f	class:reverse_iterator
operator +	g++/stl_iterator.h	/^  self operator+(difference_type n) const {$/;"	f	class:reverse_iterator
operator +	g++/stl_iterator.h	/^operator+(Dist n, const reverse_iterator<RandomAccessIter, T, Ref, Dist>& x) {$/;"	f
operator +	g++/stl_iterator.h	/^operator+(reverse_iterator<Iterator>::difference_type n,$/;"	f
operator +	g++/stl_rope.h	/^operator+ (const rope<charT,Alloc> &left, charT right) {$/;"	f
operator +	g++/stl_rope.h	/^operator+ (const rope<charT,Alloc> &left,$/;"	f
operator +	g++/stl_rope.h	/^operator+(const __rope_const_iterator<charT,Alloc> & x,$/;"	f
operator +	g++/stl_rope.h	/^operator+(const __rope_iterator<charT,Alloc> & x,$/;"	f
operator +	g++/stl_rope.h	/^operator+(ptrdiff_t n,$/;"	f
operator ++	g++/stl_bvector.h	/^  const_iterator operator++(int) {$/;"	f	struct:__bit_const_iterator
operator ++	g++/stl_bvector.h	/^  const_iterator& operator++() {$/;"	f	struct:__bit_const_iterator
operator ++	g++/stl_bvector.h	/^  iterator operator++(int) {$/;"	f	struct:__bit_iterator
operator ++	g++/stl_bvector.h	/^  iterator& operator++() {$/;"	f	struct:__bit_iterator
operator ++	g++/stl_deque.h	/^	self operator++(int)  {$/;"	f	struct:std::__deque_iterator
operator ++	g++/stl_deque.h	/^	self& operator++() $/;"	f	struct:std::__deque_iterator
operator ++	g++/stl_hashtable.h	/^__hashtable_const_iterator<V, K, HF, ExK, EqK, A>::operator++()$/;"	f	class:__hashtable_const_iterator
operator ++	g++/stl_hashtable.h	/^__hashtable_const_iterator<V, K, HF, ExK, EqK, A>::operator++(int)$/;"	f	class:__hashtable_const_iterator
operator ++	g++/stl_hashtable.h	/^__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++()$/;"	f	class:__hashtable_iterator
operator ++	g++/stl_hashtable.h	/^__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++(int)$/;"	f	class:__hashtable_iterator
operator ++	g++/stl_iterator.h	/^  back_insert_iterator<Container>& operator++() { return *this; }$/;"	f	class:back_insert_iterator
operator ++	g++/stl_iterator.h	/^  back_insert_iterator<Container>& operator++(int) { return *this; }$/;"	f	class:back_insert_iterator
operator ++	g++/stl_iterator.h	/^  front_insert_iterator<Container>& operator++() { return *this; }$/;"	f	class:front_insert_iterator
operator ++	g++/stl_iterator.h	/^  front_insert_iterator<Container>& operator++(int) { return *this; }$/;"	f	class:front_insert_iterator
operator ++	g++/stl_iterator.h	/^  insert_iterator<Container>& operator++() { return *this; }$/;"	f	class:insert_iterator
operator ++	g++/stl_iterator.h	/^  insert_iterator<Container>& operator++(int) { return *this; }$/;"	f	class:insert_iterator
operator ++	g++/stl_iterator.h	/^  istream_iterator<T, Distance> operator++(int)  {$/;"	f	class:istream_iterator
operator ++	g++/stl_iterator.h	/^  istream_iterator<T, Distance>& operator++() { $/;"	f	class:istream_iterator
operator ++	g++/stl_iterator.h	/^  ostream_iterator<T>& operator++() { return *this; } $/;"	f	class:ostream_iterator
operator ++	g++/stl_iterator.h	/^  ostream_iterator<T>& operator++(int) { return *this; } $/;"	f	class:ostream_iterator
operator ++	g++/stl_iterator.h	/^  self operator++(int) {$/;"	f	class:reverse_bidirectional_iterator
operator ++	g++/stl_iterator.h	/^  self operator++(int) {$/;"	f	class:reverse_iterator
operator ++	g++/stl_iterator.h	/^  self& operator++() {$/;"	f	class:reverse_bidirectional_iterator
operator ++	g++/stl_iterator.h	/^  self& operator++() {$/;"	f	class:reverse_iterator
operator ++	g++/stl_list.h	/^	self operator++(int){ \/\/$/;"	f	struct:std::__list_iterator
operator ++	g++/stl_list.h	/^	self& operator++(){ \/\/$/;"	f	struct:std::__list_iterator
operator ++	g++/stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T> operator++(int) {$/;"	f	class:raw_storage_iterator
operator ++	g++/stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T>& operator++() {$/;"	f	class:raw_storage_iterator
operator ++	g++/stl_rope.h	/^	sequence_buffer& operator++() { return *this; }$/;"	f	class:sequence_buffer
operator ++	g++/stl_rope.h	/^	sequence_buffer& operator++(int) { return *this; }$/;"	f	class:sequence_buffer
operator ++	g++/stl_rope.h	/^    __rope_const_iterator operator++(int) {$/;"	f	class:__rope_const_iterator
operator ++	g++/stl_rope.h	/^    __rope_const_iterator& operator++() {$/;"	f	class:__rope_const_iterator
operator ++	g++/stl_rope.h	/^    __rope_iterator operator++(int) {$/;"	f	class:__rope_iterator
operator ++	g++/stl_rope.h	/^    __rope_iterator& operator++() {$/;"	f	class:__rope_iterator
operator ++	g++/stl_slist.h	/^	self operator++(int){$/;"	f	struct:std::__slist_iterator
operator ++	g++/stl_slist.h	/^	self& operator++(){$/;"	f	struct:std::__slist_iterator
operator ++	g++/stl_tree.h	/^	self operator++(int) {$/;"	f	struct:__rb_tree_iterator
operator ++	g++/stl_tree.h	/^	self& operator++() { increment(); return *this; }$/;"	f	struct:__rb_tree_iterator
operator +=	g++/std/bastring.h	/^	basic_string& operator+= (charT c){ return append (1, c); }$/;"	f	class:basic_string
operator +=	g++/std/bastring.h	/^	basic_string& operator+= (const basic_string& rhs){ return append (rhs); }$/;"	f	class:basic_string
operator +=	g++/std/bastring.h	/^	basic_string& operator+= (const charT* s){ return append (s); }$/;"	f	class:basic_string
operator +=	g++/std/complext.h	/^complex<_FLT>::operator += (const complex<_FLT>& r)$/;"	f	class:complex
operator +=	g++/std/dcomplex.h	/^  complex& operator+= (const complex& r) { return __doapl (this, r); }$/;"	f	class:complex
operator +=	g++/std/fcomplex.h	/^  complex& operator+= (const complex& r) { return __doapl (this, r); }$/;"	f	class:complex
operator +=	g++/std/ldcomplex.h	/^  complex& operator+= (const complex& r) { return __doapl (this, r); }$/;"	f	class:complex
operator +=	g++/stl_bvector.h	/^  const_iterator& operator+=(difference_type i) {$/;"	f	struct:__bit_const_iterator
operator +=	g++/stl_bvector.h	/^  iterator& operator+=(difference_type i) {$/;"	f	struct:__bit_iterator
operator +=	g++/stl_deque.h	/^	self& operator+=(difference_type n) {$/;"	f	struct:std::__deque_iterator
operator +=	g++/stl_iterator.h	/^  self& operator+=(Distance n) {$/;"	f	class:reverse_iterator
operator +=	g++/stl_iterator.h	/^  self& operator+=(difference_type n) {$/;"	f	class:reverse_iterator
operator +=	g++/stl_rope.h	/^    __rope_const_iterator& operator+=(ptrdiff_t n) {$/;"	f	class:__rope_const_iterator
operator +=	g++/stl_rope.h	/^    __rope_iterator& operator+=(difference_type n) {$/;"	f	class:__rope_iterator
operator +=	g++/stl_rope.h	/^operator+= (rope<charT,Alloc> &left, charT right) {$/;"	f
operator +=	g++/stl_rope.h	/^operator+= (rope<charT,Alloc> &left,$/;"	f
operator -	g++/std/complext.h	/^operator - (_FLT x, const complex<_FLT>& y)$/;"	f
operator -	g++/std/complext.h	/^operator - (const complex<_FLT>& x)$/;"	f
operator -	g++/std/complext.h	/^operator - (const complex<_FLT>& x, _FLT y)$/;"	f
operator -	g++/std/complext.h	/^operator - (const complex<_FLT>& x, const complex<_FLT>& y)$/;"	f
operator -	g++/std/dcomplex.h	/^  friend inline complex operator - (const complex& x, double y)$/;"	f	class:complex
operator -	g++/std/dcomplex.h	/^  friend inline complex operator - (double x, const complex& y)$/;"	f	class:complex
operator -	g++/std/fcomplex.h	/^  friend inline complex operator - (const complex& x, float y)$/;"	f	class:complex
operator -	g++/std/fcomplex.h	/^  friend inline complex operator - (float x, const complex& y)$/;"	f	class:complex
operator -	g++/std/ldcomplex.h	/^  friend inline complex operator - (const complex& x, long double y)$/;"	f	class:complex
operator -	g++/std/ldcomplex.h	/^  friend inline complex operator - (long double x, const complex& y)$/;"	f	class:complex
operator -	g++/stl_bvector.h	/^  const_iterator operator-(difference_type i) const {$/;"	f	struct:__bit_const_iterator
operator -	g++/stl_bvector.h	/^  difference_type operator-(const_iterator x) const {$/;"	f	struct:__bit_const_iterator
operator -	g++/stl_bvector.h	/^  difference_type operator-(iterator x) const {$/;"	f	struct:__bit_iterator
operator -	g++/stl_bvector.h	/^  iterator operator-(difference_type i) const {$/;"	f	struct:__bit_iterator
operator -	g++/stl_deque.h	/^	difference_type operator-(const self& x) const $/;"	f	struct:std::__deque_iterator
operator -	g++/stl_deque.h	/^	self operator-(difference_type n) const $/;"	f	struct:std::__deque_iterator
operator -	g++/stl_iterator.h	/^  self operator-(Distance n) const {$/;"	f	class:reverse_iterator
operator -	g++/stl_iterator.h	/^  self operator-(difference_type n) const {$/;"	f	class:reverse_iterator
operator -	g++/stl_iterator.h	/^inline Distance operator-(const reverse_iterator<RandomAccessIterator, T,$/;"	f
operator -	g++/stl_iterator.h	/^operator-(const reverse_iterator<Iterator>& x, $/;"	f
operator -	g++/stl_rope.h	/^inline ptrdiff_t operator-(const __rope_const_iterator<charT,Alloc> & x,$/;"	f
operator -	g++/stl_rope.h	/^inline ptrdiff_t operator-(const __rope_iterator<charT,Alloc> & x,$/;"	f
operator -	g++/stl_rope.h	/^operator-(const __rope_const_iterator<charT,Alloc> & x,$/;"	f
operator -	g++/stl_rope.h	/^operator-(const __rope_iterator<charT,Alloc> & x,$/;"	f
operator --	g++/stl_bvector.h	/^  const_iterator operator--(int) {$/;"	f	struct:__bit_const_iterator
operator --	g++/stl_bvector.h	/^  const_iterator& operator--() {$/;"	f	struct:__bit_const_iterator
operator --	g++/stl_bvector.h	/^  iterator operator--(int) {$/;"	f	struct:__bit_iterator
operator --	g++/stl_bvector.h	/^  iterator& operator--() {$/;"	f	struct:__bit_iterator
operator --	g++/stl_deque.h	/^	self operator--(int) {$/;"	f	struct:std::__deque_iterator
operator --	g++/stl_deque.h	/^	self& operator--() {$/;"	f	struct:std::__deque_iterator
operator --	g++/stl_iterator.h	/^  self operator--(int) {$/;"	f	class:reverse_bidirectional_iterator
operator --	g++/stl_iterator.h	/^  self operator--(int) {$/;"	f	class:reverse_iterator
operator --	g++/stl_iterator.h	/^  self& operator--() {$/;"	f	class:reverse_bidirectional_iterator
operator --	g++/stl_iterator.h	/^  self& operator--() {$/;"	f	class:reverse_iterator
operator --	g++/stl_list.h	/^	self operator--(int) { $/;"	f	struct:std::__list_iterator
operator --	g++/stl_list.h	/^	self& operator--() { $/;"	f	struct:std::__list_iterator
operator --	g++/stl_rope.h	/^    __rope_const_iterator operator--(int) {$/;"	f	class:__rope_const_iterator
operator --	g++/stl_rope.h	/^    __rope_const_iterator& operator--() {$/;"	f	class:__rope_const_iterator
operator --	g++/stl_rope.h	/^    __rope_iterator operator--(int) {$/;"	f	class:__rope_iterator
operator --	g++/stl_rope.h	/^    __rope_iterator& operator--() {$/;"	f	class:__rope_iterator
operator --	g++/stl_tree.h	/^	self operator--(int) {$/;"	f	struct:__rb_tree_iterator
operator --	g++/stl_tree.h	/^	self& operator--() { decrement(); return *this; }$/;"	f	struct:__rb_tree_iterator
operator -=	g++/std/complext.h	/^complex<_FLT>::operator -= (const complex<_FLT>& r)$/;"	f	class:complex
operator -=	g++/std/dcomplex.h	/^  complex& operator-= (const complex& r) { return __doami (this, r); }$/;"	f	class:complex
operator -=	g++/std/fcomplex.h	/^  complex& operator-= (const complex& r) { return __doami (this, r); }$/;"	f	class:complex
operator -=	g++/std/ldcomplex.h	/^  complex& operator-= (const complex& r) { return __doami (this, r); }$/;"	f	class:complex
operator -=	g++/stl_bvector.h	/^  const_iterator& operator-=(difference_type i) {$/;"	f	struct:__bit_const_iterator
operator -=	g++/stl_bvector.h	/^  iterator& operator-=(difference_type i) {$/;"	f	struct:__bit_iterator
operator -=	g++/stl_deque.h	/^	self& operator-=(difference_type n) { return *this += -n; }$/;"	f	struct:std::__deque_iterator
operator -=	g++/stl_iterator.h	/^  self& operator-=(Distance n) {$/;"	f	class:reverse_iterator
operator -=	g++/stl_iterator.h	/^  self& operator-=(difference_type n) {$/;"	f	class:reverse_iterator
operator -=	g++/stl_rope.h	/^    __rope_const_iterator& operator-=(ptrdiff_t n) {$/;"	f	class:__rope_const_iterator
operator -=	g++/stl_rope.h	/^    __rope_iterator& operator-=(difference_type n) {$/;"	f	class:__rope_iterator
operator ->	g++/stl_deque.h	/^	pointer operator->() const { return &(operator*()); }$/;"	f	struct:std::__deque_iterator
operator ->	g++/stl_hashtable.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__hashtable_const_iterator
operator ->	g++/stl_hashtable.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__hashtable_iterator
operator ->	g++/stl_iterator.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	class:istream_iterator
operator ->	g++/stl_iterator.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	class:reverse_bidirectional_iterator
operator ->	g++/stl_iterator.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	class:reverse_iterator
operator ->	g++/stl_list.h	/^	pointer operator->() const { 	$/;"	f	struct:std::__list_iterator
operator ->	g++/stl_rope.h	/^    __rope_RopeBase<charT,Alloc> * operator->() { return ptr; }$/;"	f	struct:__rope_self_destruct_ptr
operator ->	g++/stl_slist.h	/^	pointer operator->() const { $/;"	f	struct:std::__slist_iterator
operator ->	g++/stl_tree.h	/^	pointer operator->() const { return &(operator*()); }$/;"	f	struct:__rb_tree_iterator
operator /	g++/std/complext.cc	/^operator \/ (FLOAT x, const complex<FLOAT>& y)$/;"	f
operator /	g++/std/complext.cc	/^operator \/ (const complex<FLOAT>& x, const complex<FLOAT>& y)$/;"	f
operator /	g++/std/complext.h	/^operator \/ (const complex<_FLT>& x, _FLT y)$/;"	f
operator /	g++/std/dcomplex.h	/^  friend inline complex operator \/ (const complex& x, double y)$/;"	f	class:complex
operator /	g++/std/dcomplex.h	/^  friend inline complex operator \/ (double x, const complex& y)$/;"	f	class:complex
operator /	g++/std/fcomplex.h	/^  friend inline complex operator \/ (const complex& x, float y)$/;"	f	class:complex
operator /	g++/std/fcomplex.h	/^  friend inline complex operator \/ (float x, const complex& y)$/;"	f	class:complex
operator /	g++/std/ldcomplex.h	/^  friend inline complex operator \/ (const complex& x, long double y)$/;"	f	class:complex
operator /	g++/std/ldcomplex.h	/^  friend inline complex operator \/ (long double x, const complex& y)$/;"	f	class:complex
operator /=	g++/std/complext.h	/^complex<_FLT>::operator \/= (const complex<_FLT>& r)$/;"	f	class:complex
operator /=	g++/std/dcomplex.h	/^  complex& operator\/= (const complex& r) { return __doadv (this, r); }$/;"	f	class:complex
operator /=	g++/std/fcomplex.h	/^  complex& operator\/= (const complex& r) { return __doadv (this, r); }$/;"	f	class:complex
operator /=	g++/std/ldcomplex.h	/^  complex& operator\/= (const complex& r) { return __doadv (this, r); }$/;"	f	class:complex
operator <	g++/std/bastring.h	/^operator< (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)$/;"	f
operator <	g++/std/bastring.h	/^operator< (const basic_string <charT, traits, Allocator>& lhs,$/;"	f
operator <	g++/std/bastring.h	/^operator< (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)$/;"	f
operator <	g++/stl_bvector.h	/^  bool operator<(const __bit_reference& x) const {$/;"	f	struct:__bit_reference
operator <	g++/stl_bvector.h	/^  bool operator<(const_iterator x) const {$/;"	f	struct:__bit_const_iterator
operator <	g++/stl_bvector.h	/^  bool operator<(iterator x) const {$/;"	f	struct:__bit_iterator
operator <	g++/stl_bvector.h	/^inline bool operator<(const bit_vector& x, const bit_vector& y) {$/;"	f
operator <	g++/stl_deque.h	/^	bool operator<(const self& x)  const { return (node == x.node) ? (cur < x.cur) : (node < x.node);}$/;"	f	struct:std::__deque_iterator
operator <	g++/stl_deque.h	/^bool operator<(const deque<T, Alloc, BufSiz>& x,const deque<T, Alloc, BufSiz>& y) $/;"	f	namespace:std
operator <	g++/stl_iterator.h	/^inline bool operator<(const reverse_iterator<Iterator>& x, $/;"	f
operator <	g++/stl_iterator.h	/^inline bool operator<(const reverse_iterator<RandomAccessIterator, T,$/;"	f
operator <	g++/stl_list.h	/^inline bool operator<(const list<T, Alloc>& x, const list<T, Alloc>& y) {$/;"	f	namespace:std
operator <	g++/stl_map.h	/^inline bool operator<(const map<Key, T, Compare, Alloc>& x, $/;"	f
operator <	g++/stl_multimap.h	/^inline bool operator<(const multimap<Key, T, Compare, Alloc>& x, $/;"	f
operator <	g++/stl_multiset.h	/^inline bool operator<(const multiset<Key, Compare, Alloc>& x, $/;"	f
operator <	g++/stl_pair.h	/^inline bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y) { $/;"	f
operator <	g++/stl_queue.h	/^bool operator<(const queue<T, Sequence>& x, const queue<T, Sequence>& y) $/;"	f
operator <	g++/stl_rope.h	/^inline bool operator< (const __rope_const_iterator<charT,Alloc> & x,$/;"	f
operator <	g++/stl_rope.h	/^inline bool operator< (const __rope_iterator<charT,Alloc> & x,$/;"	f
operator <	g++/stl_rope.h	/^operator< (const rope<charT,Alloc> &left, const rope<charT,Alloc> &right) {$/;"	f
operator <	g++/stl_set.h	/^inline bool operator<(const set<Key, Compare, Alloc>& x, $/;"	f
operator <	g++/stl_slist.h	/^inline bool operator<(const slist<T, Alloc>& L1, const slist<T, Alloc>& L2)$/;"	f	namespace:std
operator <	g++/stl_stack.h	/^bool operator<(const stack<T, Sequence>& x, const stack<T, Sequence>& y) {$/;"	f
operator <	g++/stl_tree.h	/^inline bool operator<(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, $/;"	f
operator <	g++/stl_vector.h	/^operator < (const vector<T, Alloc>& x, const vector<T, Alloc>& y) $/;"	f
operator <<	g++/iomanip.h	/^inline ostream& operator<<(ostream& o, const omanip<TP>& m)$/;"	f
operator <<	g++/iomanip.h	/^inline ostream& operator<<(ostream& o, const smanip<TP>& m)$/;"	f
operator <<	g++/iostream.h	/^    ostream& operator<<(__manip func) {(*func)(*this); return *this;}$/;"	f	class:ostream
operator <<	g++/iostream.h	/^    ostream& operator<<(__omanip func) { return (*func)(*this); }$/;"	f	class:ostream
operator <<	g++/iostream.h	/^    ostream& operator<<(bool b) { return operator<<((int)b); }$/;"	f	class:ostream
operator <<	g++/iostream.h	/^    ostream& operator<<(const signed char *s)$/;"	f	class:ostream
operator <<	g++/iostream.h	/^    ostream& operator<<(const unsigned char *s)$/;"	f	class:ostream
operator <<	g++/iostream.h	/^    ostream& operator<<(float n) { return operator<<((double)n); }$/;"	f	class:ostream
operator <<	g++/iostream.h	/^    ostream& operator<<(long double n) { return operator<<((double)n); }$/;"	f	class:ostream
operator <<	g++/iostream.h	/^    ostream& operator<<(short n) {return operator<<((int)n);}$/;"	f	class:ostream
operator <<	g++/iostream.h	/^    ostream& operator<<(signed char c) { return (*this) << (char)c; }$/;"	f	class:ostream
operator <<	g++/iostream.h	/^    ostream& operator<<(unsigned char c) { return (*this) << (char)c; }$/;"	f	class:ostream
operator <<	g++/iostream.h	/^    ostream& operator<<(unsigned short n) {return operator<<((unsigned int)n);}$/;"	f	class:ostream
operator <<	g++/ropeimpl.h	/^ostream& operator<< (ostream& o, const rope<charT, Alloc>& r)$/;"	f
operator <<	g++/std/bastring.cc	/^operator<<(ostream &o, const basic_string<charT, traits, Allocator>& s)$/;"	f
operator <<	g++/std/complext.cc	/^operator << (ostream& os, const complex<FLOAT>& x)$/;"	f
operator <=	g++/std/bastring.h	/^operator<= (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)$/;"	f
operator <=	g++/std/bastring.h	/^operator<= (const basic_string <charT, traits, Allocator>& lhs,$/;"	f
operator <=	g++/std/bastring.h	/^operator<= (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)$/;"	f
operator <=	g++/stl_relops.h	/^inline bool operator<=(const T& x, const T& y) {$/;"	f
operator =	g++/iostream.h	/^  _IO_istream_withassign& operator=(_IO_istream_withassign& rhs)$/;"	f	class:_IO_istream_withassign
operator =	g++/iostream.h	/^  _IO_ostream_withassign& operator=(_IO_ostream_withassign& rhs)$/;"	f	class:_IO_ostream_withassign
operator =	g++/ropeimpl.h	/^__rope_charT_ref_proxy<charT, Alloc>::operator= (charT c) {$/;"	f	class:__rope_charT_ref_proxy
operator =	g++/std/bastring.h	/^	basic_string& operator= (charT c) { return assign (1, c); }$/;"	f	class:basic_string
operator =	g++/std/bastring.h	/^	basic_string& operator= (const basic_string& str)$/;"	f	class:basic_string
operator =	g++/std/bastring.h	/^	basic_string& operator= (const charT* s){ return assign (s); }$/;"	f	class:basic_string
operator =	g++/stl_bvector.h	/^  __BVECTOR& operator=(const __BVECTOR& x) {$/;"	f	class:vector
operator =	g++/stl_bvector.h	/^  __bit_reference& operator=(bool x) {$/;"	f	struct:__bit_reference
operator =	g++/stl_bvector.h	/^  __bit_reference& operator=(const __bit_reference& x) { return *this = bool(x); }$/;"	f	struct:__bit_reference
operator =	g++/stl_deque.h	/^	deque& operator= (const deque& x)$/;"	f	class:std::deque
operator =	g++/stl_hashtable.h	/^  hashtable& operator= (const hashtable& ht)$/;"	f	class:hashtable
operator =	g++/stl_iterator.h	/^  operator=(const typename Container::value_type& value) { $/;"	f	class:back_insert_iterator
operator =	g++/stl_iterator.h	/^  operator=(const typename Container::value_type& value) { $/;"	f	class:front_insert_iterator
operator =	g++/stl_iterator.h	/^  operator=(const typename Container::value_type& value) { $/;"	f	class:insert_iterator
operator =	g++/stl_iterator.h	/^  ostream_iterator<T>& operator=(const T& value) { $/;"	f	class:ostream_iterator
operator =	g++/stl_list.h	/^list<T, Alloc>& list<T, Alloc>::operator=(const list<T, Alloc>& x){$/;"	f	class:std::list
operator =	g++/stl_map.h	/^  map<Key, T, Compare, Alloc>& operator=(const map<Key, T, Compare, Alloc>& x)$/;"	f	class:map
operator =	g++/stl_multimap.h	/^  operator=(const multimap<Key, T, Compare, Alloc>& x) {$/;"	f	class:multimap
operator =	g++/stl_multiset.h	/^  operator=(const multiset<Key, Compare, Alloc>& x) {$/;"	f	class:multiset
operator =	g++/stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T>& operator=(const T& element) {$/;"	f	class:raw_storage_iterator
operator =	g++/stl_rope.h	/^	rope& operator=(const rope& x)$/;"	f	class:rope
operator =	g++/stl_rope.h	/^	sequence_buffer& operator= (const sequence_buffer& x) {$/;"	f	class:sequence_buffer
operator =	g++/stl_rope.h	/^	sequence_buffer& operator= (sequence_buffer& x) {$/;"	f	class:sequence_buffer
operator =	g++/stl_rope.h	/^	sequence_buffer& operator=(const value_type& rhs)$/;"	f	class:sequence_buffer
operator =	g++/stl_rope.h	/^    __rope_charT_ptr_proxy& operator= (const __rope_charT_ptr_proxy& x) {$/;"	f	class:__rope_charT_ptr_proxy
operator =	g++/stl_rope.h	/^    __rope_charT_ref_proxy& operator= (const __rope_charT_ref_proxy& c) {$/;"	f	class:__rope_charT_ref_proxy
operator =	g++/stl_rope.h	/^    __rope_const_iterator& operator= (const __rope_const_iterator & x) {$/;"	f	class:__rope_const_iterator
operator =	g++/stl_rope.h	/^    __rope_iterator& operator= (const __rope_iterator & x) {$/;"	f	class:__rope_iterator
operator =	g++/stl_rope.h	/^    __rope_self_destruct_ptr & operator= (__rope_RopeBase<charT,Alloc> * x)$/;"	f	struct:__rope_self_destruct_ptr
operator =	g++/stl_set.h	/^  set<Key, Compare, Alloc>& operator=(const set<Key, Compare, Alloc>& x) { $/;"	f	class:set
operator =	g++/stl_slist.h	/^slist<T,Alloc>::operator=(const slist<T, Alloc>& L){$/;"	f	class:std::slist
operator =	g++/stl_tempbuf.h	/^  void operator=(const temporary_buffer&) {}$/;"	f	class:temporary_buffer
operator =	g++/stl_tree.h	/^operator=(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x) {$/;"	f	class:rb_tree
operator =	g++/stl_vector.h	/^vector<T, Alloc>::operator=(const vector<T, Alloc>& x) $/;"	f	class:vector
operator ==	g++/std/bastring.h	/^operator== (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)$/;"	f
operator ==	g++/std/bastring.h	/^operator== (const basic_string <charT, traits, Allocator>& lhs,$/;"	f
operator ==	g++/std/bastring.h	/^operator== (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)$/;"	f
operator ==	g++/std/complext.h	/^operator == (_FLT x, const complex<_FLT>& y)$/;"	f
operator ==	g++/std/complext.h	/^operator == (const complex<_FLT>& x, _FLT y)$/;"	f
operator ==	g++/std/complext.h	/^operator == (const complex<_FLT>& x, const complex<_FLT>& y)$/;"	f
operator ==	g++/std/dcomplex.h	/^  friend inline bool operator == (const complex& x, double y)$/;"	f	class:complex
operator ==	g++/std/dcomplex.h	/^  friend inline bool operator == (double x, const complex& y)$/;"	f	class:complex
operator ==	g++/std/fcomplex.h	/^  friend inline bool operator == (const complex& x, float y)$/;"	f	class:complex
operator ==	g++/std/fcomplex.h	/^  friend inline bool operator == (float x, const complex& y)$/;"	f	class:complex
operator ==	g++/std/ldcomplex.h	/^  friend inline bool operator == (const complex& x, long double y)$/;"	f	class:complex
operator ==	g++/std/ldcomplex.h	/^  friend inline bool operator == (long double x, const complex& y)$/;"	f	class:complex
operator ==	g++/stl_bvector.h	/^  bool operator==(const __bit_reference& x) const {$/;"	f	struct:__bit_reference
operator ==	g++/stl_bvector.h	/^  bool operator==(const const_iterator& x) const {$/;"	f	struct:__bit_const_iterator
operator ==	g++/stl_bvector.h	/^  bool operator==(const iterator& x) const {$/;"	f	struct:__bit_iterator
operator ==	g++/stl_bvector.h	/^inline bool operator==(const bit_vector& x, const bit_vector& y) {$/;"	f
operator ==	g++/stl_deque.h	/^	bool operator==(const self& x) const { return cur == x.cur; }$/;"	f	struct:std::__deque_iterator
operator ==	g++/stl_deque.h	/^bool operator==(const deque<T, Alloc, BufSiz>& x, const deque<T, Alloc, BufSiz>& y) $/;"	f	namespace:std
operator ==	g++/stl_hash_map.h	/^inline bool operator==(const hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1,$/;"	f
operator ==	g++/stl_hash_map.h	/^inline bool operator==(const hash_multimap<Key, T, HF, EqKey, Alloc>& hm1,$/;"	f
operator ==	g++/stl_hash_set.h	/^inline bool operator==(const hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs1,$/;"	f
operator ==	g++/stl_hash_set.h	/^inline bool operator==(const hash_set<Value, HashFcn, EqualKey, Alloc>& hs1,$/;"	f
operator ==	g++/stl_hashtable.h	/^  bool operator==(const const_iterator& it) const { return cur == it.cur; }$/;"	f	struct:__hashtable_const_iterator
operator ==	g++/stl_hashtable.h	/^  bool operator==(const iterator& it) const { return cur == it.cur; }$/;"	f	struct:__hashtable_iterator
operator ==	g++/stl_hashtable.h	/^bool operator==(const hashtable<V, K, HF, Ex, Eq, A>& ht1,$/;"	f
operator ==	g++/stl_iterator.h	/^inline bool operator==($/;"	f
operator ==	g++/stl_iterator.h	/^inline bool operator==(const istream_iterator<T, Distance>& x,$/;"	f
operator ==	g++/stl_iterator.h	/^inline bool operator==(const reverse_iterator<Iterator>& x, $/;"	f
operator ==	g++/stl_iterator.h	/^inline bool operator==(const reverse_iterator<RandomAccessIterator, T,$/;"	f
operator ==	g++/stl_list.h	/^	bool operator==(const self& x) const { $/;"	f	struct:std::__list_iterator
operator ==	g++/stl_list.h	/^inline bool operator==(const list<T,Alloc>& x, const list<T,Alloc>& y) $/;"	f	namespace:std
operator ==	g++/stl_map.h	/^inline bool operator==(const map<Key, T, Compare, Alloc>& x, $/;"	f
operator ==	g++/stl_multimap.h	/^inline bool operator==(const multimap<Key, T, Compare, Alloc>& x, $/;"	f
operator ==	g++/stl_multiset.h	/^inline bool operator==(const multiset<Key, Compare, Alloc>& x, $/;"	f
operator ==	g++/stl_pair.h	/^inline bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y) { $/;"	f
operator ==	g++/stl_queue.h	/^bool operator==(const queue<T, Sequence>& x, const queue<T, Sequence>& y) $/;"	f
operator ==	g++/stl_rope.h	/^inline bool operator== (const __rope_charT_ptr_proxy<charT,Alloc> & x,$/;"	f
operator ==	g++/stl_rope.h	/^inline bool operator== (const __rope_const_iterator<charT,Alloc> & x,$/;"	f
operator ==	g++/stl_rope.h	/^inline bool operator== (const __rope_iterator<charT,Alloc> & x,$/;"	f
operator ==	g++/stl_rope.h	/^operator== (const rope<charT,Alloc> &left, const rope<charT,Alloc> &right) {$/;"	f
operator ==	g++/stl_set.h	/^inline bool operator==(const set<Key, Compare, Alloc>& x, $/;"	f
operator ==	g++/stl_slist.h	/^	bool operator==(const __slist_iterator_base& x) const {$/;"	f	struct:std::__slist_iterator_base
operator ==	g++/stl_slist.h	/^bool operator==(const slist<T, Alloc>& L1, const slist<T, Alloc>& L2)$/;"	f	namespace:std
operator ==	g++/stl_stack.h	/^bool operator==(const stack<T, Sequence>& x, const stack<T, Sequence>& y) {$/;"	f
operator ==	g++/stl_tree.h	/^inline bool operator==(const __rb_tree_base_iterator& x, const __rb_tree_base_iterator& y) $/;"	f
operator ==	g++/stl_tree.h	/^inline bool operator==(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, $/;"	f
operator ==	g++/stl_vector.h	/^operator == (const vector<T, Alloc>& x, const vector<T, Alloc>& y) $/;"	f
operator >	g++/std/bastring.h	/^operator> (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)$/;"	f
operator >	g++/std/bastring.h	/^operator> (const basic_string <charT, traits, Allocator>& lhs,$/;"	f
operator >	g++/std/bastring.h	/^operator> (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)$/;"	f
operator >	g++/stl_relops.h	/^inline bool operator>(const T& x, const T& y) {$/;"	f
operator >=	g++/std/bastring.h	/^operator>= (const basic_string <charT, traits, Allocator>& lhs, const charT* rhs)$/;"	f
operator >=	g++/std/bastring.h	/^operator>= (const basic_string <charT, traits, Allocator>& lhs,$/;"	f
operator >=	g++/std/bastring.h	/^operator>= (const charT* lhs, const basic_string <charT, traits, Allocator>& rhs)$/;"	f
operator >=	g++/stl_relops.h	/^inline bool operator>=(const T& x, const T& y) {$/;"	f
operator >>	g++/iomanip.h	/^inline istream& operator>>(istream& i, const imanip<TP>& m)$/;"	f
operator >>	g++/iomanip.h	/^inline istream& operator>>(istream& i, const smanip<TP>& m)$/;"	f
operator >>	g++/iostream.h	/^    istream& operator>>( __manip func) {(*func)(*this); return *this;}$/;"	f	class:istream
operator >>	g++/iostream.h	/^    istream& operator>>(__imanip func) { return (*func)(*this); }$/;"	f	class:istream
operator >>	g++/iostream.h	/^    istream& operator>>(signed char& c) {return operator>>((char&)c);}$/;"	f	class:istream
operator >>	g++/iostream.h	/^    istream& operator>>(signed char*p) { return operator>>((char*)p); }$/;"	f	class:istream
operator >>	g++/iostream.h	/^    istream& operator>>(unsigned char& c) {return operator>>((char&)c);}$/;"	f	class:istream
operator >>	g++/iostream.h	/^    istream& operator>>(unsigned char* p) { return operator>>((char*)p); }$/;"	f	class:istream
operator >>	g++/std/bastring.cc	/^operator>>(istream &is, basic_string <charT, traits, Allocator> &s)$/;"	f
operator >>	g++/std/complext.cc	/^operator >> (istream& is, complex<FLOAT>& x)$/;"	f
operator []	g++/std/bastring.h	/^		charT& operator[](size_t s) { return data()[s]; }$/;"	f	struct:basic_string::Rep
operator []	g++/std/bastring.h	/^	charT operator[](size_type pos) const$/;"	f	class:basic_string
operator []	g++/std/bastring.h	/^	reference operator[](size_type pos){ selfish(); return (*rep ())[pos]; }$/;"	f	class:basic_string
operator []	g++/stl_bvector.h	/^  const_reference operator[](difference_type i) { $/;"	f	struct:__bit_const_iterator
operator []	g++/stl_bvector.h	/^  const_reference operator[](size_type n) const {$/;"	f	class:vector
operator []	g++/stl_bvector.h	/^  reference operator[](difference_type i) { return *(*this + i); }$/;"	f	struct:__bit_iterator
operator []	g++/stl_bvector.h	/^  reference operator[](size_type n) {$/;"	f	class:vector
operator []	g++/stl_deque.h	/^	const_reference operator[](size_type n) const {return start[difference_type(n)];}$/;"	f	class:std::deque
operator []	g++/stl_deque.h	/^	reference operator[](difference_type n) const { return *(*this + n); }$/;"	f	struct:std::__deque_iterator
operator []	g++/stl_deque.h	/^	reference operator[](size_type n) { return start[difference_type(n)]; }$/;"	f	class:std::deque
operator []	g++/stl_hash_map.h	/^  T& operator[](const key_type& key) {$/;"	f	class:hash_map
operator []	g++/stl_iterator.h	/^  Reference operator[](Distance n) const { return *(*this + n); }$/;"	f	class:reverse_iterator
operator []	g++/stl_iterator.h	/^  reference operator[](difference_type n) const { return *(*this + n); }  $/;"	f	class:reverse_iterator
operator []	g++/stl_map.h	/^  T& operator[](const key_type& k) {$/;"	f	class:map
operator []	g++/stl_rope.h	/^	    reference operator[] (size_type pos) {$/;"	f	class:rope
operator []	g++/stl_rope.h	/^	charT operator[] (size_type pos) const {$/;"	f	class:rope
operator []	g++/stl_rope.h	/^    reference operator[](ptrdiff_t n) {$/;"	f	class:__rope_iterator
operator []	g++/stl_rope.h	/^    reference operator[](size_t n) {$/;"	f	class:__rope_const_iterator
operator []	g++/stl_vector.h	/^	const_reference operator[](size_type n) const { return *(begin() + n); }$/;"	f	class:vector
operator []	g++/stl_vector.h	/^	reference operator[](size_type n) { 	return *(begin() + n); }$/;"	f	class:vector
operator __rope_RopeBase<charT,Alloc> *	g++/stl_rope.h	/^    operator __rope_RopeBase<charT,Alloc> *() { return ptr; }$/;"	f	struct:__rope_self_destruct_ptr
operator bool	g++/stl_bvector.h	/^  operator bool() const { return !(!(*p & mask)); }$/;"	f	struct:__bit_reference
operator charT	g++/ropeimpl.h	/^inline __rope_charT_ref_proxy<charT, Alloc>::operator charT () const$/;"	f	class:__rope_charT_ref_proxy
operator delete	g++/std/bastring.cc	/^operator delete(void * ptr)$/;"	f	class:basic_string::Rep
operator new	g++/std/bastring.cc	/^operator new (size_t s, size_t extra)$/;"	f	class:basic_string::Rep
operator void*	g++/streambuf.h	/^    operator void*() const { return fail() ? (void*)0 : (void*)(-1); }$/;"	f	class:ios
opfstream	g++/pfstream.h	/^class opfstream : public ofstream {$/;"	c
opfx	g++/iostream.h	/^    int opfx() {$/;"	f	class:ostream
or	include/iso646.h	11;"	d
or_eq	include/iso646.h	12;"	d
orelocation	bfd.h	/^   struct reloc_cache_entry **orelocation;$/;"	m	struct:sec	typeref:struct:sec::reloc_cache_entry
origin	bfd.h	/^    file_ptr origin;             $/;"	m	struct:_bfd
original_len	g++/stl_tempbuf.h	/^  ptrdiff_t original_len;$/;"	m	class:temporary_buffer
orl	bfd.h	/^struct orl {			\/* output ranlib *\/$/;"	s
osf_core_data	bfd.h	/^      struct osf_core_struct *osf_core_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::osf_core_struct
osfx	g++/iostream.h	/^    void osfx() { _IO_funlockfile(_strbuf);$/;"	f	class:ostream
ostdiostream	g++/stdiostream.h	/^  ostdiostream (FILE* __f) : ostream(), _file(__f) { init(&_file); }$/;"	f	class:ostdiostream
ostdiostream	g++/stdiostream.h	/^class ostdiostream : public ostream$/;"	c
ostream	g++/iostream.h	/^    ostream() { }$/;"	f	class:ostream
ostream	g++/iostream.h	/^class ostream : virtual public ios$/;"	c
ostream_iterator	g++/stl_iterator.h	/^  ostream_iterator(ostream& s) : stream(&s), string(0) {}$/;"	f	class:ostream_iterator
ostream_iterator	g++/stl_iterator.h	/^  ostream_iterator(ostream& s, const char* c) : stream(&s), string(c)  {}$/;"	f	class:ostream_iterator
ostream_iterator	g++/stl_iterator.h	/^class ostream_iterator {$/;"	c
ostreambuf	g++/iostream.h	/^    streambuf* ostreambuf() const { return _strbuf; }$/;"	f	class:ostream
ostrstream	g++/strstream.h	/^    ostrstream() { }$/;"	f	class:ostrstream
ostrstream	g++/strstream.h	/^    ostrstream(char *cp, int n, int mode=ios::out) :strstreambase(cp,n,mode){}$/;"	f	class:ostrstream
ostrstream	g++/strstream.h	/^class ostrstream : public strstreambase, public ostream {$/;"	c
otherValuePtr	tcl.h	/^	VOID *otherValuePtr;	\/*   - another, type-specific value *\/$/;"	m	union:Tcl_Obj::__anon54
out	g++/streambuf.h	/^	out = _IO_OUTPUT,$/;"	e	enum:ios::open_mode
out_waiting	g++/streambuf.h	/^    int out_waiting() { return _IO_write_ptr - _IO_write_base; }$/;"	f	struct:streambuf
output	g++/streambuf.h	/^    output = _IO_OUTPUT,$/;"	e	enum:open_mode
outputProc	tcl.h	/^    Tcl_DriverOutputProc *outputProc;	\/* Procedure to call for output$/;"	m	struct:Tcl_ChannelType
output_has_begun	bfd.h	/^    boolean output_has_begun;$/;"	m	struct:_bfd
output_iterator	g++/stl_iterator.h	/^struct output_iterator {$/;"	s
output_iterator_tag	g++/stl_iterator.h	/^struct output_iterator_tag {};            \/\/write only, only ++$/;"	s
output_offset	bfd.h	/^   bfd_vma output_offset;$/;"	m	struct:sec
output_section	bfd.h	/^   struct sec *output_section;$/;"	m	struct:sec	typeref:struct:sec::sec
outsymbols	bfd.h	/^    struct symbol_cache_entry  **outsymbols;             $/;"	m	struct:_bfd	typeref:struct:_bfd::symbol_cache_entry
overflow_arg_area	include/va-ppc.h	/^  char *overflow_arg_area;	\/* location on stack that holds the next$/;"	m	struct:__va_list_tag
owner	bfd.h	/^   bfd *owner;$/;"	m	struct:sec
p	bfd.h	/^      PTR p;$/;"	m	union:symbol_cache_entry::__anon37
p	bfdlink.h	/^	    } *p;$/;"	m	struct:bfd_link_hash_entry::__anon59::__anon63	typeref:struct:bfd_link_hash_entry::__anon59::__anon63::bfd_link_hash_common_entry
p	bfdlink.h	/^	  struct bfd_link_order_reloc *p;$/;"	m	struct:bfd_link_order::__anon64::__anon68	typeref:struct:bfd_link_order::__anon64::__anon68::bfd_link_order_reloc
p	g++/stl_bvector.h	/^  unsigned int* p;$/;"	m	struct:__bit_const_iterator
p	g++/stl_bvector.h	/^  unsigned int* p;$/;"	m	struct:__bit_iterator
p	g++/stl_bvector.h	/^  unsigned int* p;$/;"	m	struct:__bit_reference
padn	g++/streambuf.h	/^    streamsize padn(char pad, streamsize n) { return _IO_padn(this, pad, n); }$/;"	f	struct:streambuf
pair	g++/stl_pair.h	/^  pair() : first(T1()), second(T2()) {}$/;"	f	struct:pair
pair	g++/stl_pair.h	/^  pair(const T1& a, const T2& b) : first(a), second(b) {}$/;"	f	struct:pair
pair	g++/stl_pair.h	/^  pair(const pair<U1, U2>& p) : first(p.first), second(p.second) {}$/;"	f	struct:pair
pair	g++/stl_pair.h	/^struct pair {$/;"	s
pair_iterator_bool	g++/stl_set.h	/^  typedef  pair<iterator, bool> pair_iterator_bool; $/;"	t	class:set
parent	g++/stl_tree.h	/^	base_ptr 					 parent;$/;"	m	struct:__rb_tree_node_base
parent	g++/stl_tree.h	/^  static link_type& parent(base_ptr x) { return (link_type&)(x->parent); }$/;"	f	class:rb_tree
parent	g++/stl_tree.h	/^  static link_type& parent(link_type x) { return (link_type&)(x->parent); }$/;"	f	class:rb_tree
parentPtr	tcl.h	/^    struct Tcl_Namespace* parentPtr;$/;"	m	struct:Tcl_Namespace	typeref:struct:Tcl_Namespace::Tcl_Namespace
parentPtr	tk.h	/^    Tk_Window parentPtr;$/;"	m	struct:Tk_FakeWin
parseProc	tk.h	/^    Tk_OptionParseProc *parseProc;	\/* Procedure to call to parse an$/;"	m	struct:Tk_CustomOption
parsebuf	g++/parsestream.h	/^    parsebuf() { chain= NULL;$/;"	f	class:parsebuf
parsebuf	g++/parsestream.h	/^class parsebuf : public streambuf {$/;"	c
partial_inplace	bfd.h	/^  boolean partial_inplace;$/;"	m	struct:reloc_howto_struct
partial_sort	g++/stl_algo.h	/^inline void partial_sort(RandomAccessIterator first,$/;"	f
partial_sort_copy	g++/stl_algo.h	/^partial_sort_copy(InputIterator first, InputIterator last,$/;"	f
partial_sum	g++/stl_numeric.h	/^OutputIterator partial_sum(InputIterator first, InputIterator last,$/;"	f
partition	g++/stl_algo.h	/^BidirectionalIterator partition(BidirectionalIterator first,$/;"	f
pathName	tk.h	/^    char *pathName;$/;"	m	struct:Tk_FakeWin
path_cache_len	g++/stl_rope.h	/^    enum { path_cache_len = 4 }; \/\/ Must be <= 9.$/;"	e	enum:__rope_iterator_base::__anon11
path_cache_len	g++/stl_rope.h	/^    enum { path_cache_len = 4 }; \/\/ Must be <= 9.$/;"	e	enum:__rope_iterator_base::__anon82
path_directions	g++/stl_rope.h	/^    unsigned char path_directions;$/;"	m	class:__rope_iterator_base
path_end	g++/stl_rope.h	/^    const RopeBase * path_end[path_cache_len];$/;"	m	class:__rope_iterator_base
pattern	expect.h	/^	char *pattern;$/;"	m	struct:exp_case
pattern	g++/ropeimpl.h	/^	charT pattern;$/;"	m	class:__rope_find_char_char_consumer
pbase	g++/streambuf.h	/^    char* pbase() const { return _IO_write_base; }$/;"	f	struct:streambuf
pbump	g++/streambuf.h	/^    void pbump(int n) { _IO_write_ptr += n; }$/;"	f	struct:streambuf
pc_relative	bfd.h	/^  boolean pc_relative;$/;"	m	struct:reloc_howto_struct
pclose	g++/iostdio.h	109;"	d
pcount	g++/strstream.h	/^    _IO_ssize_t pcount() { return ((strstreambuf*)_strbuf)->pcount(); }$/;"	f	class:ostrstream
pcount	g++/strstream.h	/^    _IO_ssize_t pcount() { return ((strstreambuf*)_strbuf)->pcount(); }$/;"	f	class:strstream
pcrel_offset	bfd.h	/^  boolean pcrel_offset;$/;"	m	struct:reloc_howto_struct
pe_obj_data	bfd.h	/^      struct pe_tdata *pe_obj_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::pe_tdata
perror	g++/iostdio.h	82;"	d
pitch	tk.h	/^    int		pitch;		\/* Address difference between corresponding$/;"	m	struct:Tk_PhotoImageBlock
pixelPtr	tk.h	/^    unsigned char *pixelPtr;	\/* Pointer to the first pixel. *\/$/;"	m	struct:Tk_PhotoImageBlock
pixelSize	tk.h	/^    int		pixelSize;	\/* Address difference between successive$/;"	m	struct:Tk_PhotoImageBlock
plus	g++/stl_function.h	/^struct plus : public binary_function<T, T, T> {$/;"	s
pointProc	tk.h	/^    Tk_ItemPointProc *pointProc;	\/* Computes distance from item to$/;"	m	struct:Tk_ItemType
pointer	g++/defalloc.h	/^    typedef T* pointer;$/;"	t	class:allocator
pointer	g++/defalloc.h	/^    typedef void* pointer;$/;"	t	class:allocator
pointer	g++/std/bastring.h	/^	typedef charT* 									pointer;$/;"	t	class:basic_string
pointer	g++/stl_bvector.h	/^  typedef __bit_reference* pointer;$/;"	t	class:vector
pointer	g++/stl_bvector.h	/^  typedef __bit_reference* pointer;$/;"	t	struct:__bit_iterator
pointer	g++/stl_bvector.h	/^  typedef const bool*          pointer;$/;"	t	struct:__bit_const_iterator
pointer	g++/stl_deque.h	/^	typedef Ptr					 								pointer;$/;"	t	struct:std::__deque_iterator
pointer	g++/stl_deque.h	/^	typedef value_type* 									pointer;$/;"	t	class:std::deque
pointer	g++/stl_hash_map.h	/^  typedef typename ht::pointer pointer;$/;"	t	class:hash_map
pointer	g++/stl_hash_map.h	/^  typedef typename ht::pointer pointer;$/;"	t	class:hash_multimap
pointer	g++/stl_hash_set.h	/^  typedef typename ht::const_pointer pointer;$/;"	t	class:hash_multiset
pointer	g++/stl_hash_set.h	/^  typedef typename ht::const_pointer pointer;$/;"	t	class:hash_set
pointer	g++/stl_hashtable.h	/^  typedef Value* pointer;$/;"	t	struct:__hashtable_iterator
pointer	g++/stl_hashtable.h	/^  typedef const Value* pointer;$/;"	t	struct:__hashtable_const_iterator
pointer	g++/stl_hashtable.h	/^  typedef value_type*       pointer;$/;"	t	class:hashtable
pointer	g++/stl_iterator.h	/^          pointer;$/;"	t	class:reverse_iterator
pointer	g++/stl_iterator.h	/^  typedef Pointer   pointer;$/;"	t	struct:iterator
pointer	g++/stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	class:reverse_bidirectional_iterator
pointer	g++/stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	class:reverse_iterator
pointer	g++/stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	struct:bidirectional_iterator
pointer	g++/stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	struct:iterator_traits
pointer	g++/stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	struct:random_access_iterator
pointer	g++/stl_iterator.h	/^  typedef T*                   pointer;$/;"	t	struct:forward_iterator
pointer	g++/stl_iterator.h	/^  typedef T*                 pointer;$/;"	t	struct:input_iterator
pointer	g++/stl_iterator.h	/^  typedef const T*                   pointer;$/;"	t	struct:iterator_traits
pointer	g++/stl_iterator.h	/^  typedef const T*           pointer;$/;"	t	class:istream_iterator
pointer	g++/stl_iterator.h	/^  typedef typename Iterator::pointer           pointer;$/;"	t	struct:iterator_traits
pointer	g++/stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:back_insert_iterator
pointer	g++/stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:front_insert_iterator
pointer	g++/stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:insert_iterator
pointer	g++/stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:ostream_iterator
pointer	g++/stl_iterator.h	/^  typedef void                pointer;$/;"	t	struct:output_iterator
pointer	g++/stl_list.h	/^	typedef Ptr pointer;$/;"	t	struct:std::__list_iterator
pointer	g++/stl_list.h	/^	typedef value_type* 							pointer;$/;"	t	class:std::list
pointer	g++/stl_map.h	/^  typedef typename rep_type::pointer pointer;$/;"	t	class:map
pointer	g++/stl_multimap.h	/^  typedef typename rep_type::pointer pointer;$/;"	t	class:multimap
pointer	g++/stl_multiset.h	/^  typedef typename rep_type::const_pointer pointer;$/;"	t	class:multiset
pointer	g++/stl_raw_storage_iter.h	/^  typedef void                pointer;$/;"	t	class:raw_storage_iterator
pointer	g++/stl_rope.h	/^	typedef __rope_charT_ptr_proxy<charT,Alloc> pointer;$/;"	t	class:rope
pointer	g++/stl_rope.h	/^    typedef __rope_charT_ref_proxy<charT,Alloc>* pointer;$/;"	t	class:__rope_iterator
pointer	g++/stl_rope.h	/^    typedef const charT* pointer;$/;"	t	class:__rope_const_iterator
pointer	g++/stl_set.h	/^  typedef typename rep_type::const_pointer pointer;$/;"	t	class:set
pointer	g++/stl_slist.h	/^	typedef Ptr 									pointer;$/;"	t	struct:std::__slist_iterator
pointer	g++/stl_slist.h	/^	typedef value_type* 							pointer;$/;"	t	class:std::slist
pointer	g++/stl_tree.h	/^	typedef Ptr 													pointer;$/;"	t	struct:__rb_tree_iterator
pointer	g++/stl_tree.h	/^  typedef value_type* pointer;$/;"	t	class:rb_tree
pointer	g++/stl_vector.h	/^	typedef value_type*       					pointer;$/;"	t	class:vector
pointer_to_binary_function	g++/stl_function.h	/^    explicit pointer_to_binary_function(Result (*x)(Arg1, Arg2)) : ptr(x) {}$/;"	f	class:pointer_to_binary_function
pointer_to_binary_function	g++/stl_function.h	/^    pointer_to_binary_function() {}$/;"	f	class:pointer_to_binary_function
pointer_to_binary_function	g++/stl_function.h	/^class pointer_to_binary_function : public binary_function<Arg1, Arg2, Result> {$/;"	c
pointer_to_unary_function	g++/stl_function.h	/^  explicit pointer_to_unary_function(Result (*x)(Arg)) : ptr(x) {}$/;"	f	class:pointer_to_unary_function
pointer_to_unary_function	g++/stl_function.h	/^  pointer_to_unary_function() {}$/;"	f	class:pointer_to_unary_function
pointer_to_unary_function	g++/stl_function.h	/^class pointer_to_unary_function : public unary_function<Arg, Result> {$/;"	c
polar	g++/std/complext.h	/^polar (_FLT r, _FLT t)$/;"	f
pop	g++/stl_queue.h	/^	void pop() { c.pop_front(); }$/;"	f	class:queue
pop	g++/stl_queue.h	/^	void pop() {$/;"	f	class:priority_queue
pop	g++/stl_stack.h	/^  void pop() { c.pop_back(); }$/;"	f	class:stack
pop_back	g++/stl_bvector.h	/^  void pop_back() { --finish; }$/;"	f	class:vector
pop_back	g++/stl_deque.h	/^	void pop_back() {$/;"	f	class:std::deque
pop_back	g++/stl_list.h	/^	void pop_back() { $/;"	f	class:std::list
pop_back	g++/stl_rope.h	/^	void pop_back()$/;"	f	class:rope
pop_back	g++/stl_vector.h	/^	void pop_back() $/;"	f	class:vector
pop_back_aux	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::pop_back_aux() $/;"	f	class:std::deque
pop_front	g++/stl_deque.h	/^	void pop_front() {$/;"	f	class:std::deque
pop_front	g++/stl_list.h	/^	void pop_front() {erase(begin()); }$/;"	f	class:std::list
pop_front	g++/stl_rope.h	/^	void pop_front()$/;"	f	class:rope
pop_front	g++/stl_slist.h	/^	void pop_front() {$/;"	f	class:std::slist
pop_front_aux	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::pop_front_aux() {$/;"	f	class:std::deque
pop_heap	g++/stl_heap.h	/^inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last) $/;"	f
pop_heap	g++/stl_heap.h	/^inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
popen	g++/iostdio.h	108;"	d
pos	bfd.h	/^  file_ptr pos;			\/* bfd* or file position *\/$/;"	m	struct:orl
pos	g++/stl_rope.h	/^    size_t pos;$/;"	m	class:__rope_charT_ptr_proxy
pos	g++/stl_rope.h	/^    size_t pos;$/;"	m	class:__rope_charT_ref_proxy
pos_at_line_start	g++/parsestream.h	/^    _IO_fpos_t pos_at_line_start;$/;"	m	class:parsebuf
postscriptProc	tk.h	/^    Tk_ItemPostscriptProc *postscriptProc;$/;"	m	struct:Tk_ItemType
pow	g++/std/complext.cc	/^pow (FLOAT x, const complex<FLOAT>& y)$/;"	f
pow	g++/std/complext.cc	/^pow (const complex<FLOAT>& x, FLOAT y)$/;"	f
pow	g++/std/complext.cc	/^pow (const complex<FLOAT>& x, const complex<FLOAT>& y)$/;"	f
pow	g++/std/complext.cc	/^pow (const complex<FLOAT>& xin, int y)$/;"	f
power	g++/stl_numeric.h	/^T power(T x, Integer n, MonoidOperation op) {$/;"	f
power	g++/stl_numeric.h	/^inline T power(T x, Integer n) {$/;"	f
pptr	g++/streambuf.h	/^    char* pptr() const { return _IO_write_ptr; }$/;"	f	struct:streambuf
precision	g++/streambuf.h	/^    int precision() const { return _precision; }$/;"	f	class:ios
precision	g++/streambuf.h	/^    int precision(int newp) {$/;"	f	class:ios
pred	g++/stl_function.h	/^  Predicate pred;$/;"	m	class:binary_negate
pred	g++/stl_function.h	/^  Predicate pred;$/;"	m	class:unary_negate
prefix	g++/stl_rope.h	/^	sequence *prefix;$/;"	m	class:sequence_buffer
prev	g++/stl_list.h	/^	void_pointer prev;$/;"	m	struct:std::__list_node
prevOffset	tix.h	/^    int prevOffset;		\/* offset of the "next" pointer in a list$/;"	m	struct:Tix_ListInfo
prev_permutation	g++/stl_algo.h	/^bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last,$/;"	f
prev_permutation	g++/stl_algo.h	/^bool prev_permutation(BidirectionalIterator first,$/;"	f
previous	g++/stl_slist.h	/^	const_iterator previous(const_iterator pos) const {$/;"	f	class:std::slist
previous	g++/stl_slist.h	/^	iterator previous(const_iterator pos) {$/;"	f	class:std::slist
printProc	tk.h	/^    Tk_OptionPrintProc *printProc;	\/* Procedure to return a printable$/;"	m	struct:Tk_CustomOption
printable_name	bfd.h	/^  const char *printable_name;$/;"	m	struct:bfd_arch_info
printf	g++/iostdio.h	83;"	d
printf_vma	bfd.h	179;"	d
priority_queue	g++/stl_queue.h	/^	explicit priority_queue(const Compare& x) :  c(), comp(x) {}$/;"	f	class:priority_queue
priority_queue	g++/stl_queue.h	/^	priority_queue() : c() {}$/;"	f	class:priority_queue
priority_queue	g++/stl_queue.h	/^	priority_queue(InputIterator first, InputIterator last) $/;"	f	class:priority_queue
priority_queue	g++/stl_queue.h	/^	priority_queue(InputIterator first, InputIterator last, const Compare& x)$/;"	f	class:priority_queue
priority_queue	g++/stl_queue.h	/^class  priority_queue $/;"	c
proc	tcl.h	/^    Tcl_CmdProc *proc;		 \/* Command's string-based procedure. *\/$/;"	m	struct:Tcl_CmdInfo
proc	tcl.h	/^    Tcl_EventProc *proc;	\/* Procedure to call to service this event. *\/$/;"	m	struct:Tcl_Event
proc	tix.h	/^    Tix_SubCmdProc 	proc;$/;"	m	struct:_Tix_SubCmdInfo
procbuf	g++/procbuf.h	/^    procbuf() : filebuf() { }$/;"	f	class:procbuf
procbuf	g++/procbuf.h	/^class procbuf : public filebuf {$/;"	c
program	tclRegexp.h	/^	char program[1];	\/* Unwarranted chumminess with compiler. *\/$/;"	m	struct:regexp
project1st	g++/stl_function.h	/^struct project1st : public binary_function<Arg1, Arg2, Arg1> {$/;"	s
project2nd	g++/stl_function.h	/^struct project2nd : public binary_function<Arg1, Arg2, Arg2> {$/;"	s
ptr	g++/editbuf.h	/^inline buf_char *edit_mark::ptr(struct edit_buffer *buf)$/;"	f	class:edit_mark
ptr	g++/libio.h	/^    struct _IO_lock_t { void *ptr; short int field1; short int field2; };$/;"	m	struct:_IO_lock_t
ptr	g++/stl_function.h	/^    Result (*ptr)(Arg1, Arg2);$/;"	m	class:pointer_to_binary_function
ptr	g++/stl_function.h	/^  Result (*ptr)(Arg);$/;"	m	class:pointer_to_unary_function
ptr	g++/stl_rope.h	/^    __rope_RopeBase<charT,Alloc> * ptr;$/;"	m	struct:__rope_self_destruct_ptr
ptr1	tcl.h	/^	    VOID *ptr1;$/;"	m	struct:Tcl_Obj::__anon54::__anon55
ptr2	tcl.h	/^	    VOID *ptr2;$/;"	m	struct:Tcl_Obj::__anon54::__anon55
ptr_fun	g++/stl_function.h	/^inline pointer_to_unary_function<Arg, Result> ptr_fun(Result (*x)(Arg)) {$/;"	f
ptr_fun	g++/stl_function.h	/^ptr_fun(Result (*x)(Arg1, Arg2)) {$/;"	f
ptrdiff_t	include/stddef.h	/^typedef __PTRDIFF_TYPE__ ptrdiff_t;$/;"	t
pubseekoff	g++/streambuf.h	/^    streampos pubseekoff(streamoff o, _seek_dir d, int mode=ios::in|ios::out)$/;"	f	struct:streambuf
pubseekpos	g++/streambuf.h	/^    streampos pubseekpos(streampos pos, int mode = ios::in|ios::out)$/;"	f	struct:streambuf
pure_alphabetic	readline/chardefs.h	37;"	d
push	g++/stl_queue.h	/^	void push(const value_type& x) { c.push_back(x); }$/;"	f	class:queue
push	g++/stl_queue.h	/^	void push(const value_type& x) {$/;"	f	class:priority_queue
push	g++/stl_stack.h	/^  void push(const value_type& x) { c.push_back(x); }$/;"	f	class:stack
push_back	g++/stl_bvector.h	/^  void push_back(bool x) {$/;"	f	class:vector
push_back	g++/stl_deque.h	/^	void push_back(const value_type& t) {$/;"	f	class:std::deque
push_back	g++/stl_list.h	/^	void push_back(const T& x) {insert(end(), x); }$/;"	f	class:std::list
push_back	g++/stl_rope.h	/^	void push_back(charT x)$/;"	f	class:rope
push_back	g++/stl_rope.h	/^	void push_back(value_type x)$/;"	f	class:sequence_buffer
push_back	g++/stl_vector.h	/^	void push_back(const T& x) $/;"	f	class:vector
push_back_aux	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::push_back_aux(const value_type& t) $/;"	f	class:std::deque
push_front	g++/stl_deque.h	/^	void push_front(const value_type& t) $/;"	f	class:std::deque
push_front	g++/stl_list.h	/^	void push_front(const T& x){insert(begin(), x); }$/;"	f	class:std::list
push_front	g++/stl_rope.h	/^	void push_front(charT x)$/;"	f	class:rope
push_front	g++/stl_slist.h	/^	void push_front(const value_type& x)   {$/;"	f	class:std::slist
push_front_aux	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::push_front_aux(const value_type& t) $/;"	f	class:std::deque
push_heap	g++/stl_heap.h	/^inline void push_heap(RandomAccessIterator first, RandomAccessIterator last) $/;"	f
push_heap	g++/stl_heap.h	/^inline void push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp) $/;"	f
put	g++/iostream.h	/^    ostream& put(char c) { _strbuf->sputc(c); return *this; }$/;"	f	class:ostream
put	g++/iostream.h	/^    ostream& put(signed char c) { return put((char)c); }$/;"	f	class:ostream
put	g++/iostream.h	/^    ostream& put(unsigned char c) { return put((char)c); }$/;"	f	class:ostream
put	g++/stl_rope.h	/^	sequence_buffer& put(value_type x)$/;"	f	class:sequence_buffer
put_mode	g++/streambuf.h	/^    int put_mode() { return _flags & _IO_CURRENTLY_PUTTING; }$/;"	f	struct:streambuf
put_node	g++/stl_list.h	/^	void put_node(link_type p) { $/;"	f	class:std::list
put_node	g++/stl_tree.h	/^  void put_node(link_type p) { rb_tree_node_allocator::deallocate(p); }$/;"	f	class:rb_tree
put_stream	g++/indstream.h	/^    streambuf *put_stream()$/;"	f	class:indirectbuf
putback	g++/iostream.h	/^    istream& putback(char ch) {$/;"	f	class:istream
putc	g++/iostdio.h	60;"	d
puts	g++/iostdio.h	84;"	d
queue	g++/stl_queue.h	/^class queue $/;"	c
random_access_iterator	g++/stl_iterator.h	/^struct random_access_iterator {$/;"	s
random_access_iterator_tag	g++/stl_iterator.h	/^struct random_access_iterator_tag :       \/\/$/;"	s
random_sample	g++/stl_algo.h	/^random_sample(InputIterator first, InputIterator last,$/;"	f
random_sample_n	g++/stl_algo.h	/^OutputIterator random_sample_n(ForwardIterator first, ForwardIterator last,$/;"	f
random_shuffle	g++/stl_algo.h	/^inline void random_shuffle(RandomAccessIterator first,$/;"	f
random_shuffle	g++/stl_algo.h	/^void random_shuffle(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
range_initialize	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::range_initialize(ForwardIterator first,$/;"	f	class:std::deque
range_initialize	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::range_initialize(InputIterator first,$/;"	f	class:std::deque
range_initialize	g++/stl_list.h	/^	void range_initialize(InputIterator first, InputIterator last) {$/;"	f	class:std::list
range_initialize	g++/stl_slist.h	/^	void range_initialize(InputIterator first, InputIterator last) {$/;"	f	class:std::slist
range_initialize	g++/stl_vector.h	/^	void range_initialize(ForwardIterator first, ForwardIterator last, forward_iterator_tag) $/;"	f	class:vector
range_initialize	g++/stl_vector.h	/^	void range_initialize(InputIterator first, InputIterator last, input_iterator_tag) $/;"	f	class:vector
range_insert	g++/stl_vector.h	/^void vector<T, Alloc>::range_insert(iterator pos, InputIterator first, InputIterator last, input_iterator_tag) $/;"	f	class:vector
range_insert	g++/stl_vector.h	/^void vector<T, Alloc>::range_insert(iterator position, ForwardIterator first, ForwardIterator last, forward_iterator_tag) $/;"	f	class:vector
raw	g++/fstream.h	/^    fstreambase& raw() { rdbuf()->setbuf(NULL, 0); return *this; }$/;"	f	class:fstreambase
raw_storage_iterator	g++/stl_raw_storage_iter.h	/^  explicit raw_storage_iterator(ForwardIterator x) : iter(x) {}$/;"	f	class:raw_storage_iterator
raw_storage_iterator	g++/stl_raw_storage_iter.h	/^class raw_storage_iterator {$/;"	c
rb_tree	g++/stl_tree.h	/^  rb_tree(const Compare& comp = Compare())$/;"	f	class:rb_tree
rb_tree	g++/stl_tree.h	/^  rb_tree(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x) $/;"	f	class:rb_tree
rb_tree	g++/stl_tree.h	/^class rb_tree $/;"	c
rb_tree_node	g++/stl_tree.h	/^  typedef __rb_tree_node<Value> rb_tree_node;$/;"	t	class:rb_tree
rb_tree_node_allocator	g++/stl_tree.h	/^  typedef simple_alloc<rb_tree_node, Alloc> rb_tree_node_allocator;$/;"	t	class:rb_tree
rbegin	g++/std/bastring.h	/^	const_reverse_iterator rbegin() const{ return const_reverse_iterator (end ()); }$/;"	f	class:basic_string
rbegin	g++/std/bastring.h	/^	reverse_iterator       rbegin() { return reverse_iterator (end ()); }$/;"	f	class:basic_string
rbegin	g++/stl_bvector.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:vector
rbegin	g++/stl_bvector.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:vector
rbegin	g++/stl_deque.h	/^	const_reverse_iterator rbegin() const {return const_reverse_iterator(finish);}$/;"	f	class:std::deque
rbegin	g++/stl_deque.h	/^	reverse_iterator rbegin() { return reverse_iterator(finish); }$/;"	f	class:std::deque
rbegin	g++/stl_list.h	/^	const_reverse_iterator rbegin() const {return const_reverse_iterator(end()); }$/;"	f	class:std::list
rbegin	g++/stl_list.h	/^	reverse_iterator rbegin() {return reverse_iterator(end()); }$/;"	f	class:std::list
rbegin	g++/stl_map.h	/^  const_reverse_iterator rbegin() const { return t.rbegin(); }$/;"	f	class:map
rbegin	g++/stl_map.h	/^  reverse_iterator rbegin() { return t.rbegin(); }$/;"	f	class:map
rbegin	g++/stl_multimap.h	/^  const_reverse_iterator rbegin() const { return t.rbegin(); }$/;"	f	class:multimap
rbegin	g++/stl_multimap.h	/^  reverse_iterator rbegin() { return t.rbegin(); }$/;"	f	class:multimap
rbegin	g++/stl_multiset.h	/^  reverse_iterator rbegin() const { return t.rbegin(); } $/;"	f	class:multiset
rbegin	g++/stl_rope.h	/^	    const_reverse_iterator rbegin() { return const_rbegin(); }$/;"	f	class:rope
rbegin	g++/stl_rope.h	/^	    reverse_iterator rbegin() { return mutable_rbegin(); }$/;"	f	class:rope
rbegin	g++/stl_rope.h	/^	const_reverse_iterator rbegin() const {$/;"	f	class:rope
rbegin	g++/stl_set.h	/^  reverse_iterator rbegin() const { return t.rbegin(); } $/;"	f	class:set
rbegin	g++/stl_tree.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:rb_tree
rbegin	g++/stl_tree.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:rb_tree
rbegin	g++/stl_vector.h	/^	const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }$/;"	f	class:vector
rbegin	g++/stl_vector.h	/^	reverse_iterator rbegin(){ return reverse_iterator(end()); }$/;"	f	class:vector
rdbuf	g++/fstream.h	/^    filebuf* rdbuf() const { return &__my_fb; }$/;"	f	class:fstreambase
rdbuf	g++/fstream.h	/^    filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }$/;"	f	class:fstreambase
rdbuf	g++/stdiostream.h	/^  stdiobuf* rdbuf() \/* const *\/ { return &_file; }$/;"	f	class:ostdiostream
rdbuf	g++/stdiostream.h	/^  stdiobuf* rdbuf()\/* const *\/ { return &_file; }$/;"	f	class:istdiostream
rdbuf	g++/streambuf.h	/^    streambuf* rdbuf() const { return _strbuf; }$/;"	f	class:ios
rdbuf	g++/streambuf.h	/^    streambuf* rdbuf(streambuf *_s) {$/;"	f	class:ios
rdbuf	g++/strstream.h	/^    strstreambuf* rdbuf() { return &__my_sb; }$/;"	f	class:strstreambase
rdios	g++/streambuf.h	/^	ios* rdios() const { return _stream; }$/;"	f	class:ios::failure
rdstate	g++/streambuf.h	/^    iostate rdstate() const { return _state; }$/;"	f	class:ios
re	expect.h	/^	regexp *re;$/;"	m	struct:exp_case
re	g++/std/complext.h	/^  _FLT re, im;$/;"	m	class:complex
re	g++/std/dcomplex.h	/^  double re, im;$/;"	m	class:complex
re	g++/std/fcomplex.h	/^  float re, im;$/;"	m	class:complex
re	g++/std/ldcomplex.h	/^  long double re, im;$/;"	m	class:complex
read	g++/iostream.h	/^    istream& read(signed char *ptr, streamsize n)$/;"	f	class:istream
read	g++/iostream.h	/^    istream& read(unsigned char *ptr, streamsize n)$/;"	f	class:istream
read	g++/iostream.h	/^    istream& read(void *ptr, streamsize n)$/;"	f	class:istream
read	g++/libio.h	/^  _IO_ssize_t (*read) __P ((struct _IO_FILE *, void *, _IO_ssize_t));$/;"	m	struct:__anon3
read	g++/libio.h	/^  _IO_ssize_t (*read) __P ((struct _IO_FILE *, void *, _IO_ssize_t));$/;"	m	struct:__anon74
read	g++/stl_iterator.h	/^  void read() {$/;"	f	class:istream_iterator
read_direction	bfd.h	/^                        read_direction = 1,$/;"	e	enum:_bfd::bfd_direction
read_func	g++/parsestream.h	/^    CharReader read_func;$/;"	m	class:func_parsebuf
real	g++/std/complext.h	/^  _FLT real () const { return re; }$/;"	f	class:complex
real	g++/std/complext.h	/^real (const complex<_FLT>& x)$/;"	f
real	g++/std/dcomplex.h	/^  double real () const { return re; }$/;"	f	class:complex
real	g++/std/fcomplex.h	/^  float real () const { return re; }$/;"	f	class:complex
real	g++/std/ldcomplex.h	/^  long double real () const { return re; }$/;"	f	class:complex
reallocate	g++/stl_alloc.h	/^	static void * reallocate(void *p, size_t old_sz, size_t new_sz)$/;"	f	class:debug_alloc
reallocate	g++/stl_alloc.h	/^	static void* reallocate(void *p, size_t \/* old_sz *\/, size_t new_sz)$/;"	f	class:__malloc_alloc_template
reallocate	g++/stl_alloc.h	/^__default_alloc_template<threads, inst>::reallocate(void *p,$/;"	f	class:__default_alloc_template
reallocate_map	g++/stl_deque.h	/^void deque<T, Alloc, BufSize>::reallocate_map(size_type nodes_to_add, bool add_at_front) $/;"	f	class:std::deque
rebuildSize	tcl.h	/^    int rebuildSize;			\/* Enlarge table when numEntries gets$/;"	m	struct:Tcl_HashTable
ref	g++/std/bastring.h	/^		size_t len, res, ref; \/\/ len res$/;"	m	struct:basic_string::Rep
ref	g++/stl_rope.h	/^	  static void ref(RopeBase* t) {}$/;"	f	class:rope
ref	g++/stl_rope.h	/^	  static void ref(RopeBase* t)$/;"	f	class:rope
ref	g++/stl_rope.h	/^	  static void ref(__rope_RopeBase* t) {}$/;"	f	struct:__rope_RopeBase
ref	g++/stl_rope.h	/^	  static void ref(__rope_RopeBase* t)$/;"	f	struct:__rope_RopeBase
refCount	tcl.h	/^    int refCount;		\/* When 0 the object will be freed. *\/$/;"	m	struct:Tcl_Obj
ref_nonnil	g++/stl_rope.h	/^	  void ref_nonnil() {}$/;"	f	struct:__rope_RopeBase
ref_nonnil	g++/stl_rope.h	/^	  void ref_nonnil()$/;"	f	struct:__rope_RopeBase
refcount	g++/stl_rope.h	/^	    long refcount;  	\/\/ InterlockedIncrement wants a long *$/;"	m	struct:__rope_RopeBase
refcount	g++/stl_rope.h	/^	    size_t refcount;$/;"	m	struct:__rope_RopeBase
refcount_lock	g++/stl_rope.h	/^	    pthread_mutex_t refcount_lock;$/;"	m	struct:__rope_RopeBase
reference	g++/defalloc.h	/^    typedef T& reference;$/;"	t	class:allocator
reference	g++/std/bastring.h	/^	typedef charT& 									reference;$/;"	t	class:basic_string
reference	g++/stl_bvector.h	/^  typedef __bit_reference  reference;$/;"	t	struct:__bit_iterator
reference	g++/stl_bvector.h	/^  typedef __bit_reference reference;$/;"	t	class:vector
reference	g++/stl_bvector.h	/^  typedef bool                 reference;$/;"	t	struct:__bit_const_iterator
reference	g++/stl_deque.h	/^	typedef Ref 												reference;$/;"	t	struct:std::__deque_iterator
reference	g++/stl_deque.h	/^	typedef value_type& 									reference;$/;"	t	class:std::deque
reference	g++/stl_hash_map.h	/^  typedef typename ht::reference reference;$/;"	t	class:hash_map
reference	g++/stl_hash_map.h	/^  typedef typename ht::reference reference;$/;"	t	class:hash_multimap
reference	g++/stl_hash_set.h	/^  typedef typename ht::const_reference reference;$/;"	t	class:hash_multiset
reference	g++/stl_hash_set.h	/^  typedef typename ht::const_reference reference;$/;"	t	class:hash_set
reference	g++/stl_hashtable.h	/^  typedef Value& reference;$/;"	t	struct:__hashtable_iterator
reference	g++/stl_hashtable.h	/^  typedef const Value& reference;$/;"	t	struct:__hashtable_const_iterator
reference	g++/stl_hashtable.h	/^  typedef value_type&       reference;$/;"	t	class:hashtable
reference	g++/stl_iterator.h	/^          reference;$/;"	t	class:reverse_iterator
reference	g++/stl_iterator.h	/^  typedef Reference                  reference;$/;"	t	class:reverse_bidirectional_iterator
reference	g++/stl_iterator.h	/^  typedef Reference                  reference;$/;"	t	class:reverse_iterator
reference	g++/stl_iterator.h	/^  typedef Reference reference;$/;"	t	struct:iterator
reference	g++/stl_iterator.h	/^  typedef T&                         reference;$/;"	t	struct:bidirectional_iterator
reference	g++/stl_iterator.h	/^  typedef T&                         reference;$/;"	t	struct:iterator_traits
reference	g++/stl_iterator.h	/^  typedef T&                         reference;$/;"	t	struct:random_access_iterator
reference	g++/stl_iterator.h	/^  typedef T&                   reference;$/;"	t	struct:forward_iterator
reference	g++/stl_iterator.h	/^  typedef T&                 reference;$/;"	t	struct:input_iterator
reference	g++/stl_iterator.h	/^  typedef const T&                   reference;$/;"	t	struct:iterator_traits
reference	g++/stl_iterator.h	/^  typedef const T&           reference;$/;"	t	class:istream_iterator
reference	g++/stl_iterator.h	/^  typedef typename Iterator::reference         reference;$/;"	t	struct:iterator_traits
reference	g++/stl_iterator.h	/^  typedef void                reference;$/;"	t	class:back_insert_iterator
reference	g++/stl_iterator.h	/^  typedef void                reference;$/;"	t	class:front_insert_iterator
reference	g++/stl_iterator.h	/^  typedef void                reference;$/;"	t	class:insert_iterator
reference	g++/stl_iterator.h	/^  typedef void                reference;$/;"	t	class:ostream_iterator
reference	g++/stl_iterator.h	/^  typedef void                reference;$/;"	t	struct:output_iterator
reference	g++/stl_list.h	/^	typedef Ref reference;$/;"	t	struct:std::__list_iterator
reference	g++/stl_list.h	/^	typedef value_type& 							reference;$/;"	t	class:std::list
reference	g++/stl_map.h	/^  typedef typename rep_type::reference reference;$/;"	t	class:map
reference	g++/stl_multimap.h	/^  typedef typename rep_type::reference reference;$/;"	t	class:multimap
reference	g++/stl_multiset.h	/^  typedef typename rep_type::const_reference reference;$/;"	t	class:multiset
reference	g++/stl_queue.h	/^	typedef typename Sequence::reference reference;$/;"	t	class:priority_queue
reference	g++/stl_queue.h	/^	typedef typename Sequence::reference reference;$/;"	t	class:queue
reference	g++/stl_raw_storage_iter.h	/^  typedef void                reference;$/;"	t	class:raw_storage_iterator
reference	g++/stl_rope.h	/^	typedef __rope_charT_ref_proxy<charT,Alloc> reference;$/;"	t	class:rope
reference	g++/stl_rope.h	/^    typedef __rope_charT_ref_proxy<charT,Alloc>  reference;$/;"	t	class:__rope_iterator
reference	g++/stl_rope.h	/^    typedef charT reference;    \/\/ Really a value.  Returning a reference$/;"	t	class:__rope_const_iterator
reference	g++/stl_set.h	/^  typedef typename rep_type::const_reference reference;$/;"	t	class:set
reference	g++/stl_slist.h	/^	typedef Ref 									reference;$/;"	t	struct:std::__slist_iterator
reference	g++/stl_slist.h	/^	typedef value_type& 							reference;$/;"	t	class:std::slist
reference	g++/stl_stack.h	/^  typedef typename Sequence::reference reference;$/;"	t	class:stack
reference	g++/stl_tree.h	/^	typedef Ref 													reference;$/;"	t	struct:__rb_tree_iterator
reference	g++/stl_tree.h	/^  typedef value_type& reference;$/;"	t	class:rb_tree
reference	g++/stl_vector.h	/^	typedef value_type&       					reference;$/;"	t	class:vector
refill	g++/stl_alloc.h	/^void* __default_alloc_template<threads, inst>::refill(size_t n)$/;"	f	class:__default_alloc_template
reg_save_area	include/va-ppc.h	/^  char *reg_save_area;		\/* where r3:r10 and f1:f8, if saved are stored *\/$/;"	m	struct:__va_list_tag
reganch	tclRegexp.h	/^	char reganch;		\/* Internal use only. *\/$/;"	m	struct:regexp
regexp	tclRegexp.h	/^typedef struct regexp {$/;"	s
regexp	tclRegexp.h	/^} regexp;$/;"	t	typeref:struct:regexp
regmlen	tclRegexp.h	/^	int regmlen;		\/* Internal use only. *\/$/;"	m	struct:regexp
regmust	tclRegexp.h	/^	char *regmust;		\/* Internal use only. *\/$/;"	m	struct:regexp
regstart	tclRegexp.h	/^	char regstart;		\/* Internal use only. *\/$/;"	m	struct:regexp
rel_filepos	bfd.h	/^   file_ptr rel_filepos;$/;"	m	struct:sec
release	g++/std/bastring.h	/^		void release() { if (--ref == 0) delete this; }$/;"	f	struct:basic_string::Rep
relent	bfd.h	/^  arelent relent;$/;"	m	struct:relent_chain
relent_chain	bfd.h	/^typedef struct relent_chain {$/;"	s
reloc	bfdlink.h	/^	} reloc;$/;"	m	union:bfd_link_order::__anon64	typeref:struct:bfd_link_order::__anon64::__anon68
reloc	bfdlink.h	/^  bfd_reloc_code_real_type reloc;$/;"	m	struct:bfd_link_order_reloc
reloc_cache_entry	bfd.h	/^typedef struct reloc_cache_entry$/;"	s
reloc_count	bfd.h	/^   unsigned reloc_count;$/;"	m	struct:sec
reloc_dangerous	bfdlink.h	/^  boolean (*reloc_dangerous) PARAMS ((struct bfd_link_info *,$/;"	m	struct:bfd_link_callbacks
reloc_done	bfd.h	/^       unsigned int reloc_done : 1;$/;"	m	struct:sec
reloc_howto_struct	bfd.h	/^struct reloc_howto_struct$/;"	s
reloc_howto_type	bfd.h	/^typedef const struct reloc_howto_struct reloc_howto_type;$/;"	t	typeref:struct:reloc_howto_struct
reloc_overflow	bfdlink.h	/^  boolean (*reloc_overflow) PARAMS ((struct bfd_link_info *,$/;"	m	struct:bfd_link_callbacks
reloc_type_lookup	bfd.h	/^       (*reloc_type_lookup) PARAMS ((bfd *abfd,$/;"	m	struct:bfd_target
relocateable	bfdlink.h	/^  boolean relocateable;$/;"	m	struct:bfd_link_info
relocation	bfd.h	/^   struct reloc_cache_entry *relocation;$/;"	m	struct:sec	typeref:struct:sec::reloc_cache_entry
remove	g++/stl_algo.h	/^ForwardIterator remove(ForwardIterator first, ForwardIterator last,$/;"	f
remove	g++/stl_list.h	/^void list<T, Alloc>::remove(const T& value){$/;"	f	class:std::list
remove	g++/stl_slist.h	/^void slist<T,Alloc>::remove(const T& val){$/;"	f	class:std::slist
remove_copy	g++/stl_algo.h	/^OutputIterator remove_copy(InputIterator first, InputIterator last,$/;"	f
remove_copy_if	g++/stl_algo.h	/^OutputIterator remove_copy_if(InputIterator first, InputIterator last,$/;"	f
remove_if	g++/stl_algo.h	/^ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,$/;"	f
remove_if	g++/stl_list.h	/^void list<T, Alloc>::remove_if(Predicate pred)$/;"	f	class:std::list
remove_if	g++/stl_slist.h	/^template <class Predicate> void slist<T,Alloc>::remove_if(Predicate pred)$/;"	f	class:std::slist
rend	g++/std/bastring.h	/^	const_reverse_iterator rend() const{ return const_reverse_iterator (begin ()); }$/;"	f	class:basic_string
rend	g++/std/bastring.h	/^	reverse_iterator       rend() { return reverse_iterator (begin ()); }$/;"	f	class:basic_string
rend	g++/stl_bvector.h	/^  const_reverse_iterator rend() const { $/;"	f	class:vector
rend	g++/stl_bvector.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:vector
rend	g++/stl_deque.h	/^	const_reverse_iterator rend() const {return const_reverse_iterator(start);}$/;"	f	class:std::deque
rend	g++/stl_deque.h	/^	reverse_iterator rend() { return reverse_iterator(start); }$/;"	f	class:std::deque
rend	g++/stl_list.h	/^	const_reverse_iterator rend() const { return const_reverse_iterator(begin());}$/;"	f	class:std::list
rend	g++/stl_list.h	/^	reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:std::list
rend	g++/stl_map.h	/^  const_reverse_iterator rend() const { return t.rend(); }$/;"	f	class:map
rend	g++/stl_map.h	/^  reverse_iterator rend() { return t.rend(); }$/;"	f	class:map
rend	g++/stl_multimap.h	/^  const_reverse_iterator rend() const { return t.rend(); }$/;"	f	class:multimap
rend	g++/stl_multimap.h	/^  reverse_iterator rend() { return t.rend(); }$/;"	f	class:multimap
rend	g++/stl_multiset.h	/^  reverse_iterator rend() const { return t.rend(); }$/;"	f	class:multiset
rend	g++/stl_rope.h	/^	    const_reverse_iterator rend() { return const_rend(); }$/;"	f	class:rope
rend	g++/stl_rope.h	/^	    reverse_iterator rend() { return mutable_rend(); }$/;"	f	class:rope
rend	g++/stl_rope.h	/^	const_reverse_iterator rend() const {$/;"	f	class:rope
rend	g++/stl_set.h	/^  reverse_iterator rend() const { return t.rend(); }$/;"	f	class:set
rend	g++/stl_tree.h	/^  const_reverse_iterator rend() const { $/;"	f	class:rb_tree
rend	g++/stl_tree.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:rb_tree
rend	g++/stl_vector.h	/^	const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }$/;"	f	class:vector
rend	g++/stl_vector.h	/^	reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:vector
rep	g++/std/bastring.h	/^	Rep *rep() const { return reinterpret_cast<Rep *>(dat) - 1; }$/;"	f	class:basic_string
rep	g++/stl_hash_map.h	/^  ht rep;$/;"	m	class:hash_map
rep	g++/stl_hash_map.h	/^  ht rep;$/;"	m	class:hash_multimap
rep	g++/stl_hash_set.h	/^  ht rep;$/;"	m	class:hash_multiset
rep	g++/stl_hash_set.h	/^  ht rep;$/;"	m	class:hash_set
rep_type	g++/stl_map.h	/^                  select1st<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:map
rep_type	g++/stl_multimap.h	/^                  select1st<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:multimap
rep_type	g++/stl_multiset.h	/^                  identity<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:multiset
rep_type	g++/stl_set.h	/^                  identity<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:set
replace	g++/std/bastring.cc	/^replace(size_type pos, size_type n1, const charT* s, size_type n2)$/;"	f	class:basic_string
replace	g++/std/bastring.cc	/^replace(size_type pos, size_type n1, size_type n2, charT c)$/;"	f	class:basic_string
replace	g++/std/bastring.cc	/^replace(size_type pos1, size_type n1, const basic_string& str, size_type pos2, size_type n2)$/;"	f	class:basic_string
replace	g++/std/bastring.h	/^	basic_string& replace (iterator i1, iterator i2, const basic_string& str)$/;"	f	class:basic_string
replace	g++/std/bastring.h	/^	basic_string& replace(iterator i1, iterator i2, const charT* s)$/;"	f	class:basic_string
replace	g++/std/bastring.h	/^	basic_string& replace(iterator i1, iterator i2, const charT* s, size_type n)$/;"	f	class:basic_string
replace	g++/std/bastring.h	/^	basic_string& replace(iterator i1, iterator i2, size_type n, charT c)$/;"	f	class:basic_string
replace	g++/std/bastring.h	/^	basic_string& replace(size_type pos, size_type n, charT c)$/;"	f	class:basic_string
replace	g++/std/bastring.h	/^	basic_string& replace(size_type pos, size_type n1, const charT* s)$/;"	f	class:basic_string
replace	g++/std/bastring.h	/^replace(iterator i1, iterator i2, InputIterator j1, InputIterator j2)$/;"	f	class:basic_string
replace	g++/stl_algo.h	/^void replace(ForwardIterator first, ForwardIterator last, const T& old_value,$/;"	f
replace	g++/stl_rope.h	/^	static RopeBase * replace(RopeBase *old, size_t pos1,$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(const iterator& p, charT c)$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(const iterator& p, const charT * c_string)$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(const iterator& p, const charT *i, const charT *j)$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(const iterator& p, const charT *i, size_t n)$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(const iterator& p, const iterator& q, charT c)$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(const iterator& p, const iterator& q,$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(const iterator& p, const rope& r)$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(const iterator& p, const_iterator i, const_iterator j)$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(const iterator& p, iterator i, iterator j)$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(size_t p, charT c) {$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(size_t p, const charT *c_string) {$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(size_t p, const charT *i, const charT *j) {$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(size_t p, const charT *i, size_t i_len) {$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(size_t p, const const_iterator& i,$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(size_t p, const iterator& i,$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(size_t p, const rope& r) {$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(size_t p, size_t n, charT c) {$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(size_t p, size_t n, const charT *c_string) {$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(size_t p, size_t n, const charT *i, const charT *j) {$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(size_t p, size_t n, const charT *i, size_t i_len) {$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(size_t p, size_t n, const rope& r) {$/;"	f	class:rope
replace	g++/stl_rope.h	/^	void replace(size_t p, size_t n,$/;"	f	class:rope
replace_copy	g++/stl_algo.h	/^OutputIterator replace_copy(InputIterator first, InputIterator last,$/;"	f
replace_copy_if	g++/stl_algo.h	/^OutputIterator replace_copy_if(Iterator first, Iterator last,$/;"	f
replace_if	g++/stl_algo.h	/^void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred,$/;"	f
replace_with_c_str	g++/ropeimpl.h	/^const charT * rope<charT,Alloc>::replace_with_c_str() {$/;"	f	class:rope
repup	g++/std/bastring.h	/^	void repup(Rep *p) { rep()->release(); dat = p->data(); }$/;"	f	class:basic_string
reqHeight	tk.h	/^    int reqWidth, reqHeight;$/;"	m	struct:Tk_FakeWin
reqWidth	tk.h	/^    int reqWidth, reqHeight;$/;"	m	struct:Tk_FakeWin
requestProc	tk.h	/^    Tk_GeomRequestProc *requestProc;$/;"	m	struct:Tk_GeomMgr
requested_size	g++/stl_tempbuf.h	/^  ptrdiff_t requested_size() const { return original_len; }$/;"	f	class:temporary_buffer
res	g++/std/bastring.h	/^		size_t len, res, ref; \/\/ len res$/;"	m	struct:basic_string::Rep
reserve	g++/std/bastring.h	/^	void reserve(size_type) { }$/;"	f	class:basic_string
reserve	g++/stl_bvector.h	/^  void reserve(size_type n) {$/;"	f	class:vector
reserve	g++/stl_rope.h	/^	    void reserve(size_type res_arg = 0) {}$/;"	f	class:rope
reserve	g++/stl_vector.h	/^	void reserve(size_type n) $/;"	f	class:vector
reserve_elements_at_back	g++/stl_deque.h	/^	iterator reserve_elements_at_back(size_type n) $/;"	f	class:std::deque
reserve_elements_at_front	g++/stl_deque.h	/^	iterator reserve_elements_at_front(size_type n) $/;"	f	class:std::deque
reserve_map_at_back	g++/stl_deque.h	/^	void reserve_map_at_back (size_type nodes_to_add = 1) {$/;"	f	class:std::deque
reserve_map_at_front	g++/stl_deque.h	/^	void reserve_map_at_front (size_type nodes_to_add = 1) {$/;"	f	class:std::deque
resize	g++/std/bastring.cc	/^resize (size_type n, charT c)$/;"	f	class:basic_string
resize	g++/std/bastring.h	/^	void resize(size_type n){ resize (n, eos()); }$/;"	f	class:basic_string
resize	g++/stl_bvector.h	/^  void resize(size_type new_size, bool x = bool()) {$/;"	f	class:vector
resize	g++/stl_deque.h	/^	void resize(size_type new_size) { resize(new_size, value_type()); }$/;"	f	class:std::deque
resize	g++/stl_deque.h	/^	void resize(size_type new_size, const value_type& x) $/;"	f	class:std::deque
resize	g++/stl_hash_map.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_map
resize	g++/stl_hash_map.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_multimap
resize	g++/stl_hash_set.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_multiset
resize	g++/stl_hash_set.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_set
resize	g++/stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::resize(size_type num_elements_hint)$/;"	f	class:hashtable
resize	g++/stl_list.h	/^	void resize(size_type new_size) {resize(new_size, T()); }$/;"	f	class:std::list
resize	g++/stl_list.h	/^void list<T, Alloc>::resize(size_type new_size, const T& x){$/;"	f	class:std::list
resize	g++/stl_rope.h	/^	    void resize(size_type n) {}$/;"	f	class:rope
resize	g++/stl_rope.h	/^	    void resize(size_type n, charT c) {}$/;"	f	class:rope
resize	g++/stl_slist.h	/^	void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:std::slist
resize	g++/stl_slist.h	/^void slist<T, Alloc>::resize(size_type len, const T& x){$/;"	f	class:std::slist
resize	g++/stl_vector.h	/^	void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:vector
resize	g++/stl_vector.h	/^	void resize(size_type new_size, const T& x) $/;"	f	class:vector
result	tcl.h	/^    char *result;		\/* If the last command returned a string$/;"	m	struct:Tcl_Interp
result_type	g++/stl_function.h	/^    typedef Result result_type;$/;"	t	struct:binary_function
result_type	g++/stl_function.h	/^    typedef Result result_type;$/;"	t	struct:unary_function
result_type	g++/stl_function.h	/^  typedef Result result_type;$/;"	t	struct:constant_void_fun
return_temporary_buffer	g++/stl_tempbuf.h	/^void return_temporary_buffer(T* p) {$/;"	f
reverse	g++/stl_algo.h	/^inline void reverse(BidirectionalIterator first, BidirectionalIterator last) {$/;"	f
reverse	g++/stl_list.h	/^void list<T, Alloc>::reverse() {$/;"	f	class:std::list
reverse	g++/stl_slist.h	/^	void reverse() { $/;"	f	class:std::slist
reverse_bidirectional_iterator	g++/stl_iterator.h	/^  explicit reverse_bidirectional_iterator(BidirectionalIterator x)$/;"	f	class:reverse_bidirectional_iterator
reverse_bidirectional_iterator	g++/stl_iterator.h	/^  reverse_bidirectional_iterator() {}$/;"	f	class:reverse_bidirectional_iterator
reverse_bidirectional_iterator	g++/stl_iterator.h	/^class reverse_bidirectional_iterator {$/;"	c
reverse_copy	g++/stl_algo.h	/^OutputIterator reverse_copy(BidirectionalIterator first,$/;"	f
reverse_iterator	g++/std/bastring.h	/^	typedef ::reverse_iterator<iterator> 			reverse_iterator;$/;"	t	class:basic_string
reverse_iterator	g++/stl_bvector.h	/^          reverse_iterator;$/;"	t	class:vector
reverse_iterator	g++/stl_bvector.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:vector
reverse_iterator	g++/stl_deque.h	/^	typedef reverse_iterator<iterator> 						reverse_iterator;$/;"	t	class:std::deque
reverse_iterator	g++/stl_iterator.h	/^  explicit reverse_iterator(RandomAccessIterator x) : current(x) {}$/;"	f	class:reverse_iterator
reverse_iterator	g++/stl_iterator.h	/^  explicit reverse_iterator(iterator_type x) : current(x) {}$/;"	f	class:reverse_iterator
reverse_iterator	g++/stl_iterator.h	/^  reverse_iterator() {}$/;"	f	class:reverse_iterator
reverse_iterator	g++/stl_iterator.h	/^  reverse_iterator(const reverse_iterator<Iter>& x) : current(x.current) {}$/;"	f	class:reverse_iterator
reverse_iterator	g++/stl_iterator.h	/^  reverse_iterator(const self& x) : current(x.current) {}$/;"	f	class:reverse_iterator
reverse_iterator	g++/stl_iterator.h	/^class reverse_iterator $/;"	c
reverse_iterator	g++/stl_iterator.h	/^class reverse_iterator {$/;"	c
reverse_iterator	g++/stl_list.h	/^	typedef reverse_iterator<iterator> 				reverse_iterator;$/;"	t	class:std::list
reverse_iterator	g++/stl_map.h	/^  typedef typename rep_type::reverse_iterator reverse_iterator;$/;"	t	class:map
reverse_iterator	g++/stl_multimap.h	/^  typedef typename rep_type::reverse_iterator reverse_iterator;$/;"	t	class:multimap
reverse_iterator	g++/stl_multiset.h	/^  typedef typename rep_type::const_reverse_iterator reverse_iterator;$/;"	t	class:multiset
reverse_iterator	g++/stl_rope.h	/^				 difference_type>  reverse_iterator;$/;"	t	class:rope
reverse_iterator	g++/stl_rope.h	/^        typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:rope
reverse_iterator	g++/stl_set.h	/^  typedef typename rep_type::const_reverse_iterator reverse_iterator;$/;"	t	class:set
reverse_iterator	g++/stl_tree.h	/^          reverse_iterator; $/;"	t	class:rb_tree
reverse_iterator	g++/stl_tree.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:rb_tree
reverse_iterator	g++/stl_vector.h	/^	typedef reverse_iterator<iterator> 			reverse_iterator;$/;"	t	class:vector
rewind	g++/iostdio.h	85;"	d
rfind	g++/std/bastring.cc	/^rfind (charT c, size_type pos) const$/;"	f	class:basic_string
rfind	g++/std/bastring.cc	/^rfind (const charT* s, size_type pos, size_type n) const$/;"	f	class:basic_string
rfind	g++/std/bastring.h	/^	size_type rfind (const charT* s, size_type pos = npos) const$/;"	f	class:basic_string
rfind	g++/std/bastring.h	/^	size_type rfind(const basic_string& str, size_type pos = npos) const$/;"	f	class:basic_string
right	g++/parsestream.h	/^    char *right() const { return ebuf(); }$/;"	f	class:string_parsebuf
right	g++/stl_rope.h	/^    __rope_RopeBase<charT,Alloc>* right;$/;"	m	struct:__rope_RopeConcatenation
right	g++/stl_tree.h	/^	base_ptr 					 right;$/;"	m	struct:__rb_tree_node_base
right	g++/stl_tree.h	/^  static link_type& right(base_ptr x) { return (link_type&)(x->right); }$/;"	f	class:rb_tree
right	g++/stl_tree.h	/^  static link_type& right(link_type x) { return (link_type&)(x->right); }$/;"	f	class:rb_tree
right	g++/streambuf.h	/^	   left=_IO_LEFT, right=_IO_RIGHT, internal=_IO_INTERNAL,$/;"	e	enum:ios::__anon1
right	g++/streambuf.h	/^	   left=_IO_LEFT, right=_IO_RIGHT, internal=_IO_INTERNAL,$/;"	e	enum:ios::__anon72
rightmost	g++/stl_tree.h	/^  link_type& rightmost() const { return (link_type&) header->right; }$/;"	f	class:rb_tree
rightshift	bfd.h	/^  unsigned int rightshift;$/;"	m	struct:reloc_howto_struct
root	bfdlink.h	/^  struct bfd_hash_entry root;$/;"	m	struct:bfd_link_hash_entry	typeref:struct:bfd_link_hash_entry::bfd_hash_entry
root	g++/stl_rope.h	/^    RopeBase * root;     \/\/ The whole rope.$/;"	m	class:__rope_iterator_base
root	g++/stl_rope.h	/^    my_rope * root;     \/\/ The whole rope.$/;"	m	class:__rope_charT_ref_proxy
root	g++/stl_rope.h	/^    rope<charT,Alloc> * root;     \/\/ The whole rope.$/;"	m	class:__rope_charT_ptr_proxy
root	g++/stl_tree.h	/^  link_type& root() const { return (link_type&) header->parent; }$/;"	f	class:rb_tree
root	tk.h	/^    Window root;	    \/* root window that the event occured on *\/$/;"	m	struct:__anon34
root_rope	g++/stl_rope.h	/^    rope<charT,Alloc> * root_rope;$/;"	m	class:__rope_iterator
rope	g++/ropeimpl.h	/^rope<charT, Alloc>::rope(size_t n, charT c)$/;"	f	class:rope
rope	g++/stl_rope.h	/^	rope()$/;"	f	class:rope
rope	g++/stl_rope.h	/^	rope(RopeBase *t) : tree_ptr(t) { }$/;"	f	class:rope
rope	g++/stl_rope.h	/^	rope(charT c)$/;"	f	class:rope
rope	g++/stl_rope.h	/^	rope(char_producer<charT> *fn, size_t len, bool delete_fn)$/;"	f	class:rope
rope	g++/stl_rope.h	/^	rope(const charT *i, const charT *j)$/;"	f	class:rope
rope	g++/stl_rope.h	/^	rope(const charT *s)$/;"	f	class:rope
rope	g++/stl_rope.h	/^	rope(const charT *s, charT *e)$/;"	f	class:rope
rope	g++/stl_rope.h	/^	rope(const charT *s, size_t len)$/;"	f	class:rope
rope	g++/stl_rope.h	/^	rope(const const_iterator& s, const const_iterator& e)$/;"	f	class:rope
rope	g++/stl_rope.h	/^	rope(const iterator& s, const iterator& e)$/;"	f	class:rope
rope	g++/stl_rope.h	/^	rope(const rope &x)$/;"	f	class:rope
rope	g++/stl_rope.h	/^class rope {$/;"	c
rotate	g++/ropeimpl.h	/^inline void rotate(__rope_iterator<char,__ALLOC> first,$/;"	f
rotate	g++/stl_algo.h	/^inline void rotate(ForwardIterator first, ForwardIterator middle,$/;"	f
rotate_copy	g++/stl_algo.h	/^OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle,$/;"	f
rounded_up_size	g++/stl_rope.h	/^	static size_t rounded_up_size(size_t n) {$/;"	f	class:rope
rounded_up_size	g++/stl_rope.h	/^    static size_t rounded_up_size(size_t n) {$/;"	f	struct:__rope_RopeBase
rune_t	include/stddef.h	/^typedef _BSD_RUNE_T_ rune_t;$/;"	t
same_screen	tk.h	/^    Bool same_screen;	    \/* same screen flag *\/$/;"	m	struct:__anon34
sapp	g++/iomanip.h	/^template<class TP> class sapp {$/;"	c
savestring	readline/chardefs.h	8;"	d
saving	g++/streambuf.h	/^    int saving() { return  1; }$/;"	f	class:streammarker
sbuf	g++/parsestream.h	/^    streambuf *sbuf;$/;"	m	class:general_parsebuf
sbumpc	g++/streambuf.h	/^    int sbumpc() { return _IO_getc(this); }$/;"	f	struct:streambuf
scaleProc	tk.h	/^    Tk_ItemScaleProc *scaleProc;	\/* Procedure to rescale items of$/;"	m	struct:Tk_ItemType
scan	bfd.h	/^  boolean (*scan) PARAMS ((const struct bfd_arch_info *, const char *));$/;"	m	struct:bfd_arch_info
scanf	g++/iostdio.h	86;"	d
scientific	g++/streambuf.h	/^	   scientific=_IO_SCIENTIFIC, fixed=_IO_FIXED,$/;"	e	enum:ios::__anon1
scientific	g++/streambuf.h	/^	   scientific=_IO_SCIENTIFIC, fixed=_IO_FIXED,$/;"	e	enum:ios::__anon72
screenNum	tk.h	/^    int screenNum;$/;"	m	struct:Tk_FakeWin
search	g++/stl_algo.h	/^inline ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f
search_n	g++/stl_algo.h	/^ForwardIterator search_n(ForwardIterator first, ForwardIterator last,$/;"	f
sec	bfd.h	/^typedef struct sec$/;"	s
sec	tcl.h	/^    long sec;			\/* Seconds. *\/$/;"	m	struct:Tcl_Time
sec_ptr	bfd.h	/^typedef struct sec *sec_ptr;$/;"	t	typeref:struct:sec
second	g++/stl_pair.h	/^  T2 second;$/;"	m	struct:pair
second_argument_type	g++/stl_function.h	/^    typedef Arg2 second_argument_type;$/;"	t	struct:binary_function
second_type	g++/stl_pair.h	/^  typedef T2 second_type;$/;"	t	struct:pair
section	bfd.h	/^  struct sec *section;$/;"	m	struct:symbol_cache_entry	typeref:struct:symbol_cache_entry::sec
section	bfdlink.h	/^	      asection *section;		\/* Symbol section.  *\/$/;"	m	struct:bfd_link_hash_entry::__anon59::__anon63::bfd_link_hash_common_entry
section	bfdlink.h	/^	  asection *section;	\/* Symbol section.  *\/$/;"	m	struct:bfd_link_hash_entry::__anon59::__anon61
section	bfdlink.h	/^	  asection *section;$/;"	m	struct:bfd_link_order::__anon64::__anon65
section	bfdlink.h	/^      asection *section;$/;"	m	union:bfd_link_order_reloc::__anon69
section_align_power	bfd.h	/^  unsigned int section_align_power;$/;"	m	struct:bfd_arch_info
section_count	bfd.h	/^    unsigned int section_count;$/;"	m	struct:_bfd
section_flags	bfd.h	/^  flagword section_flags;$/;"	m	struct:bfd_target
sections	bfd.h	/^    struct sec  *sections;$/;"	m	struct:_bfd	typeref:struct:_bfd::sec
seek	g++/libio.h	/^  _IO_fpos_t (*seek) __P ((struct _IO_FILE *, _IO_off_t, int));$/;"	m	struct:__anon3
seek	g++/libio.h	/^  _IO_fpos_t (*seek) __P ((struct _IO_FILE *, _IO_off_t, int));$/;"	m	struct:__anon74
seekProc	tcl.h	/^    Tcl_DriverSeekProc *seekProc;	\/* Procedure to call to seek$/;"	m	struct:Tcl_ChannelType
seek_dir	g++/streambuf.h	/^    enum seek_dir { beg, cur, end};$/;"	g	class:ios
seekdir	g++/streambuf.h	/^    typedef enum seek_dir seekdir;$/;"	t	class:ios	typeref:enum:ios::seek_dir
selBorder	tk.h	/^    Tk_3DBorder selBorder;	\/* Border and background for selected$/;"	m	struct:Tk_CanvasTextInfo
selBorderWidth	tk.h	/^    int selBorderWidth;		\/* Width of border around selection. $/;"	m	struct:Tk_CanvasTextInfo
selFgColorPtr	tk.h	/^    XColor *selFgColorPtr;	\/* Foreground color for selected text.$/;"	m	struct:Tk_CanvasTextInfo
selItemPtr	tk.h	/^    Tk_Item *selItemPtr;	\/* Pointer to selected item.  NULL means$/;"	m	struct:Tk_CanvasTextInfo
select1st	g++/stl_function.h	/^struct select1st : public unary_function<Pair, typename Pair::first_type> {$/;"	s
select2nd	g++/stl_function.h	/^struct select2nd : public unary_function<Pair, typename Pair::second_type> {$/;"	s
selectAnchor	tk.h	/^    int selectAnchor;		\/* Fixed end of selection (i.e. "select to"$/;"	m	struct:Tk_CanvasTextInfo
selectFirst	tk.h	/^    int selectFirst;		\/* Index of first selected character. $/;"	m	struct:Tk_CanvasTextInfo
selectLast	tk.h	/^    int selectLast;		\/* Index of last selected character. $/;"	m	struct:Tk_CanvasTextInfo
selectionProc	tk.h	/^    Tk_ItemSelectionProc *selectionProc;\/* Procedure to return selection (in$/;"	m	struct:Tk_ItemType
self	g++/stl_deque.h	/^	typedef __deque_iterator 									self;$/;"	t	struct:std::__deque_iterator
self	g++/stl_iterator.h	/^                                         Distance> self;$/;"	t	class:reverse_bidirectional_iterator
self	g++/stl_iterator.h	/^        self;$/;"	t	class:reverse_iterator
self	g++/stl_iterator.h	/^  typedef reverse_iterator<Iterator> self;$/;"	t	class:reverse_iterator
self	g++/stl_list.h	/^	typedef __list_iterator<T, Ref, Ptr>           self;$/;"	t	struct:std::__list_iterator
self	g++/stl_slist.h	/^	typedef __slist_iterator<T, Ref, Ptr>           self;$/;"	t	struct:std::__slist_iterator
self	g++/stl_tree.h	/^	typedef __rb_tree_iterator<Value, Ref, Ptr>                   	self;$/;"	t	struct:__rb_tree_iterator
self_destruct_ptr	g++/stl_rope.h	/^	    typedef __rope_RopeBase<charT,Alloc> * self_destruct_ptr;$/;"	t	class:rope
self_destruct_ptr	g++/stl_rope.h	/^	    typedef __rope_self_destruct_ptr<charT,Alloc> self_destruct_ptr;$/;"	t	class:rope
self_destruct_ptr	g++/stl_rope.h	/^	typedef __rope_RopeBase<charT,Alloc> * self_destruct_ptr;$/;"	t	class:__rope_charT_ref_proxy
self_destruct_ptr	g++/stl_rope.h	/^    	typedef __rope_self_destruct_ptr<charT,Alloc> self_destruct_ptr;$/;"	t	class:__rope_charT_ref_proxy
selfish	g++/std/bastring.h	/^		bool selfish;$/;"	m	struct:basic_string::Rep
selfish	g++/std/bastring.h	/^	void selfish() { unique(); rep()->selfish = true; }$/;"	f	class:basic_string
send_event	tk.h	/^    Bool send_event;	    \/* True if this came from a SendEvent request *\/$/;"	m	struct:__anon34
send_event	tk.h	/^    Bool send_event;	    \/* True if this came from a SendEvent request *\/$/;"	m	struct:__anon35
sequence_buffer	g++/stl_rope.h	/^	sequence_buffer() : prefix(0), buf_count(0) {}$/;"	f	class:sequence_buffer
sequence_buffer	g++/stl_rope.h	/^	sequence_buffer(const sequence_buffer & x) {$/;"	f	class:sequence_buffer
sequence_buffer	g++/stl_rope.h	/^	sequence_buffer(sequence& s) : prefix(&s), buf_count(0) {}$/;"	f	class:sequence_buffer
sequence_buffer	g++/stl_rope.h	/^	sequence_buffer(sequence_buffer & x) {$/;"	f	class:sequence_buffer
sequence_buffer	g++/stl_rope.h	/^class sequence_buffer : public output_iterator {$/;"	c
serial	tk.h	/^    unsigned long serial;   \/* # of last request processed by server *\/$/;"	m	struct:__anon34
serial	tk.h	/^    unsigned long serial;   \/* # of last request processed by server *\/$/;"	m	struct:__anon35
set	g++/std/bastring.cc	/^set(size_t pos, const charT c, size_t n)$/;"	f	class:basic_string::Rep
set	g++/std/straits.h	/^	static char_type* set (char_type* s1, const char_type& c, size_t n)$/;"	f	struct:string_char_traits
set	g++/std/straits.h	/^  static char_type* set (char_type* s1, const char_type& c, size_t n)$/;"	f	struct:string_char_traits
set	g++/stl_set.h	/^  explicit set(const Compare& comp) : t(comp) {}$/;"	f	class:set
set	g++/stl_set.h	/^  set() : t(Compare()) {}$/;"	f	class:set
set	g++/stl_set.h	/^  set(InputIterator first, InputIterator last)$/;"	f	class:set
set	g++/stl_set.h	/^  set(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:set
set	g++/stl_set.h	/^  set(const set<Key, Compare, Alloc>& x) : t(x.t) {}$/;"	f	class:set
set	g++/stl_set.h	/^  set(const value_type* first, const value_type* last) $/;"	f	class:set
set	g++/stl_set.h	/^  set(const value_type* first, const value_type* last, const Compare& comp)$/;"	f	class:set
set	g++/stl_set.h	/^  set(const_iterator first, const_iterator last)$/;"	f	class:set
set	g++/stl_set.h	/^  set(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:set
set	g++/stl_set.h	/^class set {$/;"	c
set	g++/streambuf.h	/^    void set(iostate flag) { _state |= flag;$/;"	f	class:ios
setFromAnyProc	tcl.h	/^    Tcl_SetFromAnyProc *setFromAnyProc;$/;"	m	struct:Tcl_ObjType
setOptionProc	tcl.h	/^    Tcl_DriverSetOptionProc *setOptionProc;$/;"	m	struct:Tcl_ChannelType
set_debug	FlexLexer.h	/^	void set_debug( int flag )	{ yy_flex_debug = flag; }$/;"	f	class:FlexLexer
set_difference	g++/stl_algo.h	/^OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,$/;"	f
set_intersection	g++/stl_algo.h	/^OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1,$/;"	f
set_malloc_handler	g++/stl_alloc.h	/^	static void (* set_malloc_handler(void (*f)()))()$/;"	f	class:__malloc_alloc_template
set_node	g++/stl_deque.h	/^	void set_node(map_pointer new_node)    \/\/new_nodecur$/;"	f	struct:std::__deque_iterator
set_offset	g++/streambuf.h	/^    void set_offset(int offset) { _pos = offset; }$/;"	f	class:streammarker
set_symmetric_difference	g++/stl_algo.h	/^OutputIterator set_symmetric_difference(InputIterator1 first1,$/;"	f
set_union	g++/stl_algo.h	/^OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,$/;"	f
setbuf	g++/fstream.h	/^    void setbuf(char *ptr, int len) { rdbuf()->setbuf(ptr, len); }$/;"	f	class:fstreambase
setbuf	g++/iostdio.h	110;"	d
setbuf	g++/iostdio.h	87;"	d
setbuf	g++/ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::setbuf$/;"	f	class:__rope_iterator_base
setbuffer	g++/iostdio.h	88;"	d
setcache	g++/ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::setcache$/;"	f	class:__rope_iterator_base
setcache_for_incr	g++/ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::setcache_for_incr$/;"	f	class:__rope_iterator_base
setf	g++/streambuf.h	/^    fmtflags setf(fmtflags val) {$/;"	f	class:ios
setf	g++/streambuf.h	/^    fmtflags setf(fmtflags val, fmtflags mask) {$/;"	f	class:ios
setg	g++/streambuf.h	/^    void setg(char* eb, char* g, char *eg) {$/;"	f	struct:streambuf
setlinebuf	g++/iostdio.h	111;"	d
setp	g++/streambuf.h	/^    void setp(char* p, char* ep)$/;"	f	struct:streambuf
setsize	g++/SFile.h	/^    int       setsize(int s) { int old = sz; sz = s; return old; }$/;"	f	class:SFile
setstate	g++/streambuf.h	/^    void setstate(iostate flag) { _state |= flag; \/\/ ANSI$/;"	f	class:ios
setvbuf	g++/iostdio.h	89;"	d
sgetc	g++/streambuf.h	/^    int sgetc() { return _IO_peekc(this); }$/;"	f	struct:streambuf
sgetn	g++/streambuf.h	/^    streamsize sgetn(char* s, streamsize n) { return _IO_sgetn(this, s, n); }$/;"	f	struct:streambuf
sgi_core_data	bfd.h	/^      struct sgi_core_struct *sgi_core_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::sgi_core_struct
shared	bfdlink.h	/^  boolean shared;$/;"	m	struct:bfd_link_info
shortbuf	g++/streambuf.h	/^    char *shortbuf() { return _shortbuf; }$/;"	f	struct:streambuf
showbase	g++/streambuf.h	/^	   showbase=_IO_SHOWBASE, showpoint=_IO_SHOWPOINT,$/;"	e	enum:ios::__anon1
showbase	g++/streambuf.h	/^	   showbase=_IO_SHOWBASE, showpoint=_IO_SHOWPOINT,$/;"	e	enum:ios::__anon72
showpoint	g++/streambuf.h	/^	   showbase=_IO_SHOWBASE, showpoint=_IO_SHOWPOINT,$/;"	e	enum:ios::__anon1
showpoint	g++/streambuf.h	/^	   showbase=_IO_SHOWBASE, showpoint=_IO_SHOWPOINT,$/;"	e	enum:ios::__anon72
showpos	g++/streambuf.h	/^	   uppercase=_IO_UPPERCASE, showpos=_IO_SHOWPOS,$/;"	e	enum:ios::__anon1
showpos	g++/streambuf.h	/^	   uppercase=_IO_UPPERCASE, showpos=_IO_SHOWPOS,$/;"	e	enum:ios::__anon72
simple_alloc	g++/stl_alloc.h	/^class simple_alloc $/;"	c
sin	g++/std/complext.cc	/^sin (const complex<FLOAT>& x)$/;"	f
single_client_alloc	g++/stl_alloc.h	/^typedef __default_alloc_template<false, 0> single_client_alloc;$/;"	t
single_client_alloc	g++/stl_alloc.h	/^typedef malloc_alloc single_client_alloc;$/;"	t
sinh	g++/std/complext.cc	/^sinh (const complex<FLOAT>& x)$/;"	f
size	bfd.h	/^  bfd_size_type size;$/;"	m	struct:_bfd_window
size	bfd.h	/^  int size;$/;"	m	struct:reloc_howto_struct
size	bfd.h	/^  unsigned int size;$/;"	m	struct:bfd_hash_table
size	bfdlink.h	/^	  bfd_size_type size;	\/* Common symbol size.  *\/$/;"	m	struct:bfd_link_hash_entry::__anon59::__anon63
size	bfdlink.h	/^  bfd_size_type size;$/;"	m	struct:bfd_link_order
size	g++/SFile.h	/^    int       size() { return sz; }$/;"	f	class:SFile
size	g++/std/bastring.h	/^	size_type size() const{ return rep()->len; }$/;"	f	class:basic_string
size	g++/stl_bvector.h	/^  size_type size() const { return size_type(end() - begin()); }$/;"	f	class:vector
size	g++/stl_deque.h	/^	size_type size() const { return finish - start; }$/;"	f	class:std::deque
size	g++/stl_hash_map.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_map
size	g++/stl_hash_map.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_multimap
size	g++/stl_hash_set.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_multiset
size	g++/stl_hash_set.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_set
size	g++/stl_hashtable.h	/^  size_type size() const { return num_elements; }$/;"	f	class:hashtable
size	g++/stl_list.h	/^	size_type size() const {$/;"	f	class:std::list
size	g++/stl_map.h	/^  size_type size() const { return t.size(); }$/;"	f	class:map
size	g++/stl_multimap.h	/^  size_type size() const { return t.size(); }$/;"	f	class:multimap
size	g++/stl_multiset.h	/^  size_type size() const { return t.size(); }$/;"	f	class:multiset
size	g++/stl_queue.h	/^	size_type size() const { return c.size(); }$/;"	f	class:priority_queue
size	g++/stl_queue.h	/^	size_type size() const { return c.size(); }$/;"	f	class:queue
size	g++/stl_rope.h	/^	size_type size() const { $/;"	f	class:rope
size	g++/stl_rope.h	/^    size_t size;$/;"	m	struct:__rope_RopeBase
size	g++/stl_set.h	/^  size_type size() const { return t.size(); }$/;"	f	class:set
size	g++/stl_slist.h	/^	size_type size() const { return __slist_size(head.next); }$/;"	f	class:std::slist
size	g++/stl_stack.h	/^  size_type size() const { return c.size(); }$/;"	f	class:stack
size	g++/stl_tempbuf.h	/^  ptrdiff_t size() const { return len; }$/;"	f	class:temporary_buffer
size	g++/stl_tree.h	/^  size_type size() const { return node_count; }$/;"	f	class:rb_tree
size	g++/stl_vector.h	/^	size_type size() const { return size_type(end() - begin()); }$/;"	f	class:vector
size1	g++/editbuf.h	/^    inline int size1() { return gap_start() - data; }$/;"	f	struct:edit_buffer
size2	g++/editbuf.h	/^    inline int size2() { return buf_size - gap_end_pos(); }$/;"	f	struct:edit_buffer
size_t	include/stddef.h	/^typedef __SIZE_TYPE__ size_t;$/;"	t
size_type	g++/defalloc.h	/^    typedef size_t size_type;$/;"	t	class:allocator
size_type	g++/std/bastring.h	/^	typedef size_t 									size_type;$/;"	t	class:basic_string
size_type	g++/stl_bvector.h	/^  typedef size_t size_type;$/;"	t	class:vector
size_type	g++/stl_deque.h	/^	typedef size_t 												size_type;$/;"	t	struct:std::__deque_iterator
size_type	g++/stl_deque.h	/^	typedef size_t 											size_type;$/;"	t	class:std::deque
size_type	g++/stl_hash_map.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_map
size_type	g++/stl_hash_map.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_multimap
size_type	g++/stl_hash_set.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_multiset
size_type	g++/stl_hash_set.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_set
size_type	g++/stl_hashtable.h	/^  typedef size_t            size_type;$/;"	t	class:hashtable
size_type	g++/stl_hashtable.h	/^  typedef size_t size_type;$/;"	t	struct:__hashtable_const_iterator
size_type	g++/stl_hashtable.h	/^  typedef size_t size_type;$/;"	t	struct:__hashtable_iterator
size_type	g++/stl_list.h	/^	typedef size_t 									size_type;$/;"	t	class:std::list
size_type	g++/stl_list.h	/^	typedef size_t size_type;$/;"	t	struct:std::__list_iterator
size_type	g++/stl_map.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:map
size_type	g++/stl_multimap.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:multimap
size_type	g++/stl_multiset.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:multiset
size_type	g++/stl_queue.h	/^	typedef typename Sequence::size_type size_type;$/;"	t	class:priority_queue
size_type	g++/stl_queue.h	/^	typedef typename Sequence::size_type size_type;$/;"	t	class:queue
size_type	g++/stl_rope.h	/^	typedef size_t size_type;$/;"	t	class:rope
size_type	g++/stl_set.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:set
size_type	g++/stl_slist.h	/^	typedef size_t 									size_type;$/;"	t	class:std::slist
size_type	g++/stl_slist.h	/^	typedef size_t 					size_type;$/;"	t	struct:std::__slist_iterator_base
size_type	g++/stl_stack.h	/^  typedef typename Sequence::size_type size_type;$/;"	t	class:stack
size_type	g++/stl_tree.h	/^  typedef size_t size_type;$/;"	t	class:rb_tree
size_type	g++/stl_vector.h	/^	typedef size_t 			  					size_type;$/;"	t	class:vector
skipws	g++/streambuf.h	/^    enum { skipws=_IO_SKIPWS,$/;"	e	enum:ios::__anon1
skipws	g++/streambuf.h	/^    enum { skipws=_IO_SKIPWS,$/;"	e	enum:ios::__anon72
slist	g++/stl_slist.h	/^	explicit slist(size_type n) { fill_initialize(n, value_type()); }$/;"	f	class:std::slist
slist	g++/stl_slist.h	/^	slist() { head.next = 0; }$/;"	f	class:std::slist
slist	g++/stl_slist.h	/^	slist(InputIterator first, InputIterator last) {$/;"	f	class:std::slist
slist	g++/stl_slist.h	/^	slist(const slist& L) { range_initialize(L.begin(), L.end()); }$/;"	f	class:std::slist
slist	g++/stl_slist.h	/^	slist(int n, const value_type& x) { fill_initialize(n, x); }$/;"	f	class:std::slist
slist	g++/stl_slist.h	/^	slist(long n, const value_type& x) { fill_initialize(n, x); }$/;"	f	class:std::slist
slist	g++/stl_slist.h	/^	slist(size_type n, const value_type& x) { fill_initialize(n, x); }$/;"	f	class:std::slist
slist	g++/stl_slist.h	/^class slist$/;"	c	namespace:std
smanip	g++/iomanip.h	/^template <class TP> class smanip {$/;"	c
snextc	g++/streambuf.h	/^    int snextc() {$/;"	f	struct:streambuf
som_data	bfd.h	/^      struct som_data_struct *som_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::som_data_struct
sort	g++/stl_algo.h	/^inline void sort(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f
sort	g++/stl_algo.h	/^inline void sort(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
sort	g++/stl_list.h	/^void list<T, Alloc>::sort() {$/;"	f	class:std::list
sort	g++/stl_list.h	/^void list<T, Alloc>::sort(StrictWeakOrdering comp) $/;"	f	class:std::list
sort	g++/stl_slist.h	/^void slist<T,Alloc>::sort()$/;"	f	class:std::slist
sort	g++/stl_slist.h	/^void slist<T,Alloc>::sort(StrictWeakOrdering comp)$/;"	f	class:std::slist
sort_heap	g++/stl_heap.h	/^void sort_heap(RandomAccessIterator first, RandomAccessIterator last) $/;"	f
sort_heap	g++/stl_heap.h	/^void sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp) $/;"	f
spaceAvl	tcl.h	/^    int spaceAvl;		\/* Total number of bytes available for the$/;"	m	struct:Tcl_DString
specFlags	tk.h	/^    int specFlags;		\/* Any combination of the values defined$/;"	m	struct:Tk_ConfigSpec
special_function	bfd.h	/^  bfd_reloc_status_type (*special_function)$/;"	m	struct:reloc_howto_struct
splice	g++/stl_list.h	/^	void splice(iterator position, list& x) {$/;"	f	class:std::list
splice	g++/stl_list.h	/^	void splice(iterator position, list&, iterator first, iterator last){$/;"	f	class:std::list
splice	g++/stl_list.h	/^	void splice(iterator position, list&, iterator i) {$/;"	f	class:std::list
splice	g++/stl_slist.h	/^	void splice(iterator pos, slist& L) {$/;"	f	class:std::slist
splice	g++/stl_slist.h	/^	void splice(iterator pos, slist& L, iterator first, iterator last){$/;"	f	class:std::slist
splice	g++/stl_slist.h	/^	void splice(iterator pos, slist& L, iterator i) {$/;"	f	class:std::slist
splice_after	g++/stl_slist.h	/^	void splice_after(iterator pos, iterator before_first, iterator before_last){$/;"	f	class:std::slist
splice_after	g++/stl_slist.h	/^	void splice_after(iterator pos, iterator prev){$/;"	f	class:std::slist
sprintf	g++/iostdio.h	90;"	d
sprintf_vma	bfd.h	147;"	d
sprintf_vma	bfd.h	154;"	d
sprintf_vma	bfd.h	177;"	d
sputc	g++/streambuf.h	/^    int sputc(int c) { return _IO_putc(c, this); }$/;"	f	struct:streambuf
sputn	g++/streambuf.h	/^    streamsize sputn(const char* s, streamsize n) { return xsputn(s, n); }$/;"	f	struct:streambuf
sqrt	g++/std/complext.cc	/^sqrt (const complex<FLOAT>& x)$/;"	f
src	tk.h	/^    char *src;		\/* Value to be used in setting dst;  usage$/;"	m	struct:__anon30
src_mask	bfd.h	/^  bfd_vma src_mask;$/;"	m	struct:reloc_howto_struct
srec_data	bfd.h	/^      struct srec_data_struct *srec_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::srec_data_struct
sscanf	g++/iostdio.h	91;"	d
ssize_t	include/stddef.h	/^typedef long ssize_t;$/;"	t
stab_desc	bfd.h	/^  short stab_desc;             \/* Stab desc.  *\/$/;"	m	struct:_symbol_info
stab_name	bfd.h	/^  CONST char *stab_name;       \/* String for stab type.  *\/$/;"	m	struct:_symbol_info
stab_other	bfd.h	/^  char stab_other;             \/* Stab other. *\/$/;"	m	struct:_symbol_info
stab_type	bfd.h	/^  unsigned char stab_type;     \/* Stab type.  *\/$/;"	m	struct:_symbol_info
stable_partition	g++/stl_algo.h	/^inline ForwardIterator stable_partition(ForwardIterator first,$/;"	f
stable_sort	g++/stl_algo.h	/^inline void stable_sort(RandomAccessIterator first,$/;"	f
stack	g++/stl_stack.h	/^class stack {$/;"	c
start	g++/editbuf.h	/^    struct edit_mark *start, *end;$/;"	m	struct:edit_string	typeref:struct:edit_string::edit_mark
start	g++/stl_bvector.h	/^  iterator start;$/;"	m	class:vector
start	g++/stl_deque.h	/^	iterator start;     \/\/$/;"	m	class:std::deque
start	g++/stl_rope.h	/^    size_t start;$/;"	m	struct:__rope_RopeSubstring
start	g++/stl_vector.h	/^	iterator 									start;$/;"	m	class:vector
start	readline/readline.h	/^  int start, end;		\/* Where the change took place. *\/$/;"	m	struct:undo_list
start_address	bfd.h	/^    bfd_vma start_address;$/;"	m	struct:_bfd
start_free	g++/stl_alloc.h	/^	static char* start_free;   \/\/ chunk_alloc() $/;"	m	class:__default_alloc_template
start_free	g++/stl_alloc.h	/^char* __default_alloc_template<threads, inst>::start_free = 0;$/;"	m	class:__default_alloc_template
start_mark	g++/editbuf.h	/^    struct edit_mark start_mark;$/;"	m	struct:edit_buffer	typeref:struct:edit_buffer::edit_mark
start_marker	g++/editbuf.h	/^    inline struct edit_mark *start_marker() { return &start_mark; }$/;"	f	struct:edit_buffer
started	tix.h	/^    unsigned int started : 1;   \/* True if the search operation has$/;"	m	struct:Tix_ListIterator
startp	tclRegexp.h	/^	char *startp[NSUBEXP];$/;"	m	struct:regexp
stat_type	bfd.h	/^typedef struct stat stat_type; $/;"	t	typeref:struct:stat
state	tk.h	/^    unsigned int state;	    \/* key or button mask *\/$/;"	m	struct:__anon34
state_value	g++/streambuf.h	/^enum state_value {$/;"	g
staticBuckets	tcl.h	/^    Tcl_HashEntry *staticBuckets[TCL_SMALL_HASH_TABLE];$/;"	m	struct:Tcl_HashTable
staticSpace	tcl.h	/^    char staticSpace[TCL_DSTRING_STATIC_SIZE];$/;"	m	struct:Tcl_DString
staticTagSpace	tk.h	/^    Tk_Uid staticTagSpace[TK_TAG_SPACE];\/* Built-in space for limited # of$/;"	m	struct:Tk_Item
static_link	bfdlink.h	/^  boolean static_link;$/;"	m	struct:bfd_link_info
std	g++/stl_construct.h	/^namespace std{$/;"	n
std	g++/stl_deque.h	/^namespace std{ $/;"	n
std	g++/stl_list.h	/^namespace std$/;"	n
std	g++/stl_slist.h	/^namespace std{$/;"	n
std	g++/stl_uninitialized.h	/^namespace std{$/;"	n
stderr	g++/iostdio.h	57;"	d
stdin	g++/iostdio.h	55;"	d
stdio	g++/streambuf.h	/^	   unitbuf=_IO_UNITBUF, stdio=_IO_STDIO$/;"	e	enum:ios::__anon1
stdio	g++/streambuf.h	/^	   unitbuf=_IO_UNITBUF, stdio=_IO_STDIO$/;"	e	enum:ios::__anon72
stdiobuf	g++/stdiostream.h	/^class stdiobuf : public filebuf {$/;"	c
stdiofile	g++/stdiostream.h	/^    FILE* stdiofile() const { return _file; }$/;"	f	class:stdiobuf
stdout	g++/iostdio.h	56;"	d
stossc	g++/streambuf.h	/^    void stossc() { if (_IO_read_ptr < _IO_read_end) _IO_read_ptr++; }$/;"	f	struct:streambuf
str	g++/editbuf.h	/^    edit_string *str;$/;"	m	struct:edit_streambuf
str	g++/strstream.h	/^    char *str() { return ((strstreambuf*)_strbuf)->str(); }$/;"	f	class:ostrstream
str	g++/strstream.h	/^    char *str() { return ((strstreambuf*)_strbuf)->str(); }$/;"	f	class:strstream
strcasecmp	tix.h	450;"	d
strdup	tix.h	436;"	d
stream	g++/stl_iterator.h	/^  istream* stream;$/;"	m	class:istream_iterator
stream	g++/stl_iterator.h	/^  ostream* stream;$/;"	m	class:ostream_iterator
streambuf	g++/streambuf.h	/^struct streambuf : public _IO_FILE { \/\/ protected??$/;"	s
streammarker	g++/streambuf.h	/^class streammarker : private _IO_marker {$/;"	c
streamoff	g++/streambuf.h	/^typedef _IO_off64_t streamoff;$/;"	t
streamoff	g++/streambuf.h	/^typedef _IO_off_t streamoff;$/;"	t
streampos	g++/streambuf.h	/^typedef _IO_fpos64_t streampos;$/;"	t
streampos	g++/streambuf.h	/^typedef _IO_fpos_t streampos;$/;"	t
streamsize	g++/streambuf.h	/^    typedef int streamsize;$/;"	t	class:ios
streamsize	g++/streambuf.h	/^typedef _IO_ssize_t streamsize;$/;"	t
string	bfd.h	/^  const char *string;$/;"	m	struct:bfd_hash_entry
string	g++/stl_iterator.h	/^  const char* string;$/;"	m	class:ostream_iterator
string	tcl.h	/^	char string[4];			\/* String for key.  The actual size$/;"	m	union:Tcl_HashEntry::__anon56
string	tcl.h	/^    char *string;		\/* Points to beginning of string:  either$/;"	m	struct:Tcl_DString
stringMatchProc	tk.h	/^    Tk_ImageStringMatchProc *stringMatchProc;$/;"	m	struct:Tk_PhotoImageFormat
stringReadProc	tk.h	/^    Tk_ImageStringReadProc *stringReadProc;$/;"	m	struct:Tk_PhotoImageFormat
stringWriteProc	tk.h	/^    Tk_ImageStringWriteProc *stringWriteProc;$/;"	m	struct:Tk_PhotoImageFormat
string_char_traits	g++/std/straits.h	/^struct string_char_traits $/;"	s
string_char_traits	g++/std/straits.h	/^struct string_char_traits <char> {$/;"	s
string_parsebuf	g++/parsestream.h	/^class string_parsebuf : public parsebuf {$/;"	c
strip	bfdlink.h	/^  enum bfd_link_strip strip;$/;"	m	struct:bfd_link_info	typeref:enum:bfd_link_info::bfd_link_strip
strip_all	bfdlink.h	/^  strip_all		\/* Strip all symbols.  *\/$/;"	e	enum:bfd_link_strip
strip_debugger	bfdlink.h	/^  strip_debugger,	\/* Strip debugging symbols.  *\/$/;"	e	enum:bfd_link_strip
strip_none	bfdlink.h	/^  strip_none,		\/* Don't strip any symbols.  *\/$/;"	e	enum:bfd_link_strip
strip_some	bfdlink.h	/^  strip_some,		\/* keep_hash is the list of symbols to keep.  *\/$/;"	e	enum:bfd_link_strip
strstream	g++/strstream.h	/^    strstream(char *cp, int n, int mode=ios::out) :strstreambase(cp,n,mode){}$/;"	f	class:strstream
strstream	g++/strstream.h	/^  strstream() { }$/;"	f	class:strstream
strstream	g++/strstream.h	/^class strstream : public strstreambase, public iostream {$/;"	c
strstreambase	g++/strstream.h	/^    strstreambase() { init (&__my_sb); }$/;"	f	class:strstreambase
strstreambase	g++/strstream.h	/^class strstreambase : virtual public ios {$/;"	c
strstreambuf	g++/strstream.h	/^    strstreambuf() { init_dynamic(0, 0); }$/;"	f	class:strstreambuf
strstreambuf	g++/strstream.h	/^    strstreambuf(char *ptr, int size, char *pstart = NULL)$/;"	f	class:strstreambuf
strstreambuf	g++/strstream.h	/^    strstreambuf(const char *ptr, int size)$/;"	f	class:strstreambuf
strstreambuf	g++/strstream.h	/^    strstreambuf(const signed char *ptr, int size)$/;"	f	class:strstreambuf
strstreambuf	g++/strstream.h	/^    strstreambuf(const unsigned char *ptr, int size)$/;"	f	class:strstreambuf
strstreambuf	g++/strstream.h	/^    strstreambuf(int initial_size) { init_dynamic(0, 0, initial_size); }$/;"	f	class:strstreambuf
strstreambuf	g++/strstream.h	/^    strstreambuf(signed char *ptr, int size, signed char *pstart = NULL)$/;"	f	class:strstreambuf
strstreambuf	g++/strstream.h	/^    strstreambuf(unsigned char *ptr, int size, unsigned char *pstart = NULL)$/;"	f	class:strstreambuf
strstreambuf	g++/strstream.h	/^    strstreambuf(void *(*alloc)(_IO_size_t), void (*free)(void*))$/;"	f	class:strstreambuf
strstreambuf	g++/strstream.h	/^class strstreambuf : public streambuf$/;"	c
substr	g++/std/bastring.h	/^	basic_string substr (size_type pos = 0, size_type n = npos) const$/;"	f	class:basic_string
substr	g++/stl_rope.h	/^	rope substr(const_iterator start, const_iterator end) const {$/;"	f	class:rope
substr	g++/stl_rope.h	/^	rope substr(iterator start) const {$/;"	f	class:rope
substr	g++/stl_rope.h	/^	rope substr(iterator start, iterator end) const {$/;"	f	class:rope
substr	g++/stl_rope.h	/^	rope substr(size_t start, size_t len = 1) const {$/;"	f	class:rope
substr	g++/stl_rope.h	/^	rope<charT,Alloc> substr(const_iterator start) {$/;"	f	class:rope
substring	g++/ropeimpl.h	/^rope<charT,Alloc>::substring(RopeBase * base, size_t start, size_t endp1)$/;"	f	class:rope
substringfn	g++/stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon80
substringfn	g++/stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon9
subtractive_rng	g++/stl_function.h	/^  subtractive_rng() { initialize(161803398u); }$/;"	f	class:subtractive_rng
subtractive_rng	g++/stl_function.h	/^  subtractive_rng(unsigned int seed) { initialize(seed); }$/;"	f	class:subtractive_rng
subtractive_rng	g++/stl_function.h	/^class subtractive_rng : public unary_function<unsigned int, unsigned int> {$/;"	c
subwindow	tk.h	/^    Window subwindow;	    \/* child window *\/$/;"	m	struct:__anon34
sun_core_data	bfd.h	/^      struct sun_core_struct *sun_core_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::sun_core_struct
swap	g++/std/bastring.h	/^	void swap(basic_string &s) { charT *d = dat; dat = s.dat; s.dat = d; }$/;"	f	class:basic_string
swap	g++/stl_algobase.h	/^swap(T& a, T& b) {$/;"	f
swap	g++/stl_bvector.h	/^  void swap(__BVECTOR& x) {$/;"	f	class:vector
swap	g++/stl_bvector.h	/^inline void swap(__bit_reference x, __bit_reference y) {$/;"	f
swap	g++/stl_deque.h	/^	void swap(deque& x) $/;"	f	class:std::deque
swap	g++/stl_deque.h	/^inline void swap(deque<T, Alloc, BufSiz>& x, deque<T, Alloc, BufSiz>& y)$/;"	f	namespace:std
swap	g++/stl_hash_map.h	/^  void swap(hash_map& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_map
swap	g++/stl_hash_map.h	/^  void swap(hash_multimap& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_multimap
swap	g++/stl_hash_map.h	/^inline void swap(hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1,$/;"	f
swap	g++/stl_hash_map.h	/^inline void swap(hash_multimap<Key, T, HashFcn, EqualKey, Alloc>& hm1,$/;"	f
swap	g++/stl_hash_set.h	/^  void swap(hash_multiset& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_multiset
swap	g++/stl_hash_set.h	/^  void swap(hash_set& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_set
swap	g++/stl_hash_set.h	/^inline void swap(hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs1,$/;"	f
swap	g++/stl_hash_set.h	/^inline void swap(hash_set<Val, HashFcn, EqualKey, Alloc>& hs1,$/;"	f
swap	g++/stl_hashtable.h	/^  void swap(hashtable& ht)$/;"	f	class:hashtable
swap	g++/stl_hashtable.h	/^inline void swap(hashtable<Val, Key, HF, Extract, EqKey, A>& ht1,$/;"	f
swap	g++/stl_list.h	/^	void swap(list<T, Alloc>& x) { $/;"	f	class:std::list
swap	g++/stl_list.h	/^inline void swap(list<T, Alloc>& x, list<T, Alloc>& y) {$/;"	f	namespace:std
swap	g++/stl_map.h	/^  void swap(map<Key, T, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:map
swap	g++/stl_map.h	/^inline void swap(map<Key, T, Compare, Alloc>& x, $/;"	f
swap	g++/stl_multimap.h	/^  void swap(multimap<Key, T, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:multimap
swap	g++/stl_multimap.h	/^inline void swap(multimap<Key, T, Compare, Alloc>& x, $/;"	f
swap	g++/stl_multiset.h	/^  void swap(multiset<Key, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:multiset
swap	g++/stl_multiset.h	/^inline void swap(multiset<Key, Compare, Alloc>& x, $/;"	f
swap	g++/stl_rope.h	/^	void swap(rope& b) {$/;"	f	class:rope
swap	g++/stl_rope.h	/^inline void swap(crope x, crope y) { x.swap(y); }$/;"	f
swap	g++/stl_rope.h	/^inline void swap(rope<charT, Alloc>& x, rope<charT, Alloc>& y) {$/;"	f
swap	g++/stl_rope.h	/^inline void swap(wrope x, wrope y) { x.swap(y); }$/;"	f
swap	g++/stl_set.h	/^  void swap(set<Key, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:set
swap	g++/stl_set.h	/^inline void swap(set<Key, Compare, Alloc>& x, $/;"	f
swap	g++/stl_slist.h	/^	void swap(slist& L)$/;"	f	class:std::slist
swap	g++/stl_slist.h	/^inline void swap(slist<T, Alloc>& x, slist<T, Alloc>& y) {$/;"	f	namespace:std
swap	g++/stl_tree.h	/^  void swap(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& t) {$/;"	f	class:rb_tree
swap	g++/stl_tree.h	/^inline void swap(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, $/;"	f
swap	g++/stl_vector.h	/^	void swap(vector<T, Alloc>& x) $/;"	f	class:vector
swap	g++/stl_vector.h	/^inline void swap(vector<T, Alloc>& x, vector<T, Alloc>& y) $/;"	f
swap_lock	g++/ropeimpl.h	/^    pthread_mutex_t rope<charT,Alloc>::swap_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	m	class:rope
swap_lock	g++/stl_rope.h	/^	    static pthread_mutex_t swap_lock;$/;"	m	class:rope
swap_ranges	g++/stl_algo.h	/^ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f
sym	bfd.h	/^    struct symbol_cache_entry *sym; \/* Function name *\/$/;"	m	union:lineno_cache_entry::__anon36	typeref:struct:lineno_cache_entry::__anon36::symbol_cache_entry
sym_ptr_ptr	bfd.h	/^  struct symbol_cache_entry **sym_ptr_ptr;$/;"	m	struct:reloc_cache_entry	typeref:struct:reloc_cache_entry::symbol_cache_entry
symbol	bfd.h	/^   struct symbol_cache_entry *symbol;$/;"	m	struct:sec	typeref:struct:sec::symbol_cache_entry
symbol_cache_entry	bfd.h	/^typedef struct symbol_cache_entry$/;"	s
symbol_info	bfd.h	/^} symbol_info;$/;"	t	typeref:struct:_symbol_info
symbol_leading_char	bfd.h	/^  char symbol_leading_char;$/;"	m	struct:bfd_target
symbol_ptr_ptr	bfd.h	/^   struct symbol_cache_entry **symbol_ptr_ptr;$/;"	m	struct:sec	typeref:struct:sec::symbol_cache_entry
symbolic	bfdlink.h	/^  boolean symbolic;$/;"	m	struct:bfd_link_info
symcount	bfd.h	/^    unsigned int symcount;$/;"	m	struct:_bfd
symindex	bfd.h	/^typedef unsigned long symindex;$/;"	t
symvalue	bfd.h	/^typedef BFD_HOST_U_64_BIT symvalue;$/;"	t
symvalue	bfd.h	/^typedef unsigned long symvalue;$/;"	t
sync_with_stdio	g++/streambuf.h	/^    static void sync_with_stdio() { sync_with_stdio(1); }$/;"	f	class:ios
sz	g++/SFile.h	/^    int       sz;                   \/\/ unit size for structured binary IO$/;"	m	class:SFile
t	g++/stl_map.h	/^  rep_type t;  \/\/ red-black tree representing map$/;"	m	class:map
t	g++/stl_multimap.h	/^  rep_type t;  \/\/ red-black tree representing multimap$/;"	m	class:multimap
t	g++/stl_multiset.h	/^  rep_type t;  \/\/ red-black tree representing multiset$/;"	m	class:multiset
t	g++/stl_set.h	/^  rep_type t;  \/\/ red-black tree representing set$/;"	m	class:set
table	bfd.h	/^  struct bfd_hash_entry **table;$/;"	m	struct:bfd_hash_table	typeref:struct:bfd_hash_table::bfd_hash_entry
table	bfdlink.h	/^  struct bfd_hash_table table;$/;"	m	struct:bfd_link_hash_table	typeref:struct:bfd_link_hash_table::bfd_hash_table
table	g++/stl_function.h	/^  unsigned int table[55];$/;"	m	class:subtractive_rng
tablePtr	tcl.h	/^    Tcl_HashTable *tablePtr;		\/* Table being searched. *\/$/;"	m	struct:Tcl_HashSearch
tablePtr	tcl.h	/^    struct Tcl_HashTable *tablePtr;	\/* Pointer to table containing entry. *\/$/;"	m	struct:Tcl_HashEntry	typeref:struct:Tcl_HashEntry::Tcl_HashTable
tag	g++/stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	m	struct:__rope_RopeBase	typeref:enum:__rope_RopeBase::__anon80
tag	g++/stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	m	struct:__rope_RopeBase	typeref:enum:__rope_RopeBase::__anon9
tagPtr	tk.h	/^    Tk_Uid *tagPtr;			\/* Pointer to array of tags.  Usually$/;"	m	struct:Tk_Item
tagSpace	tk.h	/^    int tagSpace;			\/* Total amount of tag space available$/;"	m	struct:Tk_Item
tail	tix.h	/^    char * tail;		\/* (general pointer) tail of the list *\/$/;"	m	struct:Tix_LinkList
target_defaulted	bfd.h	/^    boolean target_defaulted;$/;"	m	struct:_bfd
target_index	bfd.h	/^   int target_index;$/;"	m	struct:sec
task_link	bfdlink.h	/^  boolean task_link;$/;"	m	struct:bfd_link_info
tdata	bfd.h	/^      } tdata;$/;"	m	struct:_bfd	typeref:union:_bfd::__anon38
tekhex_data	bfd.h	/^      struct tekhex_data_struct *tekhex_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::tekhex_data_struct
temporary_buffer	g++/stl_tempbuf.h	/^  temporary_buffer(ForwardIterator first, ForwardIterator last) {$/;"	f	class:temporary_buffer
temporary_buffer	g++/stl_tempbuf.h	/^  temporary_buffer(const temporary_buffer&) {}$/;"	f	class:temporary_buffer
temporary_buffer	g++/stl_tempbuf.h	/^class temporary_buffer {$/;"	c
terminate	g++/std/bastring.h	/^	void terminate() const$/;"	f	class:basic_string
text	readline/readline.h	/^  char *text;			\/* The text to insert, if undoing a delete. *\/$/;"	m	struct:undo_list
the_bfd	bfd.h	/^  struct _bfd *the_bfd;  \/* Use bfd_asymbol_bfd(sym) to access this field. *\/$/;"	m	struct:symbol_cache_entry	typeref:struct:symbol_cache_entry::_bfd
the_default	bfd.h	/^  boolean the_default; $/;"	m	struct:bfd_arch_info
this_dummy_member_must_be_first	g++/type_traits.h	/^	typedef __true_type     this_dummy_member_must_be_first;$/;"	t	struct:__type_traits
tie	g++/streambuf.h	/^    ostream* tie() const { return _tie; }$/;"	f	class:ios
tie	g++/streambuf.h	/^    ostream* tie(ostream* val) { ostream* save=_tie; _tie=val; return save; }$/;"	f	class:ios
time	tk.h	/^    Time time;		    \/* milliseconds *\/$/;"	m	struct:__anon34
tmp_buf	g++/stl_rope.h	/^    charT tmp_buf[iterator_buf_len];$/;"	m	class:__rope_iterator_base
to_lower	readline/chardefs.h	41;"	d
to_upper	readline/chardefs.h	40;"	d
top	g++/stl_queue.h	/^	const_reference top() const { return c.front(); }$/;"	f	class:priority_queue
top	g++/stl_stack.h	/^  const_reference top() const { return c.back(); }$/;"	f	class:stack
top	g++/stl_stack.h	/^  reference top() { return c.back(); }$/;"	f	class:stack
trad_core_data	bfd.h	/^      struct trad_core_struct *trad_core_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::trad_core_struct
traditional_format	bfdlink.h	/^  boolean traditional_format;$/;"	m	struct:bfd_link_info
traits_type	g++/std/bastring.h	/^	typedef traits									traits_type;$/;"	t	class:basic_string
transfer	g++/stl_list.h	/^	void transfer(iterator position, iterator first, iterator last){$/;"	f	class:std::list
transform	g++/stl_algo.h	/^OutputIterator transform(InputIterator first, InputIterator last,$/;"	f
transform	g++/stl_algo.h	/^OutputIterator transform(InputIterator1 first1, InputIterator1 last1,$/;"	f
translateProc	tk.h	/^    Tk_ItemTranslateProc *translateProc;\/* Procedure to translate items of$/;"	m	struct:Tk_ItemType
tree_concat	g++/ropeimpl.h	/^rope<charT,Alloc>::tree_concat (RopeBase * left, RopeBase * right)$/;"	f	class:rope
tree_ptr	g++/stl_rope.h	/^	RopeBase *tree_ptr;$/;"	m	class:rope
true	bfd.h	/^typedef enum bfd_boolean {false, true} boolean;$/;"	e	enum:bfd_boolean
true	g++/stl_config.h	180;"	d
true	include/stdbool.h	/^    true = 1$/;"	e	enum:__anon14
true	include/stdbool.h	/^    true = 1$/;"	e	enum:__anon39
true	include/stdbool.h	15;"	d
trunc	g++/streambuf.h	/^	trunc = _IO_TRUNC,$/;"	e	enum:ios::open_mode
twoPtrValue	tcl.h	/^	} twoPtrValue;$/;"	m	union:Tcl_Obj::__anon54	typeref:struct:Tcl_Obj::__anon54::__anon55
type	bfd.h	/^  char type;$/;"	m	struct:_symbol_info
type	bfd.h	/^  unsigned int type;$/;"	m	struct:reloc_howto_struct
type	bfdlink.h	/^  enum bfd_link_hash_type type;$/;"	m	struct:bfd_link_hash_entry	typeref:enum:bfd_link_hash_entry::bfd_link_hash_type
type	bfdlink.h	/^  enum bfd_link_order_type type;$/;"	m	struct:bfd_link_order	typeref:enum:bfd_link_order::bfd_link_order_type
type	expect.h	/^	enum exp_type type;$/;"	m	struct:exp_case	typeref:enum:exp_case::exp_type
type	readline/keymaps.h	/^  char type;$/;"	m	struct:_keymap_entry
type	tcl.h	/^    Tcl_ValueType type;		\/* Indicates intValue or doubleValue is$/;"	m	struct:Tcl_Value
type	tk.h	/^    int type;			\/* Type of option, such as TK_CONFIG_COLOR;$/;"	m	struct:Tk_ConfigSpec
type	tk.h	/^    int type;		\/* Indicates option type;  see below. *\/$/;"	m	struct:__anon30
type	tk.h	/^    int type;$/;"	m	struct:__anon34
type	tk.h	/^    int type;$/;"	m	struct:__anon35
typeName	tcl.h	/^    char *typeName;			\/* The name of the channel type in Tcl$/;"	m	struct:Tcl_ChannelType
typePtr	tcl.h	/^    Tcl_ObjType *typePtr;	\/* Denotes the object's type. Always$/;"	m	struct:Tcl_Obj
typePtr	tk.h	/^    struct Tk_ItemType *typePtr;	\/* Table of procedures that implement$/;"	m	struct:Tk_Item	typeref:struct:Tk_Item::Tk_ItemType
typename	g++/stl_config.h	187;"	d
u	bfd.h	/^  } u;$/;"	m	struct:lineno_cache_entry	typeref:union:lineno_cache_entry::__anon36
u	bfdlink.h	/^    } u;$/;"	m	struct:bfd_link_hash_entry	typeref:union:bfd_link_hash_entry::__anon59
u	bfdlink.h	/^    } u;$/;"	m	struct:bfd_link_order	typeref:union:bfd_link_order::__anon64
u	bfdlink.h	/^    } u;$/;"	m	struct:bfd_link_order_reloc	typeref:union:bfd_link_order_reloc::__anon69
udata	bfd.h	/^    } udata;$/;"	m	struct:symbol_cache_entry	typeref:union:symbol_cache_entry::__anon37
unary_compose	g++/stl_function.h	/^  unary_compose(const Operation1& x, const Operation2& y) : op1(x), op2(y) {}$/;"	f	class:unary_compose
unary_compose	g++/stl_function.h	/^class unary_compose : public unary_function<typename Operation2::argument_type,$/;"	c
unary_function	g++/stl_function.h	/^struct unary_function {$/;"	s
unary_negate	g++/stl_function.h	/^  explicit unary_negate(const Predicate& x) : pred(x) {}$/;"	f	class:unary_negate
unary_negate	g++/stl_function.h	/^class unary_negate$/;"	c
unattached_reloc	bfdlink.h	/^  boolean (*unattached_reloc) PARAMS ((struct bfd_link_info *,$/;"	m	struct:bfd_link_callbacks
unbuffered	g++/streambuf.h	/^    int unbuffered() { return _flags & _IO_UNBUFFERED ? 1 : 0; }$/;"	f	struct:streambuf
unbuffered	g++/streambuf.h	/^    void unbuffered(int i)$/;"	f	struct:streambuf
undef	bfdlink.h	/^	} undef;$/;"	m	union:bfd_link_hash_entry::__anon59	typeref:struct:bfd_link_hash_entry::__anon59::__anon60
undefined_symbol	bfdlink.h	/^  boolean (*undefined_symbol) PARAMS ((struct bfd_link_info *,$/;"	m	struct:bfd_link_callbacks
undefs	bfdlink.h	/^  struct bfd_link_hash_entry *undefs;$/;"	m	struct:bfd_link_hash_table	typeref:struct:bfd_link_hash_table::bfd_link_hash_entry
undefs_tail	bfdlink.h	/^  struct bfd_link_hash_entry *undefs_tail;$/;"	m	struct:bfd_link_hash_table	typeref:struct:bfd_link_hash_table::bfd_link_hash_entry
undo_code	readline/readline.h	/^enum undo_code { UNDO_DELETE, UNDO_INSERT, UNDO_BEGIN, UNDO_END };$/;"	g
undo_list	readline/readline.h	/^typedef struct undo_list {$/;"	s
unget	g++/iostream.h	/^    istream& unget() {$/;"	f	class:istream
unget	g++/iostream.h	/^    istream& unget(char ch) { return putback(ch); }$/;"	f	class:istream
ungetc	g++/iostdio.h	92;"	d
uninitialized_copy	g++/stl_uninitialized.h	/^uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result) $/;"	f	namespace:std
uninitialized_copy	g++/stl_uninitialized.h	/^uninitialized_copy(const char* first, const char* last, char* result) $/;"	f	namespace:std
uninitialized_copy	g++/stl_uninitialized.h	/^uninitialized_copy(const wchar_t* first, const wchar_t* last, wchar_t* result) {$/;"	f	namespace:std
uninitialized_copy_n	g++/stl_uninitialized.h	/^uninitialized_copy_n(InputIterator first, Size count, ForwardIterator result) $/;"	f	namespace:std
uninitialized_fill	g++/stl_uninitialized.h	/^uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x) $/;"	f	namespace:std
uninitialized_fill_n	g++/stl_uninitialized.h	/^uninitialized_fill_n(ForwardIterator first, Size n, const T& x) $/;"	f	namespace:std
unique	g++/std/bastring.h	/^	void unique() { if (rep()->ref > 1) alloc(length(), true); }$/;"	f	class:basic_string
unique	g++/stl_algo.h	/^ForwardIterator unique(ForwardIterator first, ForwardIterator last) {$/;"	f
unique	g++/stl_algo.h	/^ForwardIterator unique(ForwardIterator first, ForwardIterator last,$/;"	f
unique	g++/stl_list.h	/^void list<T, Alloc>::unique() {$/;"	f	class:std::list
unique	g++/stl_list.h	/^void list<T, Alloc>::unique(BinaryPredicate binary_pred) {$/;"	f	class:std::list
unique	g++/stl_slist.h	/^void slist<T,Alloc>::unique()$/;"	f	class:std::slist
unique	g++/stl_slist.h	/^void slist<T,Alloc>::unique(BinaryPredicate pred)$/;"	f	class:std::slist
unique_copy	g++/stl_algo.h	/^inline OutputIterator unique_copy(InputIterator first, InputIterator last,$/;"	f
unitbuf	g++/streambuf.h	/^	   unitbuf=_IO_UNITBUF, stdio=_IO_STDIO$/;"	e	enum:ios::__anon1
unitbuf	g++/streambuf.h	/^	   unitbuf=_IO_UNITBUF, stdio=_IO_STDIO$/;"	e	enum:ios::__anon72
unref	g++/stl_rope.h	/^	  static void unref(RopeBase* t) {}$/;"	f	class:rope
unref	g++/stl_rope.h	/^	  static void unref(RopeBase* t)$/;"	f	class:rope
unref	g++/stl_rope.h	/^	  static void unref(__rope_RopeBase* t) {}$/;"	f	struct:__rope_RopeBase
unref	g++/stl_rope.h	/^	  static void unref(__rope_RopeBase* t)$/;"	f	struct:__rope_RopeBase
unref_nonnil	g++/stl_rope.h	/^	  void unref_nonnil() {}$/;"	f	struct:__rope_RopeBase
unref_nonnil	g++/stl_rope.h	/^	  void unref_nonnil()$/;"	f	struct:__rope_RopeBase
unset	g++/streambuf.h	/^    void unset(state_value flag) { _state &= ~flag; }$/;"	f	class:ios
unsetf	g++/streambuf.h	/^    fmtflags unsetf(fmtflags mask) {$/;"	f	class:ios
updateStringProc	tcl.h	/^    Tcl_UpdateStringProc *updateStringProc;$/;"	m	struct:Tcl_ObjType
upper_bound	g++/stl_algo.h	/^inline ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,$/;"	f
upper_bound	g++/stl_map.h	/^  const_iterator upper_bound(const key_type& x) const {$/;"	f	class:map
upper_bound	g++/stl_map.h	/^  iterator upper_bound(const key_type& x) {return t.upper_bound(x); }$/;"	f	class:map
upper_bound	g++/stl_multimap.h	/^  const_iterator upper_bound(const key_type& x) const {$/;"	f	class:multimap
upper_bound	g++/stl_multimap.h	/^  iterator upper_bound(const key_type& x) {return t.upper_bound(x); }$/;"	f	class:multimap
upper_bound	g++/stl_multiset.h	/^  iterator upper_bound(const key_type& x) const {$/;"	f	class:multiset
upper_bound	g++/stl_set.h	/^  iterator upper_bound(const key_type& x) const {$/;"	f	class:set
upper_bound	g++/stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key& k) const {$/;"	f	class:rb_tree
upper_bound	g++/stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key& k) {$/;"	f	class:rb_tree
uppercase	g++/streambuf.h	/^	   uppercase=_IO_UPPERCASE, showpos=_IO_SHOWPOS,$/;"	e	enum:ios::__anon1
uppercase	g++/streambuf.h	/^	   uppercase=_IO_UPPERCASE, showpos=_IO_SHOWPOS,$/;"	e	enum:ios::__anon72
uppercase_p	readline/chardefs.h	35;"	d
usec	tcl.h	/^    long usec;			\/* Microseconds. *\/$/;"	m	struct:Tcl_Time
used	bfdlink.h	/^  int used;$/;"	m	struct:bfd_elf_version_tree
used_by_bfd	bfd.h	/^   PTR used_by_bfd;$/;"	m	struct:sec
user_set_vma	bfd.h	/^       unsigned int user_set_vma : 1;$/;"	m	struct:sec
userdata	bfd.h	/^   PTR userdata;$/;"	m	struct:sec
usrdata	bfd.h	/^    PTR usrdata;$/;"	m	struct:_bfd
va_alist	include/va-alpha.h	39;"	d
va_alist	include/va-arc.h	31;"	d
va_alist	include/va-clipper.h	34;"	d
va_alist	include/va-h8300.h	38;"	d
va_alist	include/va-i860.h	47;"	d
va_alist	include/va-i960.h	49;"	d
va_alist	include/va-m32r.h	27;"	d
va_alist	include/va-m88k.h	45;"	d
va_alist	include/va-mips.h	124;"	d
va_alist	include/va-mn10200.h	19;"	d
va_alist	include/va-mn10300.h	18;"	d
va_alist	include/va-pa.h	17;"	d
va_alist	include/va-ppc.h	101;"	d
va_alist	include/va-ppc.h	212;"	d
va_alist	include/va-pyr.h	88;"	d
va_alist	include/va-sh.h	59;"	d
va_alist	include/va-sparc.h	37;"	d
va_alist	include/va-spur.h	9;"	d
va_alist	include/va-v850.h	17;"	d
va_alist	include/varargs.h	70;"	d
va_alist	include/varargs.h	91;"	d
va_arg	include/stdarg.h	101;"	d
va_arg	include/stdarg.h	106;"	d
va_arg	include/va-alpha.h	113;"	d
va_arg	include/va-alpha.h	119;"	d
va_arg	include/va-arc.h	86;"	d
va_arg	include/va-arc.h	98;"	d
va_arg	include/va-clipper.h	48;"	d
va_arg	include/va-h8300.h	45;"	d
va_arg	include/va-i860.h	124;"	d
va_arg	include/va-i960.h	59;"	d
va_arg	include/va-m32r.h	65;"	d
va_arg	include/va-m88k.h	73;"	d
va_arg	include/va-mips.h	213;"	d
va_arg	include/va-mips.h	224;"	d
va_arg	include/va-mips.h	242;"	d
va_arg	include/va-mips.h	247;"	d
va_arg	include/va-mips.h	257;"	d
va_arg	include/va-mips.h	265;"	d
va_arg	include/va-mn10200.h	30;"	d
va_arg	include/va-mn10300.h	29;"	d
va_arg	include/va-pa.h	35;"	d
va_arg	include/va-ppc.h	118;"	d
va_arg	include/va-ppc.h	222;"	d
va_arg	include/va-pyr.h	112;"	d
va_arg	include/va-sh.h	162;"	d
va_arg	include/va-sh.h	192;"	d
va_arg	include/va-sparc.h	144;"	d
va_arg	include/va-sparc.h	96;"	d
va_arg	include/va-spur.h	39;"	d
va_arg	include/va-v850.h	28;"	d
va_arg	include/varargs.h	120;"	d
va_arg	include/varargs.h	125;"	d
va_arg	include/varargs.h	76;"	d
va_dcl	include/va-alpha.h	40;"	d
va_dcl	include/va-arc.h	32;"	d
va_dcl	include/va-clipper.h	36;"	d
va_dcl	include/va-h8300.h	40;"	d
va_dcl	include/va-i860.h	49;"	d
va_dcl	include/va-i860.h	51;"	d
va_dcl	include/va-i960.h	50;"	d
va_dcl	include/va-m32r.h	29;"	d
va_dcl	include/va-m88k.h	46;"	d
va_dcl	include/va-mips.h	127;"	d
va_dcl	include/va-mips.h	129;"	d
va_dcl	include/va-mn10200.h	20;"	d
va_dcl	include/va-mn10300.h	19;"	d
va_dcl	include/va-pa.h	31;"	d
va_dcl	include/va-ppc.h	102;"	d
va_dcl	include/va-ppc.h	213;"	d
va_dcl	include/va-pyr.h	93;"	d
va_dcl	include/va-sh.h	60;"	d
va_dcl	include/va-sparc.h	38;"	d
va_dcl	include/va-spur.h	21;"	d
va_dcl	include/va-v850.h	18;"	d
va_dcl	include/varargs.h	71;"	d
va_dcl	include/varargs.h	93;"	d
va_end	include/stdarg.h	92;"	d
va_end	include/stdarg.h	94;"	d
va_end	include/va-alpha.h	68;"	d
va_end	include/va-arc.h	69;"	d
va_end	include/va-clipper.h	55;"	d
va_end	include/va-h8300.h	51;"	d
va_end	include/va-i860.h	96;"	d
va_end	include/va-i960.h	73;"	d
va_end	include/va-m32r.h	35;"	d
va_end	include/va-m88k.h	82;"	d
va_end	include/va-mips.h	170;"	d
va_end	include/va-mn10200.h	27;"	d
va_end	include/va-mn10200.h	29;"	d
va_end	include/va-mn10300.h	26;"	d
va_end	include/va-mn10300.h	28;"	d
va_end	include/va-pa.h	47;"	d
va_end	include/va-ppc.h	171;"	d
va_end	include/va-ppc.h	227;"	d
va_end	include/va-pyr.h	128;"	d
va_end	include/va-sh.h	114;"	d
va_end	include/va-sparc.h	78;"	d
va_end	include/va-spur.h	32;"	d
va_end	include/va-v850.h	25;"	d
va_end	include/va-v850.h	27;"	d
va_end	include/varargs.h	108;"	d
va_end	include/varargs.h	74;"	d
va_list	include/stdarg.h	/^typedef __gnuc_va_list va_list;$/;"	t
va_list	include/va-alpha.h	32;"	d
va_list	include/va-clipper.h	18;"	d
va_list	include/va-spur.h	/^} va_list;$/;"	t	typeref:struct:__anon21
va_list	include/va-spur.h	/^} va_list;$/;"	t	typeref:struct:__anon46
va_list	include/varargs.h	/^typedef __gnuc_va_list va_list;$/;"	t
va_list	include/varargs.h	72;"	d
va_start	include/stdarg.h	89;"	d
va_start	include/va-alpha.h	42;"	d
va_start	include/va-alpha.h	44;"	d
va_start	include/va-alpha.h	55;"	d
va_start	include/va-alpha.h	59;"	d
va_start	include/va-arc.h	25;"	d
va_start	include/va-arc.h	33;"	d
va_start	include/va-clipper.h	28;"	d
va_start	include/va-clipper.h	37;"	d
va_start	include/va-h8300.h	33;"	d
va_start	include/va-h8300.h	41;"	d
va_start	include/va-i860.h	53;"	d
va_start	include/va-i860.h	60;"	d
va_start	include/va-i960.h	41;"	d
va_start	include/va-i960.h	51;"	d
va_start	include/va-m32r.h	22;"	d
va_start	include/va-m32r.h	30;"	d
va_start	include/va-m88k.h	25;"	d
va_start	include/va-m88k.h	29;"	d
va_start	include/va-m88k.h	38;"	d
va_start	include/va-m88k.h	40;"	d
va_start	include/va-mips.h	104;"	d
va_start	include/va-mips.h	114;"	d
va_start	include/va-mips.h	120;"	d
va_start	include/va-mips.h	134;"	d
va_start	include/va-mips.h	142;"	d
va_start	include/va-mips.h	152;"	d
va_start	include/va-mips.h	159;"	d
va_start	include/va-mips.h	163;"	d
va_start	include/va-mips.h	96;"	d
va_start	include/va-mn10200.h	16;"	d
va_start	include/va-mn10200.h	21;"	d
va_start	include/va-mn10300.h	15;"	d
va_start	include/va-mn10300.h	20;"	d
va_start	include/va-pa.h	27;"	d
va_start	include/va-pa.h	32;"	d
va_start	include/va-ppc.h	100;"	d
va_start	include/va-ppc.h	200;"	d
va_start	include/va-ppc.h	207;"	d
va_start	include/va-ppc.h	95;"	d
va_start	include/va-pyr.h	98;"	d
va_start	include/va-sh.h	38;"	d
va_start	include/va-sh.h	52;"	d
va_start	include/va-sh.h	64;"	d
va_start	include/va-sh.h	79;"	d
va_start	include/va-sparc.h	28;"	d
va_start	include/va-sparc.h	31;"	d
va_start	include/va-sparc.h	41;"	d
va_start	include/va-sparc.h	43;"	d
va_start	include/va-spur.h	29;"	d
va_start	include/va-v850.h	13;"	d
va_start	include/va-v850.h	19;"	d
va_start	include/varargs.h	106;"	d
va_start	include/varargs.h	73;"	d
val	g++/stl_function.h	/^  Result val;$/;"	m	struct:constant_binary_fun
val	g++/stl_function.h	/^  Result val;$/;"	m	struct:constant_unary_fun
val	g++/stl_function.h	/^  result_type val;$/;"	m	struct:constant_void_fun
val	g++/stl_hashtable.h	/^  Value val;$/;"	m	struct:__hashtable_node
value	bfd.h	/^  symvalue value;$/;"	m	struct:_symbol_info
value	bfd.h	/^  symvalue value;$/;"	m	struct:symbol_cache_entry
value	bfdlink.h	/^	  bfd_vma value;	\/* Symbol value.  *\/$/;"	m	struct:bfd_link_hash_entry::__anon59::__anon61
value	bfdlink.h	/^	  unsigned int value;$/;"	m	struct:bfd_link_order::__anon64::__anon66
value	expect.h	/^	int value;		\/* value to be returned upon match *\/$/;"	m	struct:exp_case
value	g++/stl_function.h	/^  typename Operation::first_argument_type value;$/;"	m	class:binder1st
value	g++/stl_function.h	/^  typename Operation::second_argument_type value;$/;"	m	class:binder2nd
value	g++/stl_iterator.h	/^  T value;$/;"	m	class:istream_iterator
value	g++/stl_tree.h	/^  static reference value(base_ptr x) { return ((link_type)x)->value_field; }$/;"	f	class:rb_tree
value	g++/stl_tree.h	/^  static reference value(link_type x) { return x->value_field; }$/;"	f	class:rb_tree
value_comp	g++/stl_map.h	/^  value_compare value_comp() const { return value_compare(t.key_comp()); }$/;"	f	class:map
value_comp	g++/stl_multimap.h	/^  value_compare value_comp() const { return value_compare(t.key_comp()); }$/;"	f	class:multimap
value_comp	g++/stl_multiset.h	/^  value_compare value_comp() const { return t.key_comp(); }$/;"	f	class:multiset
value_comp	g++/stl_set.h	/^  value_compare value_comp() const { return t.key_comp(); }$/;"	f	class:set
value_compare	g++/stl_map.h	/^    value_compare(Compare c) : comp(c) {}$/;"	f	class:map::value_compare
value_compare	g++/stl_map.h	/^  class value_compare$/;"	c	class:map
value_compare	g++/stl_multimap.h	/^    value_compare(Compare c) : comp(c) {}$/;"	f	class:multimap::value_compare
value_compare	g++/stl_multimap.h	/^  class value_compare : public binary_function<value_type, value_type, bool> {$/;"	c	class:multimap
value_compare	g++/stl_multiset.h	/^  typedef Compare value_compare;$/;"	t	class:multiset
value_compare	g++/stl_set.h	/^  typedef Compare value_compare;$/;"	t	class:set
value_field	g++/stl_tree.h	/^	Value value_field;$/;"	m	struct:__rb_tree_node
value_type	g++/defalloc.h	/^    typedef T value_type;$/;"	t	class:allocator
value_type	g++/std/bastring.h	/^	typedef typename traits::char_type				value_type;$/;"	t	class:basic_string
value_type	g++/stl_bvector.h	/^  typedef bool value_type;$/;"	t	class:vector
value_type	g++/stl_deque.h	/^	typedef T 													value_type;$/;"	t	struct:std::__deque_iterator
value_type	g++/stl_deque.h	/^	typedef T 												value_type;$/;"	t	class:std::deque
value_type	g++/stl_deque.h	/^inline T* value_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) $/;"	f	namespace:std
value_type	g++/stl_hash_map.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_map
value_type	g++/stl_hash_map.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_multimap
value_type	g++/stl_hash_set.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_multiset
value_type	g++/stl_hash_set.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_set
value_type	g++/stl_hashtable.h	/^  typedef Value value_type;$/;"	t	class:hashtable
value_type	g++/stl_hashtable.h	/^  typedef Value value_type;$/;"	t	struct:__hashtable_const_iterator
value_type	g++/stl_hashtable.h	/^  typedef Value value_type;$/;"	t	struct:__hashtable_iterator
value_type	g++/stl_hashtable.h	/^inline V* value_type(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
value_type	g++/stl_hashtable.h	/^value_type(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
value_type	g++/stl_iterator.h	/^          value_type;$/;"	t	class:reverse_iterator
value_type	g++/stl_iterator.h	/^  typedef T                          value_type;$/;"	t	class:reverse_bidirectional_iterator
value_type	g++/stl_iterator.h	/^  typedef T                          value_type;$/;"	t	class:reverse_iterator
value_type	g++/stl_iterator.h	/^  typedef T                          value_type;$/;"	t	struct:bidirectional_iterator
value_type	g++/stl_iterator.h	/^  typedef T                          value_type;$/;"	t	struct:iterator_traits
value_type	g++/stl_iterator.h	/^  typedef T                          value_type;$/;"	t	struct:random_access_iterator
value_type	g++/stl_iterator.h	/^  typedef T                    value_type;$/;"	t	struct:forward_iterator
value_type	g++/stl_iterator.h	/^  typedef T                  value_type;$/;"	t	class:istream_iterator
value_type	g++/stl_iterator.h	/^  typedef T                  value_type;$/;"	t	struct:input_iterator
value_type	g++/stl_iterator.h	/^  typedef T         value_type;$/;"	t	struct:iterator
value_type	g++/stl_iterator.h	/^  typedef typename Iterator::value_type        value_type;$/;"	t	struct:iterator_traits
value_type	g++/stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:back_insert_iterator
value_type	g++/stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:front_insert_iterator
value_type	g++/stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:insert_iterator
value_type	g++/stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:ostream_iterator
value_type	g++/stl_iterator.h	/^  typedef void                value_type;$/;"	t	struct:output_iterator
value_type	g++/stl_iterator.h	/^inline T* value_type(const T*) { return (T*)(0); }$/;"	f
value_type	g++/stl_iterator.h	/^inline T* value_type(const bidirectional_iterator<T, Distance>&) {$/;"	f
value_type	g++/stl_iterator.h	/^inline T* value_type(const forward_iterator<T, Distance>&) {$/;"	f
value_type	g++/stl_iterator.h	/^inline T* value_type(const input_iterator<T, Distance>&) {$/;"	f
value_type	g++/stl_iterator.h	/^inline T* value_type(const istream_iterator<T, Distance>&) { return (T*) 0; }$/;"	f
value_type	g++/stl_iterator.h	/^inline T* value_type(const random_access_iterator<T, Distance>&) {$/;"	f
value_type	g++/stl_iterator.h	/^inline T* value_type(const reverse_iterator<RandomAccessIterator, T,$/;"	f
value_type	g++/stl_iterator.h	/^value_type(const Iterator&) {$/;"	f
value_type	g++/stl_iterator.h	/^value_type(const reverse_bidirectional_iterator<BidirectionalIterator, T,$/;"	f
value_type	g++/stl_list.h	/^	typedef T 										value_type;$/;"	t	class:std::list
value_type	g++/stl_list.h	/^	typedef T value_type;$/;"	t	struct:std::__list_iterator
value_type	g++/stl_list.h	/^value_type(const __list_iterator<T, Ref, Ptr>&) {$/;"	f	namespace:std
value_type	g++/stl_map.h	/^  typedef pair<const Key, T> value_type;$/;"	t	class:map
value_type	g++/stl_multimap.h	/^  typedef pair<const Key, T> value_type;$/;"	t	class:multimap
value_type	g++/stl_multiset.h	/^  typedef Key value_type;$/;"	t	class:multiset
value_type	g++/stl_queue.h	/^	typedef typename Sequence::value_type value_type;$/;"	t	class:priority_queue
value_type	g++/stl_queue.h	/^	typedef typename Sequence::value_type value_type;$/;"	t	class:queue
value_type	g++/stl_raw_storage_iter.h	/^  typedef void                value_type;$/;"	t	class:raw_storage_iterator
value_type	g++/stl_rope.h	/^	    typedef typename sequence::value_type value_type;$/;"	t	class:sequence_buffer
value_type	g++/stl_rope.h	/^	typedef charT value_type;$/;"	t	class:rope
value_type	g++/stl_set.h	/^  typedef Key value_type;$/;"	t	class:set
value_type	g++/stl_slist.h	/^	typedef T 										value_type;$/;"	t	class:std::slist
value_type	g++/stl_slist.h	/^	typedef T 										value_type;$/;"	t	struct:std::__slist_iterator
value_type	g++/stl_slist.h	/^value_type(const __slist_iterator<T, Ref, Ptr>&) {$/;"	f	namespace:std
value_type	g++/stl_stack.h	/^  typedef typename Sequence::value_type value_type;$/;"	t	class:stack
value_type	g++/stl_tree.h	/^	typedef Value 													value_type;$/;"	t	struct:__rb_tree_iterator
value_type	g++/stl_tree.h	/^  typedef Value value_type;$/;"	t	class:rb_tree
value_type	g++/stl_tree.h	/^inline Value* value_type(const __rb_tree_iterator<Value, Ref, Ptr>&) {$/;"	f
value_type	g++/stl_vector.h	/^	typedef T                 					value_type;$/;"	t	class:vector
vector	g++/stl_bvector.h	/^template<class Alloc> class vector<bool, Alloc>$/;"	c
vector	g++/stl_vector.h	/^	explicit vector(size_type n) { fill_initialize(n, T()); }$/;"	f	class:vector
vector	g++/stl_vector.h	/^	vector() : start(0), finish(0), end_of_storage(0) {}$/;"	f	class:vector
vector	g++/stl_vector.h	/^	vector(InputIterator first, InputIterator last) :	start(0), finish(0), end_of_storage(0)$/;"	f	class:vector
vector	g++/stl_vector.h	/^	vector(const vector<T, Alloc>& x) $/;"	f	class:vector
vector	g++/stl_vector.h	/^	vector(int n, const T& value) { fill_initialize(n, value);}$/;"	f	class:vector
vector	g++/stl_vector.h	/^	vector(long n, const T& value) { fill_initialize(n, value);}$/;"	f	class:vector
vector	g++/stl_vector.h	/^	vector(size_type n, const T& value) { fill_initialize(n, value); }$/;"	f	class:vector
vector	g++/stl_vector.h	/^class vector {$/;"	c
vernum	bfdlink.h	/^  unsigned int vernum;$/;"	m	struct:bfd_elf_version_tree
versados_data	bfd.h	/^      struct versados_data_struct *versados_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::versados_data_struct
version_needed	bfdlink.h	/^  struct bfd_elf_version_tree *version_needed;$/;"	m	struct:bfd_elf_version_deps	typeref:struct:bfd_elf_version_deps::bfd_elf_version_tree
vfprintf	g++/iostdio.h	93;"	d
visual	tk.h	/^    Visual *visual;$/;"	m	struct:Tk_FakeWin
vma	bfd.h	/^   bfd_vma vma;$/;"	m	struct:sec
void_pointer	g++/stl_list.h	/^	typedef void* 									void_pointer;$/;"	t	class:std::list
void_pointer	g++/stl_list.h	/^	typedef void* void_pointer;$/;"	t	struct:std::__list_node
void_pointer	g++/stl_tree.h	/^  typedef void* void_pointer;$/;"	t	class:rb_tree
vprintf	g++/iostdio.h	94;"	d
vsprintf	g++/iostdio.h	95;"	d
vtable	g++/libio.h	/^  const void *vtable;$/;"	m	struct:_IO_cookie_file
vtable	g++/libioP.h	/^  const struct _IO_jump_t *vtable;$/;"	m	struct:_IO_FILE_plus	typeref:struct:_IO_FILE_plus::_IO_jump_t
warning	bfdlink.h	/^	  const char *warning;	\/* Warning (bfd_link_hash_warning only).  *\/$/;"	m	struct:bfd_link_hash_entry::__anon59::__anon62
warning	bfdlink.h	/^  boolean (*warning) PARAMS ((struct bfd_link_info *,$/;"	m	struct:bfd_link_callbacks
watchProc	tcl.h	/^    Tcl_DriverWatchProc *watchProc;	\/* Set up the notifier to watch$/;"	m	struct:Tcl_ChannelType
what	readline/readline.h	/^  enum undo_code what;		\/* Delete, Insert, Begin, End. *\/$/;"	m	struct:undo_list	typeref:enum:undo_list::undo_code
where	bfd.h	/^    file_ptr where;              $/;"	m	struct:_bfd
whitespace	readline/chardefs.h	13;"	d
width	g++/streambuf.h	/^    int width() const { return _width; }$/;"	f	class:ios
width	g++/streambuf.h	/^    int width(int val) { int save = _width; _width = val; return save; }$/;"	f	class:ios
width	tk.h	/^    int		width;		\/* Width of block, in pixels. *\/$/;"	m	struct:Tk_PhotoImageBlock
window	tk.h	/^    Window window;	    \/* Window in which event occurred. *\/$/;"	m	struct:__anon35
window	tk.h	/^    Window window;$/;"	m	struct:Tk_FakeWin
wint_t	include/stddef.h	/^typedef __WINT_TYPE__ wint_t;$/;"	t
words	tcl.h	/^	int words[1];			\/* Multiple integer words for key.$/;"	m	union:Tcl_HashEntry::__anon56
wrap_hash	bfdlink.h	/^  struct bfd_hash_table *wrap_hash;$/;"	m	struct:bfd_link_info	typeref:struct:bfd_link_info::bfd_hash_table
write	g++/iostream.h	/^    ostream& write(const signed char *s, streamsize n)$/;"	f	class:ostream
write	g++/iostream.h	/^    ostream& write(const unsigned char *s, streamsize n)$/;"	f	class:ostream
write	g++/iostream.h	/^    ostream& write(const void *s, streamsize n)$/;"	f	class:ostream
write	g++/libio.h	/^  _IO_ssize_t (*write) __P ((struct _IO_FILE *, const void *, _IO_ssize_t));$/;"	m	struct:__anon3
write	g++/libio.h	/^  _IO_ssize_t (*write) __P ((struct _IO_FILE *, const void *, _IO_ssize_t));$/;"	m	struct:__anon74
write	g++/stl_rope.h	/^	sequence_buffer& write(value_type *s, size_t len)$/;"	f	class:sequence_buffer
write_armap	bfd.h	/^  boolean  (*write_armap) PARAMS ((bfd *arch, $/;"	m	struct:bfd_target
write_direction	bfd.h	/^                        write_direction = 2,$/;"	e	enum:_bfd::bfd_direction
wrope	g++/stl_rope.h	/^typedef rope<wchar_t, __ALLOC> wrope;$/;"	t
x	tk.h	/^    int x, y;		    \/* pointer x, y coordinates in event window *\/$/;"	m	struct:__anon34
x1	tk.h	/^    int x1, y1, x2, y2;			\/* Bounding box for item, in integer$/;"	m	struct:Tk_Item
x2	tk.h	/^    int x1, y1, x2, y2;			\/* Bounding box for item, in integer$/;"	m	struct:Tk_Item
x_root	tk.h	/^    int x_root, y_root;	    \/* coordinates relative to root *\/$/;"	m	struct:__anon34
xchain	g++/streambuf.h	/^    _IO_FILE*& xchain() { return _chain; }$/;"	f	struct:streambuf
xcoff_obj_data	bfd.h	/^      struct xcoff_tdata *xcoff_obj_data;$/;"	m	union:_bfd::__anon38	typeref:struct:_bfd::__anon38::xcoff_tdata
xflags	g++/streambuf.h	/^    int xflags() { return _IO_file_flags; }$/;"	f	struct:streambuf
xflags	g++/streambuf.h	/^    int xflags(int f) {int fl = _IO_file_flags; _IO_file_flags = f; return fl;}$/;"	f	struct:streambuf
xor	include/iso646.h	13;"	d
xor_eq	include/iso646.h	14;"	d
xput_char	g++/streambuf.h	/^    void xput_char(char c) { *_IO_write_ptr++ = c; }$/;"	f	struct:streambuf
xsetflags	g++/streambuf.h	/^    void xsetflags(int f) { _IO_file_flags |= f; }$/;"	f	struct:streambuf
xsetflags	g++/streambuf.h	/^    void xsetflags(int f, int mask)$/;"	f	struct:streambuf
xvec	bfd.h	/^    const struct bfd_target *xvec;$/;"	m	struct:_bfd	typeref:struct:_bfd::bfd_target
y	tk.h	/^    int x, y;		    \/* pointer x, y coordinates in event window *\/$/;"	m	struct:__anon34
y1	tk.h	/^    int x1, y1, x2, y2;			\/* Bounding box for item, in integer$/;"	m	struct:Tk_Item
y2	tk.h	/^    int x1, y1, x2, y2;			\/* Bounding box for item, in integer$/;"	m	struct:Tk_Item
y_root	tk.h	/^    int x_root, y_root;	    \/* coordinates relative to root *\/$/;"	m	struct:__anon34
yyFlexLexer	FlexLexer.h	/^class yyFlexLexer : public FlexLexer {$/;"	c
yyFlexLexerOnce	FlexLexer.h	100;"	d
yy_c_buf_p	FlexLexer.h	/^	char* yy_c_buf_p;$/;"	m	class:yyFlexLexer
yy_current_buffer	FlexLexer.h	/^	struct yy_buffer_state* yy_current_buffer;$/;"	m	class:yyFlexLexer	typeref:struct:yyFlexLexer::yy_buffer_state
yy_did_buffer_switch_on_eof	FlexLexer.h	/^	int yy_did_buffer_switch_on_eof;$/;"	m	class:yyFlexLexer
yy_flex_debug	FlexLexer.h	/^	int yy_flex_debug;	\/\/ only has effect with -d or "%option debug"$/;"	m	class:FlexLexer
yy_full_lp	FlexLexer.h	/^	int yy_full_lp;$/;"	m	class:yyFlexLexer
yy_full_match	FlexLexer.h	/^	char* yy_full_match;$/;"	m	class:yyFlexLexer
yy_full_state	FlexLexer.h	/^	int* yy_full_state;$/;"	m	class:yyFlexLexer
yy_hold_char	FlexLexer.h	/^	char yy_hold_char;$/;"	m	class:yyFlexLexer
yy_init	FlexLexer.h	/^	int yy_init;		\/\/ whether we need to initialize$/;"	m	class:yyFlexLexer
yy_last_accepting_cpos	FlexLexer.h	/^	char* yy_last_accepting_cpos;$/;"	m	class:yyFlexLexer
yy_last_accepting_state	FlexLexer.h	/^	yy_state_type yy_last_accepting_state;$/;"	m	class:yyFlexLexer
yy_looking_for_trail_begin	FlexLexer.h	/^	int yy_looking_for_trail_begin;$/;"	m	class:yyFlexLexer
yy_lp	FlexLexer.h	/^	int yy_lp;$/;"	m	class:yyFlexLexer
yy_more_flag	FlexLexer.h	/^	int yy_more_flag;$/;"	m	class:yyFlexLexer
yy_more_len	FlexLexer.h	/^	int yy_more_len;$/;"	m	class:yyFlexLexer
yy_n_chars	FlexLexer.h	/^	int yy_n_chars;$/;"	m	class:yyFlexLexer
yy_start	FlexLexer.h	/^	int yy_start;		\/\/ start state number$/;"	m	class:yyFlexLexer
yy_start_stack	FlexLexer.h	/^	int* yy_start_stack;$/;"	m	class:yyFlexLexer
yy_start_stack_depth	FlexLexer.h	/^	int yy_start_stack_depth;$/;"	m	class:yyFlexLexer
yy_start_stack_ptr	FlexLexer.h	/^	int yy_start_stack_ptr;$/;"	m	class:yyFlexLexer
yy_state_buf	FlexLexer.h	/^	yy_state_type* yy_state_buf;$/;"	m	class:yyFlexLexer
yy_state_ptr	FlexLexer.h	/^	yy_state_type* yy_state_ptr;$/;"	m	class:yyFlexLexer
yy_state_type	FlexLexer.h	/^typedef int yy_state_type;$/;"	t
yyin	FlexLexer.h	/^	istream* yyin;	\/\/ input source for default LexerInput$/;"	m	class:yyFlexLexer
yyleng	FlexLexer.h	/^	int yyleng;$/;"	m	class:FlexLexer
yylex	FlexLexer.h	/^	int yylex( istream* new_in, ostream* new_out = 0 )$/;"	f	class:FlexLexer
yylineno	FlexLexer.h	/^	int yylineno;		\/\/ only maintained if you use %option yylineno$/;"	m	class:FlexLexer
yyout	FlexLexer.h	/^	ostream* yyout;	\/\/ output sink for default LexerOutput$/;"	m	class:yyFlexLexer
yytext	FlexLexer.h	/^	char* yytext;$/;"	m	class:FlexLexer
~FlexLexer	FlexLexer.h	/^	virtual ~FlexLexer()	{ }$/;"	f	class:FlexLexer
~__BVECTOR	g++/stl_bvector.h	/^  ~__BVECTOR() { deallocate(); }$/;"	f	class:vector
~__rope_RopeSubstring	g++/stl_rope.h	/^    virtual ~__rope_RopeSubstring() {}$/;"	f	struct:__rope_RopeSubstring
~__rope_char_consumer	g++/stl_rope.h	/^	virtual ~__rope_char_consumer() {};$/;"	f	class:__rope_char_consumer
~__rope_find_char_char_consumer	g++/ropeimpl.h	/^	~__rope_find_char_char_consumer() {}$/;"	f	class:__rope_find_char_char_consumer
~__rope_flatten_char_consumer	g++/ropeimpl.h	/^	~__rope_flatten_char_consumer() {}$/;"	f	class:__rope_flatten_char_consumer
~__rope_insert_char_consumer	g++/ropeimpl.h	/^	~__rope_insert_char_consumer() { };$/;"	f	class:__rope_insert_char_consumer
~__rope_iterator	g++/stl_rope.h	/^    ~__rope_iterator() {$/;"	f	class:__rope_iterator
~__rope_self_destruct_ptr	g++/stl_rope.h	/^    ~__rope_self_destruct_ptr() { __rope_RopeBase<charT,Alloc>::unref(ptr); }$/;"	f	struct:__rope_self_destruct_ptr
~basic_string	g++/std/bastring.h	/^	~basic_string (){ rep()->release (); }$/;"	f	class:basic_string
~char_producer	g++/stl_rope.h	/^	virtual ~char_producer() {};$/;"	f	class:char_producer
~deque	g++/stl_deque.h	/^	~deque() $/;"	f	class:std::deque
~hashtable	g++/stl_hashtable.h	/^  ~hashtable() { clear(); }$/;"	f	class:hashtable
~ios	g++/streambuf.h	/^inline ios::~ios() {$/;"	f	class:ios
~list	g++/stl_list.h	/^	~list() {$/;"	f	class:std::list
~rb_tree	g++/stl_tree.h	/^  ~rb_tree() {$/;"	f	class:rb_tree
~rope	g++/stl_rope.h	/^	~rope()$/;"	f	class:rope
~sequence_buffer	g++/stl_rope.h	/^	~sequence_buffer() { flush(); }$/;"	f	class:sequence_buffer
~slist	g++/stl_slist.h	/^	~slist() { clear(); }$/;"	f	class:std::slist
~temporary_buffer	g++/stl_tempbuf.h	/^  ~temporary_buffer() {  $/;"	f	class:temporary_buffer
~vector	g++/stl_vector.h	/^	~vector() $/;"	f	class:vector
